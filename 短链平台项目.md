[TOC]

# 短链平台项目

## 1.需求文档如何写

```
参考网址：
https://zhuanlan.zhihu.com/p/428514067
```

![1673064381011](短链平台项目.assets/1673064381011.png)

## 2.短链平台背景介绍

### 2.1什么是短链

![1673064684700](短链平台项目.assets/1673064684700.png)

### 2.2短链解决的痛点

```
1.公司电商产品推⼴、业务活动⻚、⼴告落地⻚ 缺少实时【数据反馈和渠道效果分析】
2.⽼项⽬业务推⼴【没⼈维护，⽆法做埋点】需要统计效果
例⼦ https://tongji.baidu.com/web/demo/overview/index?siteId=16847648
3.APP和营销活动发送营销短信链接过长，【浪费短信发送费⽤】
4.国内反垄断后，微信、抖⾳、淘宝 流量互通，很多知识付费公司需要做 私域流量、社群运营
5.可以对外做产品输出，实现商业化能⼒增加公司营收
6.积累终端数据和⼈群数据，为公司未来产品⼈群做策略助⼒
```

![1673064999133](短链平台项目.assets/1673064999133.png)

### 2.3短链平台的盈利点

```
1.⽤户按量付费，根据流量包选择付费购买对应的套餐
2.不同流量包权益不⼀样
3.每天可以创建的短链次数不⼀样
4.流量包使⽤时间限制、⽀持流量包叠加
5.注册⽤户每天有⼀定免费使⽤次数，但是不能查看数据
```

### 2.4短链平台产品目标

```
1.满⾜公司现有业务的营销推⼴需求、数据分析和拉新促活能⼒
2.对外进⾏付费商⽤，⽀持企业私有化部署
3.⾸年⽇活⽤户： 10万
4.⾸年⽇新增短链数据：10万*50 = 500万
5.年新增⽤户数：50万/1年
6.年营收⽬标: 10万付费⽤户 * 客单价200元 = 2千万
7.新增短链：50条/⽤户每⽇
8.年私有化部署⽤户数：1K⽤户 * 3万/单价 = 3千万
```

## 3管理方法论

### 3.1PEST方法论

```
指的是政治（Political）、经济（Economic）、社会（Social）和技术（Technological）
1.政治环境主要是看我们的国家现在是否⿎励相关的业务
2.经济环境⼜可以分为宏观经济和微观经济，包括居⺠消费⽔平、产业结构
3.社会环境则是说跟社会的⻛俗习惯是否吻合
4.技术环境当然就是说的我们的技术实⼒（ASML光刻机）
```

**案例：**

```
BAT区块链⼤⽜找你开发特币交易平台app
P 国家出台了相关政策、法律法规监管
E ⼤家有闲钱，现在⼈居可⽀配收⼊⾼
S ⼈⼝规模⼤，⽣活⽅式改变，投资理财越来越多
T 团队已有对应的技术，⾏业领先，移动互联⽹成熟
```

### 3.2数据分析模型AARRR

```
什么是AARRR⽤户增⻓模型
AARRR是Acquisition、Activation、Retention、Revenue、Referral 五个单词的缩写，对应⽤户⽣命周期中的5个重要环节。
通俗来说就是⼀个产品从0~1到100的⽅法论
指引产品运营在不同的产品运营阶段，思考哪些关键节点，更好各个节点的指标数据


AARRR详细解释
获取：新⽤户⾸单免费/低价(瑞幸、拼多多)、⼚商预装(⼿机)、买量投放
激活：app推送、短信推送、产品价值激活
留存：签到、活动短信推送、平台价值提供
收益：平台⼴告、电商变现、付费会员、融资、软件服务
传播：好友助⼒、分享抽奖、兄弟砍我⼀⼑
```

### 3.3SWOT态势分析法

```
什么是SWOT态势分析
官⽅：⽤来确定企业⾃身的竞争优势、劣势、外部市场的机会和威胁，从⽽将公司的战略与公司内部资源、外部环境有机地结合起来的⼀种科学的分析⽅法

4个单词的缩写 优势=strength、劣势=weakness、机会=opportunity、威胁=threats
优势和弱势是内部环境的分析，机会和威胁是对于外部环境的分析



外部的机会正好是你的优势，赶紧利⽤起来
外部的机会但是你的劣势，需要改进
⾃身具有优势但外部存在威胁，就需要时刻思考、保持警惕
是威胁⼜是你的劣势，就规避并消除
```

![1673082500836](短链平台项目.assets/1673092926589.png)

**案例**

```
个⼈做技术Leader能⼒分析（⼯作3年，⾼级java，技术能力不错，项⽬组⻓刚离职）
优势：技术不错、对公司业务熟悉（个⼈内部）
劣势：项⽬管理能⼒不⾜、PPT汇报能⼒不⾜（个⼈内部）
机会: 独⽴负责的项⽬把控、直接和领导汇报，成为管理层（个⼈外部）
威胁：项⽬的规范机制没有建⽴、项⽬的核⼼难点没有攻破、加班比较多（个⼈外部）


技术解决⽅案分析（团队熟悉RabbitMQ，新来的组⻓熟悉RocketMQ，技术选型思考）
优势：RabbitMQ团队多⼈⽤过、AMQP跨语⾔、模型API丰富（团队内部）
劣势：阅读过源码的⼈过少, Erlang开发，⼆次修改不容易，项⽬组⻓对这个不熟悉（团队内部）
机会：项⽬可以快速上线，减少采坑（团队外部）
威胁：未来可能有更强⼤的MQ产品出现或公司改动架构（团队外部）


总结：根据SWOT进⾏充分分析，然后进⾏取舍选择，考虑更全⾯（对⽐没⽤这个分析你会怎么选择）
```

### 3.4SMART方法论

```
什么是SMART⽅法论
源于国外管理⼤师的《管理的实践》
是为了利于员⼯更加明确⾼效地⼯作，更是为了管理者将来对员⼯实施绩效考核提供了考核⽬标和考核标准，使考核更加科学化、规范化


是5个单词的缩写
SMART原则【⽬标管理、设置】
Specific：⽬标要具体
Measurable：⽬标成果要可衡量（量化）
Attainable：⽬标要可实现，避免过⾼/过低
Relevant：与其他⽬标有⼀定的相关性
Time bound：⽬标必须有明确的期限
意义：在制定⼯作⽬标或者任务⽬标时，考虑⼀下⽬标与计划是不是SMART化的。只有具备SMART化的计划才是具有良好可实施性的，也才能指导保证计划得以实现
```

**案例**

```
短链平台项⽬组成员，每天需要开晨会-并记录 ( 周⼀早上团队开周会，每个⼈列出本周事项安排)
```

![1673087344373](短链平台项目.assets/1673087344373.png)

```
张三的周报如下
周三前完成短链平台数据库设计并输出相关sql⽂件（SMART）
周四前完成短链平台整体架构搭建和⼯作任务拆分并评审完成（SMART）
周⼆完成短链微服务开发⼯作 (SM RT)
开发账号微服务 (S)
解决⽼项⽬的bug ( )
周⼆完成优化电商项⽬⾥⾯的下单接⼝RT响应时间，把500ms优化到200ms响应（SMART）
```

## 4.短链平台架构设计

### 4.1名词解释

```
短链：原始链接缩短后的链接
ABTest: 为同一个产品目标制定多个方案，通过数据分析得出更符合目标的方案
KA（KeyAccount）：关键客户、重点客户
数据埋点：通过在程序中植入代码的方式，记录用户在软件（web、app、小程序）上的操作行为的技术手段,事件是记录用户在软件中操作行为的标签，如，用户在首页的曝光事件、按钮的点击事件等
公有云：指第三方提供商为用户提供的能够使用的云，比如我们经常使 用阿里云即是一种公有云
私有云：拥有基础设施并可以控制在此设施上部署应用程序的方式，核心属性是专有资源
SaaS服务：软件即服务，产品上用户只需要注册一个B端产品，就可以使用软件服务
私有化部署：将程序、业务数据部署在内网的本地服务器上、将核心数据掌握在自己手中
私域流量：从公域（internet）包括 平台、媒体渠道、合作伙伴等、引流到自己私域（官网、微信）的流量
公域流量：指商家直接入驻平台实现流量转换， 比如拼多多、京东、淘宝、抖音等，以及内容付费行业的喜马拉雅、知乎、得到等公域流量平台
AARRR模型：用户生命周期中的5个重要环节
获取：新用户首单免费/低价(瑞幸、拼多多)、厂商预装(手机)、买量投放
激活：app推送、短信推送、产品价值激活
留存：签到、活动短信推送、平台价值提供
收益：平台广告、电商变现、付费会员、融资、软件服务
传播：好友助力、分享抽奖、兄弟砍我一刀
用户运营：根据用户行为圈数用户画像，建立分层分群，提高AARRR各个环节指标
内容运营
根据用户需求推出喜好内容，比如私域流量运营、短链平台使用技巧、案例分析等
用图文、软文、视频等内容形式，在【站内、站外】多个渠道分发吸引用户，打造品牌知名度
活动运营：策划活动提高 订单量、转化率、复购、日活、留存等数据，围绕AARRR模型进行开展
渠道投放：付费投放、买量，比如百度广告、朋友圈广告等
```

### 4.2项目流程

| 节点           | 开始      | 结束      | 备注                       |
| -------------- | --------- | --------- | -------------------------- |
| 需求评审       | 2022-1-10 | 2022-1-12 |                            |
| 设计           | 2022-1-13 | 2022-1-18 |                            |
| 前端           | 2022-1-16 | 2022-3-16 | 部分UI稿先开发             |
| 后端           | 2022-1-12 | 2022-3-16 | 数据库设计、架构设计、编码 |
| 联调           | 2022-3-10 | 2022-3-25 | 部分接口可以先对接         |
| 测试           | 2022-2-20 | 2022-3-30 | 测试可以提前接入编写用例   |
| 回归           | 2022-4-1  | 2022-4-5  | 回归测试和线上资源申请     |
| 预发布         | 2022-4-6  | 2022-4-7  | 预发布环境测试             |
| 上线           | 2022-4-8  | 2022-4-8  | 上线                       |
| 日常运营和放量 | 2022-4-10 | 2022-5-5  | 常规运营和适当推广         |

### 4.3微服务的拆分

```
dcloud-common
公共依赖包

dcloud-app
Flink+Kafka实时计算

dcloud-account
账号+流量包微服务

dcloud-data
数据可视化微服务

dcloud-gateway
业务⽹关

dcloud-link
短链微服务

dcloud-shop
流量包商品+⽀付微服务
```

### 4.4微服务技术栈

```
JDK8
SpringBoot 2.5.5
SpringCloud 2020.0.4
AlibabaCloud 2021.1
Sharding-JDBC 4.1.1
Mysql 8.0
Nacos 2.0.2
Redis 6.2.4
RabbitQM 3.8.15
Kafka : wurstmeister/kafka:2.13-2.7.0
```

### 4.5短链平台架构图

![1673095545989](短链平台项目.assets/1673095545989.png)

**各个微服务模块解析**

![1673096313154](短链平台项目.assets/1673096313154.png)

## 5.阿里云Linux安装中间件

### 5.1环境配置

```
1.服务器买2核8g或者16g以上，选择固定带宽1M~5M都⾏。
2.务必使⽤CentOS 7 以上版本，64位系统，不要在Windows系统操作！！！！推荐是CentOS 7.8。
```

![1673097856372](短链平台项目.assets/1673097856372.png)

### 5.2Docker安装

```
#安装依赖
[root@iZ2zeashk7kdvi5eievv7sZ ~]# yum install -y yum-utils device-mapper-persistent-data lvm2


#配置yum源使⽤国内的
[root@iZ2zeashk7kdvi5eievv7sZ ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo


#查看版本
[root@iZ2zeashk7kdvi5eievv7sZ ~]# yum list docker-ce --showduplicates | sort -r


#安装docker
[root@iZ2zeashk7kdvi5eievv7sZ ~]# yum -y install docker-ce-20.10.10-3.el7


#查看docker版本
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker -v


#启动docker
[root@iZ2zeashk7kdvi5eievv7sZ ~]# systemctl start docker


#镜像加速
[root@iZ2zeashk7kdvi5eievv7sZ ~]# vim /etc/docker/daemon.json
{
"debug":true,"experimental":true,
"registry-mirrors": ["https://pb5bklzr.mirror.aliyuncs.com","https://hub-mirror.c.163.com","https://docker.mirrors.ustc.edu.cn"]
}



#重启docker
[root@iZ2zeashk7kdvi5eievv7sZ ~]# systemctl restart docker



#查看是否配置成功
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker info
Client:
...
 Registry Mirrors:
  https://pb5bklzr.mirror.aliyuncs.com/
  https://hub-mirror.c.163.com/
  https://docker.mirrors.ustc.edu.cn/
 Live Restore Enabled: false


#删除所有容器
[root@ubuntu1804 ~]#docker rm -f `docker ps -a -q`


注意：不使⽤1.13.1版本，该版本在jenkins使⽤docker命令时会说找不到配置⽂件！
```

### 5.3Mysql8.0安装

**Mysql8.0安装**

```
#安装mysql8,让容器使用宿主机的时间，容器时间与宿主机时间同步
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker run \
-p 3306:3306 \
-e MYSQL_ROOT_PASSWORD=Liu19971009 \
-v /home/data/mysql/data:/var/lib/mysql:rw \
-v /etc/localtime:/etc/localtime:ro \
--name liu__mysql \
--restart=always \
-d mysql:8.0



#查看mysql镜像
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED              STATUS              PORTS                                                  NAMES
56812ad98c6f   mysql:8.0   "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:3306->3306/tcp, :::3306->3306/tcp, 33060/tcp   liu__mysql
```

阿里云开放端口

![1673100356213](短链平台项目.assets/1673100356213.png)

用Navicat测试连接

![1673100652179](短链平台项目.assets/1673100652179.png)

![1673100662292](短链平台项目.assets/1673100662292.png)

连接数的配置

```
show variables like '%max_connections%';
set GLOBAL max_connections=5000;
set GLOBAL mysqlx_max_connections=5000;
```

![1673100969455](短链平台项目.assets/1673100969455.png)

### 5.4Redis6安装

```
#安装redis镜像
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker run -itd --name liu-redis1 -p 6379:6379 -v /mydata/redis/data:/data redis:6.2.4 --requirepass Liu19971009


#查看redis
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker ps
CONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS          PORTS                                                  NAMES
03a94f0b87db   redis:6.2.4   "docker-entrypoint.s…"   31 seconds ago   Up 29 seconds   0.0.0.0:6379->6379/tcp, :::6379->6379/tcp              liu-redis1
56812ad98c6f   mysql:8.0     "docker-entrypoint.s…"   21 minutes ago   Up 21 minutes   0.0.0.0:3306->3306/tcp, :::3306->3306/tcp, 33060/tcp   liu__mysql



#连接测试redis
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker exec -it 03a94f0b87db redis-cli
127.0.0.1:6379> auth Liu19971009
OK
127.0.0.1:6379> set name liusenbiao
OK
```

开放阿里云redis端口

![1673101804040](短链平台项目.assets/1673101804040.png)

可视化工具进行连接

![1673101952361](短链平台项目.assets/1673101952361.png)

### 5.5Nacos2.0.2安装

新建nacos数据库

![1673102327663](短链平台项目.assets/1673102327663.png)

运行nacos.sql脚本

![1673102494897](短链平台项目.assets/1673102494897.png)

**开始安装nacos**

```
开源版本的nacos server配置中，不会对客户端鉴权，即任何能访问 Nacos server 的用户，都可以直接获取 Nacos 中存储的配置，假如⼀个⿊客攻进了企业内⽹，就能获取所有的业务配置，这样肯定会有安全隐患。

⽐如请求
http://112.74.55.160:8848/nacos/v1/cs/configs?dataId=dcloud-account-service-
dev.yaml&group=DEFAULT_GROUP

需要先开启 Nacos server 的鉴权,在 Nacos server 上修改application.properties 中的
nacos.core.auth.enabled 值为 true 即可
```

**xshell中输入命令**

```
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker run -d \
-e NACOS_AUTH_ENABLE=true \
-e MODE=standalone \
-e JVM_XMS=128m \
-e JVM_XMX=128m \
-e JVM_XMN=128m \
-p 8848:8848 \
-e SPRING_DATASOURCE_PLATFORM=mysql \
-e MYSQL_SERVICE_HOST=123.57.69.236 \
-e MYSQL_SERVICE_PORT=3306 \
-e MYSQL_SERVICE_USER=root \
-e MYSQL_SERVICE_PASSWORD=Liu19971009 \
-e MYSQL_SERVICE_DB_NAME=nacos_config \
-e MYSQL_SERVICE_DB_PARAM='characterEncoding=utf8&connectTimeout=10000&socketTimeout=30000&autoReconnect=true&useSSL=false' \
--restart=always \
--privileged=true \
-v /home/data/nacos/logs:/home/nacos/logs \
--name liu_nacos_auth \
nacos/nacos-server:2.0.2
```

阿里云开放8848端口

![1673103815621](短链平台项目.assets/1673103815621.png)

查看nacos启动

```
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker logs -f 75b3835fb709
```

![1673104076893](短链平台项目.assets/1673104076893.png)

账号密码默认都是nacos

![1673104241118](短链平台项目.assets/1673104241118.png)

![1673104276441](短链平台项目.assets/1673104276441.png)

### 5.6RabbitMQ安装

```
#安装rabbitMQ的镜像
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker run -d  --name liu_rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:3.8.15-management


#⽹络安全组记得开放端口
4369 erlang 发现口
5672 client 端通信口
15672 管理界⾯ ui 端口
25672 server 间内部通信口
```

![1673105052135](短链平台项目.assets/1673105052135.png)

**访问rabbitMQ**

![1673105215918](短链平台项目.assets/1673105215918.png)

![1673105269997](短链平台项目.assets/1673105269997.png)

### 5.7Kafka+Zookeeper安装

- 部署zookeeper

```
docker run -d --name zookeeper -p 2181:2181 -t wurstmeister/zookeeper
```

- 部署Kafka

```
#1.docker部署kafka
docker run -d --name liu_kafka \
-p 9092:9092 \
-e KAFKA_BROKER_ID=0 \
--env KAFKA_HEAP_OPTS=-Xmx256M \
--env KAFKA_HEAP_OPTS=-Xms128M \
                           #私网IP
-e KAFKA_ZOOKEEPER_CONNECT=172.26.44.128:2181 \
                                 #公网IP                                   
-e KAFKA_ADVERTISED_LISTENERS=PL/101.200.159.132:9092 \
-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka:2.13-2.7.0


#2.查看kafka是否成功启动
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker logs -f e8e0


#3.进入kafka内部容器
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker exec -it e8e05849f91d /bin/bash
bash-5.1# cd /opt/kafka/bin



#4.创建⼀个主题
bash-5.1# ./kafka-topics.sh --create --zookeeper 172.26.44.128:2181 --replication-factor 1 --partitions 1 --topic ods_link_visit_topic


#5.查看topic
bash-5.1# ./kafka-topics.sh --list --zookeeper 172.26.44.128:2181


#6.删除topic(若有故障，执行)
./kafka-topics.sh --zookeeper 172.26.44.128:2181 --delete --topic ods_link_visit_topic


#7.消费者消费消息(浏览器发送消息后查看)
./kafka-console-consumer.sh --bootstrap-server 101.200.159.132:9092 --from-beginning --topic ods_link_visit_topic



#8.网络安全组记得开发端口9092、2181
[root@iZ2zeashk7kdvi5eievv7sZ ~]# firewall-cmd --zone=public --add-port=9092/tcp --permanent
```

### 5.8ClickHouse安装

- RPM包安装

```
#1.安装把windows上的文件拖到linux上的安装包
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# yum -y install lrzsz vim


#2.创建clickhouse文件夹
[root@iZ2zeashk7kdvi5eievv7sZ ~]# mkdir /usr/local/software/clickhouse -p
[root@iZ2zeashk7kdvi5eievv7sZ ~]# cd /usr/local/software/clickhouse


#3.查看clickhouse需要的安装包
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# ls -l
total 907092
-rw-r--r-- 1 root root    131535 Jan  6 12:21 clickhouse-client-22.1.2.2-2.noarch.rpm
-rw-r--r-- 1 root root 215344894 Jan  6 12:22 clickhouse-common-static-22.1.2.2-2.x86_64.rpm
-rw-r--r-- 1 root root 713210726 Jan  6 12:23 clickhouse-common-static-dbg-22.1.2.2-2.x86_64.rpm
-rw-r--r-- 1 root root    156210 Jan  6 12:21 clickhouse-server-22.1.2.2-2.noarch.rpm


#4.进行clickhouse安装
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# sudo rpm -ivh *.rpm


#5.启动clickhouse
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# systemctl start clickhouse-server


#6.查看clickhouse状态
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# systemctl status clickhouse-server


#7.开启远程访问，取消下面的注释
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# vim /etc/clickhouse-server/config.xml
183行  <listen_host>0.0.0.0</listen_host> 


#8.重启服务
[root@iZ2zeashk7kdvi5eievv7sZ ~]# systemctl restart clickhouse-server


#9.网络安全组记得开放http端口是8123
```

- docker安装

```
docker run -d --name liu_clickhouse --ulimit nofile=262144:262144 \
-p 8123:8123 -p 9000:9000 -p 9009:9009 --privileged=true \
-v /mydata/docker/clickhouse/log:/var/log/clickhouse-server \
-v /mydata/docker/clickhouse/data:/var/lib/clickhouse clickhouse/clickhouse-server:22.2.3.5
```

## 6.Maven创建微服务项目

### 6.1创建微服务

```
创建dcloud-common对应的微服务如下图所示，其余微服务同理

dcloud-common
公共依赖包

dcloud-app
Flink+Kafka实时计算

dcloud-account
账号+流量包微服务

dcloud-data
数据可视化微服务

dcloud-gateway
业务⽹关

dcloud-link
短链微服务

dcloud-shop
流量包商品+⽀付微服务
```

![1673105644625](短链平台项目.assets/1673105644625.png)

![1673105689709](短链平台项目.assets/1673105689709.png)

![1673106655243](短链平台项目.assets/1673106655243.png)

![1673106701175](短链平台项目.assets/1673106701175.png)

```
删除src目录，然后创建微服务所对应的module
```

![1673106884889](短链平台项目.assets/1673106884889.png)

![1673106916325](短链平台项目.assets/1673106916325.png)

![1673106962558](短链平台项目.assets/1673106962558.png)

![1673106983664](短链平台项目.assets/1673106983664.png)

### 6.2添加pom.xml的依赖

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>net.xdclass</groupId>
    <artifactId>dcloud-short-link</artifactId>
    <packaging>pom</packaging>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>dcloud-common</module>
        <module>dcloud-app</module>
        <module>dcloud-account</module>
        <module>dcloud-data</module>
        <module>dcloud-gateway</module>
        <module>dcloud-link</module>
        <module>dcloud-shop</module>
    </modules>

    <properties>

        <!--JDK版本，如果是jdk8则这里是 1.8-->
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>

        <spring.boot.version>2.5.5</spring.boot.version>
        <spring.cloud.version>2020.0.4</spring.cloud.version>
        <alibaba.cloud.version>2021.1</alibaba.cloud.version>

        <mybatisplus.boot.starter.version>3.4.0</mybatisplus.boot.starter.version>
        <lombok.version>1.18.16</lombok.version>
        <commons.lang3.version>3.9</commons.lang3.version>
        <commons.codec.version>1.15</commons.codec.version>

        <xxl-job.version>2.3.0</xxl-job.version>

        <aliyun.oss.version>3.10.2</aliyun.oss.version>

        <captcha.version>1.1.0</captcha.version>

        <redission.version>3.10.1</redission.version>
        <jwt.version>0.7.0</jwt.version>
        <sharding-jdbc.version>4.1.1</sharding-jdbc.version>

        <junit.version>4.12</junit.version>
        <druid.version>1.1.16</druid.version>

        <!--跳过单元测试-->
        <skipTests>true</skipTests>
        <docker.image.prefix>dcloud</docker.image.prefix>

    </properties>




    <!--锁定版本-->
    <dependencyManagement>
        <dependencies>
            <!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-dependencies/2.3.3.RELEASE-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring.boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies/Hoxton.SR8-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring.cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-alibaba-dependencies/2.2.1.RELEASE-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${alibaba.cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>



            <!--mybatis plus和springboot整合-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatisplus.boot.starter.version}</version>
            </dependency>

            <!--https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.16-->
            <!--scope=provided，说明它只在编译阶段生效，不需要打入包中, Lombok在编译期将带Lombok注解的Java文件正确编译为完整的Class文件-->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
                <!--<scope>provided</scope>-->
            </dependency>



            <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>${commons.lang3.version}</version>
            </dependency>

            <!-- https://mvnrepository.com/artifact/commons-codec/commons-codec -->
            <!--用于加密-->
            <dependency>
                <groupId>commons-codec</groupId>
                <artifactId>commons-codec</artifactId>
                <version>${commons.codec.version}</version>
            </dependency>



            <!--验证码kaptcha依赖包-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>kaptcha-spring-boot-starter</artifactId>
                <version>${captcha.version}</version>
            </dependency>


            <!--阿里云oss-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun.oss.version}</version>
            </dependency>



            <!-- JWT相关 -->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>${jwt.version}</version>
            </dependency>



            <!--分布式锁-->
            <dependency>
                <groupId>org.redisson</groupId>
                <artifactId>redisson</artifactId>
                <version>${redission.version}</version>
            </dependency>



            <!--https://mvnrepository.com/artifact/org.apache.shardingsphere/sharding-jdbc-spring-boot-starter-->
            <dependency>
                <groupId>org.apache.shardingsphere</groupId>
                <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
                <version>${sharding-jdbc.version}</version>
            </dependency>


            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>${junit.version}</version>
            </dependency>


            <!-- https://mvnrepository.com/artifact/com.xuxueli/xxl-job-core -->
            <dependency>
                <groupId>com.xuxueli</groupId>
                <artifactId>xxl-job-core</artifactId>
                <version>${xxl-job.version}</version>
            </dependency>

        </dependencies>
    </dependencyManagement>

    <!-- 代码库 -->
    <repositories>
        <repository>
            <id>maven-ali</id>
            <url>http://maven.aliyun.com/nexus/content/groups/public//</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>true</enabled>
                <updatePolicy>always</updatePolicy>
                <checksumPolicy>fail</checksumPolicy>
            </snapshots>
        </repository>
    </repositories>


    <pluginRepositories>
        <pluginRepository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
    </pluginRepositories>

    <!--module不用添加打包版本信息-->
    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.1</version>
                <configuration>
                    <skip>true</skip>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring.boot.version}</version>
                <configuration>
                    <fork>true</fork>
                    <addResources>true</addResources>
                </configuration>
            </plugin>
        </plugins>
    </build>


</project>
```

### 6.3Gitee相关仓库配置

```
首先创建一个仓库，设置为ssh连接
```

![1673110110919](短链平台项目.assets/1673110110919.png)

#### 6.3.1设置公钥私钥

```
18053@LAPTOP-DH2R8IBT MINGW64 ~/Desktop (master|REBASE 1/1)
$ ssh-keygen -t rsa -C "1805336068@qq.com"
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/18053/.ssh/id_rsa):
/c/Users/18053/.ssh/id_rsa already exists.
Overwrite (y/n)? y
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /c/Users/18053/.ssh/id_rsa
Your public key has been saved in /c/Users/18053/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:Key+163PPJTTbeC/jt6A2tZqOQt+Tgu81k8D3KuOfaA 1805336068@qq.com
The key's randomart image is:
+---[RSA 3072]----+
|                 |
|                 |
|                 |
|     .   .. . .  |
|      o S  o = o |
|     . ..  .* + o|
|      .  =o=+* o |
|     .  oE@X*o= .|
|      oo.=B%@=.+.|
+----[SHA256]-----+

18053@LAPTOP-DH2R8IBT MINGW64 ~/Desktop (master|REBASE 1/1)
$ cd /c/Users/18053/.ssh/

18053@LAPTOP-DH2R8IBT MINGW64 ~/.ssh (master|REBASE 1/1)
$ ls
config  id_rsa  id_rsa.pub  known_hosts

18053@LAPTOP-DH2R8IBT MINGW64 ~/.ssh (master|REBASE 1/1)
$ cat id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDDL6Z0FD2KNO4IvMJTZ+EWZRZMpYOQfK6C+sLwb2ph6afmw2cngN9ubOBiNvINwyC29MRg4B5U693I2c0c26qkXScsWS6pUhgUlvCIiTkpBMFaWQli5vVdUm7UiL3/IDnfAjjjemg+Prd5yHXtTk6rBlyj0ZdeQHBE8WZz00JZmgJp+WvatM0xHUDhCA3wy2oYKHALOZXK4abtox1BzEz760tBLfgd67e8HqMeSJanKl00MJbpfqArvjeA9p7o0G+SNaVUj35PXzt5xo8xUjB6ui+GUT3Yq43pzeoHtYChbS00SUawg2m2/e36HUIIHmY5OdhQlvpgOHbPUGVFhndzZfpOj6ZW9kJB+e7TZF9zB3tqQAhKOfLfpVv3gjERTud9bBrEqiRcugcEy4qesbUrAJ2EINKDnYzGPgtXjCUcLZZKdbv5dtct9dJkAt5QLfpWZVgOrQ/shtc51hh12+LYuHaUkFLjZMDeXmEUmnkT3/3/7FeSHnMH8SN0A7O5dc0= 1805336068@qq.com
```

![1673110220277](短链平台项目.assets/1673110220277.png)

![1673110309315](短链平台项目.assets/1673110309315.png)



![1673111633673](短链平台项目.assets/1673111633673.png)

#### 6.3.2配置gitignore

```
#在项目下创建.gitignore文件
# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar
.DS_Store
.idea
# virtual machine crash logs, seehttp://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
```

![1673114790715](短链平台项目.assets/1673114790715.png)

#### 6.3.3代码提交仓库

```
git init
git remote add origin git@gitee.com:liu_se/dcloud-short-link.git
git config core.autocrlf false
git add .
git commit -m "短链平台项目"
git push -u origin master
```

![1673114931482](短链平台项目.assets/1673114931482.png)

![1673114946428](短链平台项目.assets/1673114946428.png)



### 6.4阿里编码规范

#### 6.4.1N方库说明

```
⼀⽅库: 本⼯程内部⼦项⽬模块依赖的库(jar 包)，类似于common模块。
⼆⽅库: 公司内部发布到中央仓库，可供公司内部其它应⽤依赖的库(jar包)。
三⽅库: 公司之外的开源库(jar包)。
```

#### 6.4.2POJO实体类

```
POJO(Plain Ordinary Java Object): 在⼿册中，POJO 专指只有 setter / getter / toString的简单类，包括DO/DTO/BO/VO等, 禁⽌命名成xxxPOJO.
```

#### 6.4.3各个层级约束规范

```
A) Service/DAO层⽅法命名规约
 1) 获取单个对象的⽅法⽤get做前缀。
 2) 获取多个对象的⽅法⽤list做前缀，复数形式结尾如:listObjects。
 3) 获取统计值的⽅法⽤count做前缀。
 4) 插⼊的⽅法⽤save/insert做前缀。
 5) 删除的⽅法⽤remove/delete做前缀。
 6) 修改的⽅法⽤update做前缀。
 
 
B) 领域模型命名规约
 1) 数据对象:xxxDO，xxx即为数据表名。
 2) ⼀般数据传输对象:xxxDTO，xxx为业务领域相关的名称，项⽬⾥⾯也⽤VO。
 3) 展示对象:xxxVO，也就是响应给前端的实体包装类。
 4) 接收前端json对象请求的命名为 XXXRequest
```

#### 6.4.4Manager分层

```
Manager分层说明通⽤业务处理层，它有如下特征
1.对第三⽅平台封装的层，预处理返回结果及转化异常信息
2.对Service层通⽤能⼒的下沉，如缓存⽅案、中间件通⽤处理;
3.与DAO层交互，对多个DAO的组合复⽤。
```

![1673264633997](短链平台项目.assets/1673264633997.png)

### 6.5dcloud-common模块配置

**pom文件配置**

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>dcloud-short-link</artifactId>
        <groupId>net.xdclass</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>dcloud-common</artifactId>
    <dependencies>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>

        <!--项目中添加 spring-boot-starter-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>


        <!--数据库连接-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <!--mybatis plus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>


        <!--单元测试-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>


        <!--redis客户端-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>io.lettuce</groupId>
                    <artifactId>lettuce-core</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
        </dependency>



        <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>

        <!--用于加密-->
        <dependency>
            <groupId>commons-codec</groupId>
            <artifactId>commons-codec</artifactId>
        </dependency>

        <!-- JWT相关 -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
        </dependency>


        <!--redisson分布式锁-->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
        </dependency>

        <!--Hoxton.M2版本之后不再使用Ribbon而是使用spring-cloud-loadbalancer，所以不引入spring-cloud-loadbalancer会报错，所以加入spring-cloud-loadbalancer依赖 并且在nacos中排除ribbon依赖，不然loadbalancer无效 -->

        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>


        <!--配置中心， 留坑，后续用的时候再讲，解决方式，看springboot官方文档版本更新说明-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>


        <!--Feign远程调用-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>


        <!--限流依赖-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
        </dependency>



        <!--限流持久化到nacos-->

        <dependency>
            <groupId>com.alibaba.csp</groupId>
            <artifactId>sentinel-datasource-nacos</artifactId>
        </dependency>



        <!--Springboot项目整合spring-kafka依赖包配置-->
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>



        <!--引入AMQP-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>


        <!--spring cache依赖包-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>


        <dependency>
            <groupId>org.apache.shardingsphere</groupId>
            <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
        </dependency>


        <!-- https://mvnrepository.com/artifact/com.xuxueli/xxl-job-core -->
        <!--分布式调度-->
        <dependency>
            <groupId>com.xuxueli</groupId>
            <artifactId>xxl-job-core</artifactId>
        </dependency>


        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </dependency>

    </dependencies>

</project>
```

**在account,data,dcloud-link,shop引入公共依赖**

```
    <dependencies>
        <dependency>
            <groupId>net.xdclass</groupId>
            <artifactId>dcloud-common</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>
```

### 6.6响应工具类封装

#### 6.6.1统⼀业务状态码 BizCodeEnum

状态码定义约束，共6位数，前三位代表服务，后3位代表接口
比如商品服务210

![1673266580844](短链平台项目.assets/1673266580844.png)

```
package net.xdclass.enums;

import lombok.Getter;

/**
 * @Description 状态码定义约束，共6位数，前三位代表服务，后3位代表接口
 *  比如 商品服务210,购物车是220、用户服务230，403代表权限
 **/
public enum BizCodeEnum {


    /**
     * 短链分组
     */
    GROUP_REPEAT(23001,"分组名重复"),
    GROUP_OPER_FAIL(23503,"分组名操作失败"),
    GROUP_NOT_EXIST(23404,"分组不存在"),



    /**
     *验证码
     */
    CODE_TO_ERROR(240001,"接收号码不合规"),
    CODE_LIMITED(240002,"验证码发送过快"),
    CODE_ERROR(240003,"验证码错误"),
    CODE_CAPTCHA_ERROR(240101,"图形验证码错误"),



    /**
     * 账号
     */
    ACCOUNT_REPEAT(250001,"账号已经存在"),
    ACCOUNT_UNREGISTER(250002,"账号不存在"),
    ACCOUNT_PWD_ERROR(250003,"账号或者密码错误"),
    ACCOUNT_UNLOGIN(250004,"账号未登录"),


    /**
     * 短链
     */
    SHORT_LINK_NOT_EXIST(260404,"短链不存在"),


    /**
     * 订单
     */
    ORDER_CONFIRM_PRICE_FAIL(280002,"创建订单-验价失败"),
    ORDER_CONFIRM_REPEAT(280008,"订单恶意-重复提交"),
    ORDER_CONFIRM_TOKEN_EQUAL_FAIL(280009,"订单令牌缺少"),
    ORDER_CONFIRM_NOT_EXIST(280010,"订单不存在"),

    /**
     * 支付
     */
    PAY_ORDER_FAIL(300001,"创建支付订单失败"),
    PAY_ORDER_CALLBACK_SIGN_FAIL(300002,"支付订单回调验证签失败"),
    PAY_ORDER_CALLBACK_NOT_SUCCESS(300003,"支付宝回调更新订单失败"),
    PAY_ORDER_NOT_EXIST(300005,"订单不存在"),
    PAY_ORDER_STATE_ERROR(300006,"订单状态不正常"),
    PAY_ORDER_PAY_TIMEOUT(300007,"订单支付超时"),


    /**
     * 流控操作
     */
    CONTROL_FLOW(500101,"限流控制"),
    CONTROL_DEGRADE(500201,"降级控制"),
    CONTROL_AUTH(500301,"认证控制"),


    /**
     * 流量包操作
     */
    TRAFFIC_FREE_NOT_EXIST(600101,"免费流量包不存在，联系客服"),

    TRAFFIC_REDUCE_FAIL(600102,"流量不足，扣减失败"),

    TRAFFIC_EXCEPTION(600103,"流量包数据异常,用户无流量包"),


    /**
     * 通用操作码
     */

    OPS_REPEAT(110001,"重复操作"),
    OPS_NETWORK_ADDRESS_ERROR(110002,"网络地址错误"),


    /**
     * 文件相关
     */
    FILE_UPLOAD_USER_IMG_FAIL(700101,"用户头像文件上传失败");

    @Getter
    private String message;

    @Getter
    private int code;

    private BizCodeEnum(int code, String message){
        this.code = code;
        this.message = message;
    }
}
```

#### 6.6.2JsonData工具类

![1673267596515](短链平台项目.assets/1673267596515.png)

```
package net.xdclass.util;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import net.xdclass.enums.BizCodeEnum;


/**
 * 通用套路，直接复制粘贴即可
 * 没必要手敲！！！！
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class JsonData {

    /**
     * 状态码 0 表示成功
     */

    private Integer code;
    /**
     * 数据
     */
    private Object data;
    /**
     * 描述
     */
    private String msg;


    /**
     *  获取远程调用数据
     *  注意事项：
     *      支持多单词下划线专驼峰（序列化和反序列化）
     *
     * @param typeReference
     * @param <T>
     * @return
     */
    public <T> T getData(TypeReference<T> typeReference){
        return JSON.parseObject(JSON.toJSONString(data),typeReference);
    }

    /**
     * 成功，不传入数据
     * @return
     */
    public static JsonData buildSuccess() {
        return new JsonData(0, null, null);
    }

    /**
     *  成功，传入数据
     * @param data
     * @return
     */
    public static JsonData buildSuccess(Object data) {
        return new JsonData(0, data, null);
    }

    /**
     * 失败，传入描述信息
     * @param msg
     * @return
     */
    public static JsonData buildError(String msg) {
        return new JsonData(-1, null, msg);
    }



    /**
     * 自定义状态码和错误信息
     * @param code
     * @param msg
     * @return
     */
    public static JsonData buildCodeAndMsg(int code, String msg) {
        return new JsonData(code, null, msg);
    }

    /**
     * 传入枚举，返回信息
     * @param codeEnum
     * @return
     */
    public static JsonData buildResult(BizCodeEnum codeEnum){
        return JsonData.buildCodeAndMsg(codeEnum.getCode(),codeEnum.getMessage());
    }
}
```

#### 6.6.3自定义全局异常

```
package net.xdclass.exception;


import lombok.Data;
import net.xdclass.enums.BizCodeEnum;

@Data
public class BizException extends RuntimeException {

    private int code;

    private String msg;

    public BizException(Integer code, String message) {
        super(message);
        this.code = code;
        this.msg = message;
    }

    public BizException(BizCodeEnum bizCodeEnum) {
        super(bizCodeEnum.getMessage());
        this.code = bizCodeEnum.getCode();
        this.msg = bizCodeEnum.getMessage();
    }
}
```

#### 6.6.4自定义异常处理器

```
package net.xdclass.exception;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.util.JsonData;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 自定义异常处理器
 */
@ControllerAdvice
@Slf4j
public class CustomExceptionHandler {

    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public JsonData handler(Exception e) {
        if (e instanceof BizException) {
            BizException bizException = (BizException) e;
            log.error("[业务异常]{}",e);
            return JsonData.buildCodeAndMsg(bizException.getCode(),bizException.getMsg());
        }else {
            log.error("[系统异常]{}",e);
            return JsonData.buildError("系统异常");
        }
    }
}
```

#### 6.6.5时间格式化工具类

```
package net.xdclass.util;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.Date;


public class TimeUtil {

    /**
     * 默认日期格式
     */
    private static final String DEFAULT_PATTERN = "yyyy-MM-dd HH:mm:ss";

    /**
     * 默认日期格式
     */
    private static final DateTimeFormatter DEFAULT_DATE_TIME_FORMATTER  = DateTimeFormatter.ofPattern(DEFAULT_PATTERN);

    private static final ZoneId DEFAULT_ZONE_ID = ZoneId.systemDefault();


    /**
     * LocalDateTime 转 字符串，指定日期格式
     * @param time
     * @param pattern
     * @return
     */
    public static String format(LocalDateTime localDateTime, String pattern){
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        String timeStr = formatter.format(localDateTime.atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }


    /**
     * Date 转 字符串, 指定日期格式
     * @param time
     * @param pattern
     * @return
     */
    public static String format(Date time, String pattern){
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        String timeStr = formatter.format(time.toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }

    /**
     *  Date 转 字符串，默认日期格式
     * @param time
     * @return
     */
    public static String format(Date time){

        String timeStr = DEFAULT_DATE_TIME_FORMATTER.format(time.toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }

    /**
     * timestamp 转 字符串，默认日期格式
     *
     * @param time
     * @return
     */
    public static String format(long timestamp) {
        String timeStr = DEFAULT_DATE_TIME_FORMATTER.format(new Date(timestamp).toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }


    /**
     * 字符串 转 Date
     *
     * @param time
     * @return
     */
    public static Date strToDate(String time) {
        LocalDateTime localDateTime = LocalDateTime.parse(time, DEFAULT_DATE_TIME_FORMATTER);
        return Date.from(localDateTime.atZone(DEFAULT_ZONE_ID).toInstant());

    }


    /**
     * 获取当天剩余的秒数,用于流量包过期配置
     * @param currentDate
     * @return
     */
    public static Integer getRemainSecondsOneDay(Date currentDate) {
        LocalDateTime midnight = LocalDateTime.ofInstant(currentDate.toInstant(),
                ZoneId.systemDefault()).plusDays(1).withHour(0).withMinute(0)
                .withSecond(0).withNano(0);

        LocalDateTime currentDateTime = LocalDateTime.ofInstant(currentDate.toInstant(),
                ZoneId.systemDefault());
        long seconds = ChronoUnit.SECONDS.between(currentDateTime, midnight);
        return (int) seconds;
    }
}
```

#### 6.6.6Json序列化工具类

```
package net.xdclass.util;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import lombok.extern.slf4j.Slf4j;

import java.text.SimpleDateFormat;
import java.util.List;


@Slf4j
public class JsonUtil {


    private static final ObjectMapper mapper = new ObjectMapper();

    static {

        //设置可用单引号
        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);

        //序列化的时候序列对象的所有属性
        mapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);

        //反序列化的时候如果多了其他属性,不抛出异常
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        //如果是空对象的时候,不抛异常
        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);

        //取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
    }



    /**
     * 对象转为Json字符串
     * @param data
     * @return
     */
    public static String obj2Json(Object obj) {
        String jsonStr = null;
        try {
            jsonStr = mapper.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return jsonStr;
    }
    /**
     * json字符串转为对象
     * @param str
     * @param valueType
     * @return
     */
    public static <T> T json2Obj(String jsonStr, Class<T> beanType) {
        T obj = null;
        try {
            obj = mapper.readValue(jsonStr, beanType);
        } catch (Exception e){
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return obj;
    }


    /**
     * json数据转换成pojo对象list
     * @param jsonData
     * @param beanType
     * @return
     */
    public static <T> List<T> json2List(String jsonData, Class<T> beanType) {
        JavaType javaType = mapper.getTypeFactory().constructParametricType(List.class, beanType);
        try {
            List<T> list = mapper.readValue(jsonData, javaType);
            return list;
        } catch (Exception e) {
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return null;
    }

    /**
     * 对象转为byte数组
     * @param data
     * @return
     */
    public static byte[] obj2Bytes(Object obj) {
        byte[] byteArr = null;
        try {
            byteArr = mapper.writeValueAsBytes(obj);
        } catch (JsonProcessingException e) {
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return byteArr;
    }



    /**
     * byte数组转为对象
     * @param byteArr
     * @param valueType
     * @return
     */
    public static <T> T bytes2Obj(byte[] byteArr, Class<T> beanType) {
        T obj = null;
        try {
            obj = mapper.readValue(byteArr, beanType);
        } catch (Exception e) {
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return obj;
    }
}
```

#### 6.6.7其余常用工具类

```
package net.xdclass.util;

import lombok.extern.slf4j.Slf4j;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.MessageDigest;
import java.util.*;


@Slf4j
public class CommonUtil {
    /**
     * 获取ip
     *
     * @param request
     * @return
     */
    public static String getIpAddr(HttpServletRequest request) {
        String ipAddress = null;
        try {
            ipAddress = request.getHeader("x-forwarded-for");
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getHeader("Proxy-Client-IP");
            }
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getHeader("WL-Proxy-Client-IP");
            }
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getRemoteAddr();
                if (ipAddress.equals("127.0.0.1")) {
                    // 根据网卡取本机配置的IP
                    InetAddress inet = null;
                    try {
                        inet = InetAddress.getLocalHost();
                    } catch (UnknownHostException e) {
                        e.printStackTrace();
                    }
                    ipAddress = inet.getHostAddress();
                }
            }
            // 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照','分割
            if (ipAddress != null && ipAddress.length() > 15) {
                // "***.***.***.***".length()
                // = 15
                if (ipAddress.indexOf(",") > 0) {
                    ipAddress = ipAddress.substring(0, ipAddress.indexOf(","));
                }
            }
        } catch (Exception e) {
            ipAddress = "";
        }
        return ipAddress;
    }


    /**
     * 获取全部请求头
     *
     * @param request
     * @return
     */
    public static Map<String, String> getAllRequestHeader(HttpServletRequest request) {
        Enumeration<String> headerNames = request.getHeaderNames();
        Map<String, String> map = new HashMap<>();
        while (headerNames.hasMoreElements()) {
            String key = (String) headerNames.nextElement();
            //根据名称获取请求头的值
            String value = request.getHeader(key);
            map.put(key, value);
        }

        return map;
    }


    /**
     * MD5加密
     *
     * @param data
     * @return
     */
    public static String MD5(String data) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] array = md.digest(data.getBytes("UTF-8"));
            StringBuilder sb = new StringBuilder();
            for (byte item : array) {
                sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));
            }

            return sb.toString().toUpperCase();
        } catch (Exception exception) {
        }
        return null;

    }


    /**
     * 获取验证码随机数
     *
     * @param length
     * @return
     */
    public static String getRandomCode(int length) {

        String sources = "0123456789";
        Random random = new Random();
        StringBuilder sb = new StringBuilder();
        for (int j = 0; j < length; j++) {
            sb.append(sources.charAt(random.nextInt(9)));
        }
        return sb.toString();
    }


    /**
     * 获取当前时间戳
     *
     * @return
     */
    public static long getCurrentTimestamp() {
        return System.currentTimeMillis();
    }


    /**
     * 生成uuid
     *
     * @return
     */
    public static String generateUUID() {
        return UUID.randomUUID().toString().replaceAll("-", "").substring(0, 32);
    }

    /**
     * 获取随机长度的串
     *
     * @param length
     * @return
     */
    private static final String ALL_CHAR_NUM = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    public static String getStringNumRandom(int length) {
        //生成随机数字和字母,
        Random random = new Random();
        StringBuilder saltString = new StringBuilder(length);
        for (int i = 1; i <= length; ++i) {
            saltString.append(ALL_CHAR_NUM.charAt(random.nextInt(ALL_CHAR_NUM.length())));
        }
        return saltString.toString();
    }


    /**
     * 响应json数据给前端
     *
     * @param response
     * @param obj
     */
    public static void sendJsonMessage(HttpServletResponse response, Object obj) {

        response.setContentType("application/json; charset=utf-8");

        try (PrintWriter writer = response.getWriter()) {
            writer.print(JsonUtil.obj2Json(obj));
            response.flushBuffer();

        } catch (IOException e) {
            log.warn("响应json数据给前端异常:{}", e);
        }


    }

}
```

## 7.账号和流量包设计

### 7.1account表设计

**索引规范**

```
主键索引名为 pk_字段名; pk即 primary key;
唯⼀索引名为 uk_字段名；uk 即 unique key
普通索引名则为 idx_字段名；idx 即index 的简称
```

**account表**

![1673273258520](短链平台项目.assets/1673273258520.png)

```
CREATE TABLE `account` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `account_no` bigint DEFAULT NULL,
  `head_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '头像',
  `phone` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '手机号',
  `pwd` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '密码',
  `secret` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '盐，用于个人敏感信息处理',
  `mail` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '邮箱',
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '用户名',
  `auth` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '认证级别，DEFAULT，REALNAME，ENTERPRISE，访问次数不一样',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_phone` (`phone`) USING BTREE,
  UNIQUE KEY `uk_account` (`account_no`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

### 7.2流量包设计

账号和流包的关系：⼀对多

**traffic流包表**

思考点

- 海数据下每天免费次数怎么更新？

- 海数据付费流套餐包每天次数限制怎么更新？

- ⾼性能扣减流包设计怎么做？

- 流包数据更新处理-⾼并发下分布式事务怎么解决

  ```
  CREATE TABLE `traffic` (
    `id` bigint unsigned NOT NULL AUTO_INCREMENT,
    `day_limit` int DEFAULT NULL COMMENT '每天限制多少条，短链',
    `day_used` int DEFAULT NULL COMMENT '当天用了多少条，短链',
    `total_limit` int DEFAULT NULL COMMENT '总次数，活码才用',
    `account_no` bigint DEFAULT NULL COMMENT '账号',
    `out_trade_no` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '订单号',
    `level` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '产品层级：FIRST青铜、SECOND黄金、THIRD钻石',
    `expired_date` date DEFAULT NULL COMMENT '过期日期',
    `plugin_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '插件类型',
    `product_id` bigint DEFAULT NULL COMMENT '商品主键',
    `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
    `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_trade_no` (`out_trade_no`,`account_no`) USING BTREE,
    KEY `idx_account_no` (`account_no`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
  ```

**traffic_task 流包任务表(主要用于分布式事务当中)**

```
CREATE TABLE `traffic_task` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `account_no` bigint DEFAULT NULL,
  `traffic_id` bigint DEFAULT NULL,
  `use_times` int DEFAULT NULL,
  `lock_state` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '锁定状态锁定LOCK  完成FINISH-取消CANCEL',
  `message_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '唯一标识',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_msg_id` (`message_id`) USING BTREE,
  KEY `idx_release` (`account_no`,`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

### 7.3流量包业务模型

![1673275287285](短链平台项目.assets/1673275287285.png)

### 7.4引入Mybatis-plus-generator

#### 7.4.1在dcloud-common中添加依赖

```
 <!-- 代码自动生成依赖 begin -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.4.1</version>
        </dependency>
        <!-- velocity -->
        <dependency>
            <groupId>org.apache.velocity</groupId>
            <artifactId>velocity-engine-core</artifactId>
            <version>2.0</version>
        </dependency>
        <!-- 代码自动生成依赖 end-->
```

#### 7.4.2创建Mybatis-plus-generator模板类

![1673276456175](短链平台项目.assets/1673276456175.png)

```
package net.xdclass.db;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;


public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();
        // 是否支持AR模式
        config.setActiveRecord(true)
                // 作者
                .setAuthor("刘森飚")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("C:\\Users\\18053\\Desktop")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")


                //生成基本的resultMap
                .setBaseResultMap(true)

                //实体类结尾名称
                .setEntityName("%sDO")
                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://123.57.238.78:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai")
                .setUsername("root")
                .setPassword("Liu19971009");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("account","traffic","traffic_task");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("=======  相关代码生成完毕  ========");
    }
}
```

![1673277224703](短链平台项目.assets/1673277224703.png)

**导入生成好的代码**

```
1.model (为啥不放common项⽬，如果是确定每个服务都⽤到的依赖或者类才放到common项⽬)
2.mapper类接口拷贝
3.resource/mapper⽂件夹 xml脚本拷⻉
4.controller
5.service不拷贝
```

![1673277889260](短链平台项目.assets/1673277889260.png)

#### 7.4.3配置plus打印sql日志

```
在resources文件下建立application.yml
```

**application.yml**

```
server:
  port: 8001


#应用名称
spring:
  application:
    name: dcloud-account

#服务注册发现
  cloud:
    nacos:
      discovery:
        server-addr: 123.57.238.78:8848
        username: nacos
        password: nacos

#数据库配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://123.57.238.78:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: Liu19971009



#配置plus打印sql日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

### 7.5微服务注册Nacos

#### 7.5.1排除sharding-jdbc依赖

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>dcloud-short-link</artifactId>
        <groupId>net.xdclass</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>dcloud-account</artifactId>

    <dependencies>
        <dependency>
            <groupId>net.xdclass</groupId>
            <artifactId>dcloud-common</artifactId>
            <version>1.0-SNAPSHOT</version>
            <!--因为引入shardingsphere启动这个account的微服务会报数据源错误
            故需要排除，临时排除而已！！-->
            <exclusions>
                <exclusion>
                    <groupId>org.apache.shardingsphere</groupId>
                    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>
</project>
```

#### 7.5.2增加main函数主类

```
package net.xdclass;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.transaction.annotation.EnableTransactionManagement;

/**
 * @Description
 * @Author 刘森飚
 **/

@MapperScan("net.xdclass.mapper")
@EnableTransactionManagement
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class AccountApplication {

    public static void main(String[] args) {
        SpringApplication.run(AccountApplication.class, args);
    }

}
```

#### 7.5.3配置application.yml

```
server:
  port: 8001


#应用名称
spring:
  application:
    name: dcloud-account

#服务注册发现
  cloud:
    nacos:
      discovery:
        server-addr: 47.94.167.237:8848
        username: nacos
        password: nacos

#数据库配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://47.94.167.237:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: Liu19971009



#配置plus打印sql日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

#### 7.5.4查看nacos注册情况

![1673364786493](短链平台项目.assets/1673364786493.png)

![1673364848263](短链平台项目.assets/1673364848263.png)

- 多个微服务增加配置+代码生成配置引入

## 8.账号注册模块

### 8.1注册功能和流程介绍

**功能需求**

```
1.使用手机号注册，已经注册的手机号不能︎复注册，密码不能使用简单的MD5加密
2.用户上传头像需要用⽂件存储
```

**安全需求**

```
1.高并发下账号唯⼀性注册邮箱或者⼿机验证码不能被恶意调用
   验证码+唯一索引
2.头像⽂件存储访问⽅便扩容和管理
   阿⾥云OSS
3.高并发处理
   异步+池化思想
```

### 8.2第三方短信验证码平台接入

**短信验证码平台选择考虑点**

```
1.各个类型短信价格
2.短信到达率、到达时间
3.⽀持多种推⼴内容的短信发放，例如业务推广、新产品宣讲、
4.短信内容变灵活，方便⽀持多场景
5.会员关怀等内容的短信
6.多维度数据统计 -查看请求、发送成功、失败、等
```

**短信平台**

```
阿⾥云：https://www.aliyun.com/product/sms
腾讯云：https://cloud.tencent.com/product/sms
第三方⼚商：https://market.aliyun.com/products/57000002/cmapi00046920.html
提供测试模板、免审核、测试成本更低


我们采用第三方厂商进行测试使用！！
```

![1673407137190](短链平台项目.assets/1673407137190.png)

![1673407167275](短链平台项目.assets/1673407167275.png)

 **短信验证码管理台地址**

```
https://market.console.aliyun.com/imageconsole/index.htm?#/bizlist?_k=9oq6tb
```

**参数**

```
AppKey：204146885 
AppSecret：6o9XbEfoyKYOIGSoTwFiKRbCibrBSkLt
AppCode：e5d8caac8369401b91462f8f1c6e4c58
templateId：M105EABDEC
```

![1673407330218](短链平台项目.assets/1673407330218.png)

![1673409495080](短链平台项目.assets/1673409495080.png)

### 8.3短信验证码发送工具类封装

#### 8.3.1RestTemplate配置

在common模块下配置

![1673409097006](短链平台项目.assets/1673409097006.png)

```
package net.xdclass.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate(ClientHttpRequestFactory requestFactory) {

        return new RestTemplate(requestFactory);
    }

    @Bean
    public ClientHttpRequestFactory  simpleClientHttpRequestFactory(){
        SimpleClientHttpRequestFactory factory  = new SimpleClientHttpRequestFactory();
        factory.setReadTimeout(10000);
        factory.setConnectTimeout(10000);
        return factory;
    }
}
```

#### 8.3.2SmsConfig配置

![1673409839820](短链平台项目.assets/1673409839820.png)

**在account模块下配置**

```
package net.xdclass.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/

@ConfigurationProperties(prefix = "sms")
@Configuration
@Data
public class SmsConfig {

    private String templateId;

    private String appCode;

}
```

**applicatiom.yml配置**

```
server:
  port: 8001


#应用名称
spring:
  application:
    name: dcloud-account

#服务注册发现
  cloud:
    nacos:
      discovery:
        server-addr: 123.57.57.196:8848
        username: nacos
        password: nacos

#数据库配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://123.57.57.196:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: Liu19971009



#配置plus打印sql日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl


#----------添加这一行--------------
#----------sms短信配置--------------
sms:
  app-code: e5d8caac8369401b91462f8f1c6e4c58
  template-id: M105EABDEC
```

#### 8.3.3SmsComponent工具类

```
package net.xdclass.component;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.config.SmsConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
@Slf4j
public class SmsComponent {
    /**
     * 发送地址
     */
    private static final String URL_TEMPLATE = "https://jmsms.market.alicloudapi.com/sms/send?mobile=%s&templateId=%s&value=%s";

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private SmsConfig smsConfig;



    /**
     * 发送短信验证码
     * @param to
     * @param templateId
     * @param value
     */
    public void send(String to,String templateId,String value) {

        String url = String.format(URL_TEMPLATE,to,templateId,value);
        HttpHeaders headers = new HttpHeaders();
        //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
        headers.set("Authorization","APPCODE " + smsConfig.getAppCode());
        HttpEntity entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
        log.info("url={},body={}",url,response.getBody());
        if (response.getStatusCode().is2xxSuccessful()) {
            log.info("发送短信验证码成功");
        }else {
            log.error("发送短信验证码失败:{}",response.getBody());
        }
    }
}
```

### 8.4短信验证码单元测试

```
package net.xdclass.biz;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.AccountApplication;
import net.xdclass.component.SmsComponent;
import net.xdclass.config.SmsConfig;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = AccountApplication.class)
@Slf4j
public class SmsTest {

    @Autowired
    private SmsComponent smsComponent;

    @Autowired
    private SmsConfig smsConfig;

    @Test
    public void testSendSms() {
        smsComponent.send("15861364032",smsConfig.getTemplateId(),"短链平台刘老湿");

    }
}
```

![1673412199185](短链平台项目.assets/1673412199185.png)

![1673412404208](短链平台项目.assets/1673412404208.png)

## 9.性能优化最佳实践(上)

### 9.1接口压测和常用压力测试工具对比

```
LoadRunner
 性能稳定，压测结果及细粒度⼤，可以⾃定义脚本进⾏压测，但是太过于⼤，功能比繁多
 
Apache AB(单接⼝压测最⽅便)
模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占⽤很多CPU，也不会占⽤太多的内存，但却会给⽬标服务器造成巨⼤的负载, 简单DDOS攻击等

Webbench
webbench⾸先fork出多个⼦进程，每个⼦进程都循环做web 访问测试。⼦进程把访问的结果通过pipe告诉⽗进程，⽗进程做最终的统微计结信果。

Jmeter (GUI)
压测不同的协议和应⽤
1. Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …)2. SOAP / REST Webservices
3. FTP
4. Database via JDBC
5. LDAP 轻⽬录访问协议
6. Message-oriented middleware (MOM) via JMS
7. Mail - SMTP(S), POP3(S) and IMAP(S)
8. TCP等等
使用场景及优点
1）功能测试
2）压⼒测试
3）分布式压⼒测试
4）纯java开发
5）上⼿容易，⾼性能
4）提供测试数据分析
5）各种报表数据图形展示


快速下载https://jmeter.apache.org/download_jmeter.cgi 
文档地址he.org/usermanual/get-start ed.htm
```

**目录**

```
bin:核⼼可执⾏⽂件，包含配置
        jmeter.bat: windows启动⽂件(window系统⼀定要配置显示⽂件拓展名)
        jmeter: mac或者linux启动⽂件
        jmeter-server：mac或者Liunx分布式压测使⽤的启动⽂件
        jmeter-server.bat：window分布式压测使⽤的启动⽂件
        jmeter.properties: 核心配置⽂件
extras：插件拓展的包


lib:核心的依赖包
```

**Jmeter语言版本中英文切换**

```
控制台修改 menu -> options -> choose language
```

![1673414951258](短链平台项目.assets/1673414951258.png)

![1673415108835](短链平台项目.assets/1673415108835.png)

### 9.2Jmeter基础功能介绍

**添加->threads->线程组（控制总体并发）**

```
线程数：虚拟⽤户数。⼀个虚拟⽤户占⽤⼀个进程或线程

准备时长（Ramp-Up Period(in seconds)）：全部线程启动的时长，⽐如100个线程，20秒，则表示20秒内 100个线程都要启动完成，每秒启动5个线程

循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环
```

![1673523488592](短链平台项目.assets/1673523488592.png)

![1673523725773](短链平台项目.assets/1673523725773.png)

**线程组->添加-> Sampler(采样器) -> Http （⼀个线程组下⾯可以增加⼏个Sampler）**

```
名称：采样器名称
注释：对这个采样器的描述

web服务器：
默认协议是http
默认端口是80
服务器名称或IP：请求的目标服务器名称或IP地址，一般是内网ip:127.0.0.1


查看测试结果
线程组->添加->监听器->察看结果树
线程组->添加->监听器->聚合报告


常规压测流程
内⽹环境
⾮GUI下压测
停⽌其他⽆关资源进程
压测机和被压测机器隔离
```

![1673523955325](短链平台项目.assets/1673523955325.png)

![1673524293833](短链平台项目.assets/1673524293833.png)

**查看测试结果**

![1673524477052](短链平台项目.assets/1673524477052.png)

![1673524798344](短链平台项目.assets/1673524798344.png)

### 9.3Jmeter性能压测实践

#### 9.3.1SmsComponent

```
package net.xdclass.component;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.config.SmsConfig;
import net.xdclass.util.CommonUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
@Slf4j
public class SmsComponent {
    /**
     * 发送地址
     */
    private static final String URL_TEMPLATE = "https://jmsms.market.alicloudapi.com/sms/send?mobile=%s&templateId=%s&value=%s";

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private SmsConfig smsConfig;



    /**
     * 发送短信验证码
     * @param to
     * @param templateId
     * @param value
     */
    public void send(String to,String templateId,String value) {
        #添加这行
        long beginTime = CommonUtil.getCurrentTimestamp();

        String url = String.format(URL_TEMPLATE,to,templateId,value);
        HttpHeaders headers = new HttpHeaders();
        //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
        headers.set("Authorization","APPCODE " + smsConfig.getAppCode());
        HttpEntity entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
        
        #添加这行
        long endTime = CommonUtil.getCurrentTimestamp();

        log.info("耗时={},url={},body={}",endTime - beginTime,url,response.getBody());
        if (response.getStatusCode().is2xxSuccessful()) {
            log.info("发送短信验证码成功");
        }else {
            log.error("发送短信验证码失败:{}",response.getBody());
        }
    }
}
```

#### 9.3.2SmsTest

```
package net.xdclass.biz;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.AccountApplication;
import net.xdclass.component.SmsComponent;
import net.xdclass.config.SmsConfig;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = AccountApplication.class)
@Slf4j
public class SmsTest {

    @Autowired
    private SmsComponent smsComponent;

    @Autowired
    private SmsConfig smsConfig;

    @Test
    public void testSendSms() {
        for (int i = 0; i < 3; i++) {
        smsComponent.send("13618051265",smsConfig.getTemplateId(),"短链平台刘老湿");
        }

    }
}
```

![1673528967675](短链平台项目.assets/1673528967675.png)

#### 9.3.3api接口实战

##### 9.3.3.1NotifyController

```
package net.xdclass.controller;


import net.xdclass.service.NotifyService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/account/v1")
public class NotifyController {

    @Autowired
    private NotifyService notifyService;

    /**
     * 测试发送验证码接口，主要用于对比优化区别
     * @return
     */
    @RequestMapping("send_code")
    public JsonData sendCode() {
        notifyService.testSend();
        return JsonData.buildSuccess();
    }
}
```

##### 9.3.3.2NotifyService

```
package net.xdclass.service;

public interface NotifyService {
    /**
     * 用于测定使用
     */
    void testSend();
}
```

##### 9.3.3.3NotifyServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.service.NotifyService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class NotifyServiceImpl implements NotifyService {

    @Autowired
    private RestTemplate restTemplate;


    @Override
    public void testSend() {
//        try {
//            TimeUnit.MILLISECONDS.sleep(200);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//    }

        ResponseEntity<String> forEntity = restTemplate.getForEntity("https://www.toutiao.com/", String.class);
        String body = forEntity.getBody();
        log.info(body);
    }
}
```

![1673529148437](短链平台项目.assets/1673529148437.png)

**压测参数配置**

```
200并发
2秒启动
循环500次


同步发送+resttemplate未池化
错误：Connection timed out 25.1到25.2qps
```

![1673530989047](短链平台项目.assets/1673530989047.png)

![1673531141169](短链平台项目.assets/1673531141169.png)

### 9.4异步请求解决方案

```
异步调⽤是相对于同步调⽤⽽⾔的，同步调⽤是指程序按预定顺序⼀步步执⾏，每⼀步必须等到上⼀步执⾏完后才能执⾏，异步调⽤则⽆需等待上⼀步程序执⾏完即可执⾏
多线程就是⼀种实现异步调⽤的⽅式
MQ也是⼀种宏观上的异步


使用⽅式
启动类⾥⾯使⽤@EnableAsync注解开启功能，⾃动扫描
定义异步任务类并使⽤@Component标记组件被容器扫描,异步⽅法加上@Async
```

#### 9.4.1AccountApplication

```
package net.xdclass;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.transaction.annotation.EnableTransactionManagement;

/**
 * @Description
 * @Author 刘森飚
 **/

@MapperScan("net.xdclass.mapper")
@EnableTransactionManagement
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
#加上这个注解
@EnableAsync
public class AccountApplication {

    public static void main(String[] args) {
        SpringApplication.run(AccountApplication.class, args);
    }

}
```

#### 9.4.2NotifyServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.service.NotifyService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class NotifyServiceImpl implements NotifyService {

    @Autowired
    private RestTemplate restTemplate;


    @Override
    #再此加上注解
    @Async
    public void testSend() {
//        try {
//            TimeUnit.MILLISECONDS.sleep(200);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//    }

        ResponseEntity<String> forEntity = restTemplate.getForEntity("https://www.toutiao.com/", String.class);
        String body = forEntity.getBody();
        log.info(body);
    }
}
```

![1673587518276](短链平台项目.assets/1673587988177.png)

#### 9.4.3@Async失效情况

```
1.注解@Async的方法不是public⽅法
2.注解@Async的返回值只能为void或者Future
3.注解@Async⽅法使⽤static修饰也会失效
4.spring⽆法扫描到异步类，没加注解@Async 或@EnableAsync注解
5.调⽤⽅与被调⽅不能在同⼀个类
  Spring 在扫描bean的时候会扫描⽅法上是否包含@Async 注解，动态地⽣成⼀个⼦类（即proxy代理类），当这个有注解的⽅法被调⽤的时候，实际上是由代理类来调⽤的，代理类在调⽤时增加异步作⽤
  如果这个有注解的⽅法是被同⼀个类中的其他⽅法调⽤
的，那么该⽅法的调⽤并没有通过代理类，⽽是直接通过原来的那个 bean，所以就失效了
所以调⽤⽅与被调⽅不能在同⼀个类，主要是使⽤了动态代理，同⼀个类的时候直接调⽤，不是通过⽣成的动态代理类调⽤
⼀般将要异步执⾏的⽅法单独抽取成⼀个类
```

### 9.5压测高QPS后的原因

```
现象：压测后很快跑完全部内容，是因为都在线程池内部的阻塞队列⾥⾯
  极容易出现OOM，或者消息丢失
  默认8个核⼼线程数占⽤满了之后, 新的调⽤就会进⼊队列, 最⼤值是Integer.MAX_VALUE，表现为没有执⾏
  
task-XXX ⽇志⾥⾯会出现递增
设置下idea启动进程的jvm参数： -Xms50M -Xmx50M
```

**说明**

```
直接使⽤ @Async 注解没指定线程池的话，即未设置TaskExecutor时
默认使⽤Spring创建ThreadPoolTaskExecutor
核⼼线程数：8
最⼤线程数：Integer.MAX_VALUE ( 21亿多)
队列使⽤LinkedBlockingQueue
容量是：Integer.MAX_VALUE
空闲线程保留时间：60s
线程池拒绝策略：AbortPolicy


会出现请求很快的请求完，就是因为阻塞队列最够的大，都在阻塞队列中缓存着，但是后台仍然在不断的刷，是因为仍然需要不断地消费。
```

**思考**

```
如果有10w个请求，然而只跑完1w个请求，然后程序宕机了，我们该如何处理？
```

### 9.6自定义线程池

```
自定义线程池可以解决上述的问题
```

![1673589436492](短链平台项目.assets/1673589436492.png)

```
线程池的时候搞混淆ThreadPoolTaskExecutor和ThreadPoolExecutor区别
1.ThreadPoolExecutor，这个类是JDK中的线程池类，继承⾃Executor，⾥⾯有⼀个execute()⽅法，⽤来执⾏线程，线程池主要提供⼀个线程队列，队列中保存着所有等待状态的线程，避免了创建与销毁的额外开销。

2.ThreadPoolTaskExecutor，是spring包下的，是Spring为我们提供的线程池类，Spring异步线程池的接⼝类是TaskExecutor，本质还是java.util.concurrent.Executor。
```

**解决方式**

```
spring会先搜索TaskExecutor类型的bean或者名字为taskExecutor的Executor类型的bean,所以我们最好来⾃定义⼀个线程池，加⼊Spring IOC容器⾥⾯，即可覆盖。
```

**自定义线程池**

#### 9.6.1ThreadPoolTaskConfig

```
package net.xdclass.config;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.ThreadPoolExecutor;

@Configuration
@EnableAsync
public class ThreadPoolTaskConfig {

    @Bean("threadPoolTaskExecutor")
    public ThreadPoolTaskExecutor threadPoolTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        //线程池创建的核心线程数，线程池维护线程的最少数量，即使没有任务需要执行，也会一直存活
        //如果设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭
        executor.setCorePoolSize(8);
        //阻塞队列 当核心线程数达到最大时，新任务会放在队列中排队等待执行
        executor.setQueueCapacity(124);

        //最大线程池数量，当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
        //任务队列已满时, 且当线程数=maxPoolSize，，线程池会拒绝处理任务而抛出异常
        executor.setMaxPoolSize(64);

        //当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
        //允许线程空闲时间30秒，当maxPoolSize的线程在空闲时间到达的时候销毁
        //如果allowCoreThreadTimeout=true，则会直到线程数量=0
        executor.setKeepAliveSeconds(30);

        //spring 提供的 ThreadPoolTaskExecutor 线程池，是有setThreadNamePrefix() 方法的。
        //jdk 提供的ThreadPoolExecutor 线程池是没有 setThreadNamePrefix() 方法的
        executor.setThreadNamePrefix("刘森飚自定义线程池-");

        // rejection-policy：当pool已经达到max size的时候，如何处理新任务
        // CallerRunsPolicy()：交由调用方线程运行，比如 main 线程；如果添加到线程池失败，那么主线程会自己去执行该任务，不会等待线程池中的线程去执行
        // AbortPolicy()：该策略是线程池的默认策略，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。
        // DiscardPolicy()：如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常
        // DiscardOldestPolicy()：丢弃队列中最老的任务，队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列

        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
        executor.initialize();
        return executor;
    }
}
```

#### 9.6.2NotifyServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.service.NotifyService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
@Slf4j
public class NotifyServiceImpl implements NotifyService {

    @Autowired
    private RestTemplate restTemplate;


    @Override
    #添加这一行
    @Async("threadPoolTaskExecutor")
    public void testSend() {
//        try {
//            TimeUnit.MILLISECONDS.sleep(200);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//    }

        ResponseEntity<String> forEntity = restTemplate.getForEntity("https://www.toutiao.com/", String.class);
        String body = forEntity.getBody();
        log.info(body);
    }
}
```

![1673592136539](短链平台项目.assets/1673592136539.png)

![1673592871001](短链平台项目.assets/1673592871001.png)

**总结**

```
先是CorePoolSize是否满足，然后是Queue阻塞队列是否满，最后才是MaxPoolSize是否满足。
```

### 9.7ThreadPoolTaskExecutor面试题

#### 9.7.1请你说下 ThreadPoolTaskExecutor线程池 有哪几个重要参数，什么时候会创建线程

```
1.查看核⼼线程池是否已满，不满就创建⼀条线程执⾏任务，否则执⾏第⼆步。
2.查看阻塞队列是否已满，不满就将任务存储在阻塞队列中，否则执⾏第三步。
3.查看线程池是否已满，即是否达到最⼤线程池数，不满就创建⼀条线程执⾏任务，否则就按照策略处理⽆法执⾏的任务。
```

#### 9.7.2高并发下核心线程怎么设置？

```
分IO密集还是CPU密集
CPU密集设置为跟核心数⼀样⼤⼩
IO密集型设置为2倍CPU核心数
非固定，根据实际情况压测进⾏调整，俗称调参程序员
```

### 9.8线程池多参数调整

- 异步发送+ resttemplate未池化


```
threadPoolTaskExecutor.setCorePoolSize(4);
threadPoolTaskExecutor.setMaxPoolSize(16);
threadPoolTaskExecutor.setQueueCapacity(32);
```

qps少，等待队列小

- 异步发送+resttemplate未池化

```
threadPoolTaskExecutor.setCorePoolSize(32);
threadPoolTaskExecutor.setMaxPoolSize(64);
threadPoolTaskExecutor.setQueueCapacity(10000);
//如果等待队列⻓度为10万，则qps瞬间很⾼8k+,可能oom
```


qps，等待队列⼤(瞬间⾼)

- 问题

```
1.采⽤异步发送⽤户体验变好了，但是存在丢失的可能，阻塞队列存储内存中，如果队列⻓度过多则容易出现丢失数据情况。
2.采⽤了异步发送了+阻塞队列存缓冲，刚开始瞬间QPS⾼，但是后续也降低很多
3.问题是在哪⾥？消费⽅⻆度，提⾼消费能⼒
```

## 10.性能优化最佳实践(下)

### 10.1Broken pipe错误

- 同步发送+resttemplate未池化

```
压测结果 ⼏百吞吐量
错误Caused by: java.io.IOException: Broken pipe
1.服务端向前端socket连接管道写返回数据时 链接（pipe）却断开了
2.从应⽤⻆度分析，这是因为客户端等待返回超时了，主动断开了与服务端链接
3.连接数设置太⼩，并发量增加后，造成⼤量请求排队等待
4.⽹络延迟，是否有丢包
5.内存是否⾜够多⽀持对应的并发量
```

- 问题分析

```
resttemplate底层是怎样的？
基于之前的认知-池化思想，联想到是否使⽤了http连接池？
```

- 重新认识RestTemplate

```
RestTemplate是Spring提供的⽤于访问Rest服务的客户端
底层通过使⽤java.net包下的实现创建HTTP请求
通过使⽤ClientHttpRequestFactory指定不同的HTTP请求⽅式，主要提供了两种实现⽅式
1.SimpleClientHttpRequestFactory（默认）
  底层使⽤J2SE提供的⽅式，既java.net包提供的⽅式，创建底层的Http请求连接
  主要createRequest⽅法（ 断点调试），每次都会创建⼀个新的连接，每次都创建连接会造成极⼤的资源浪费，⽽且若连接不能及时释放，会因为⽆法建⽴新的连接导致后⾯的请求阻塞
  
  
2.HttpComponentsClientHttpRequestFactory
底层使⽤HttpClient访问远程的Http服务
```

- 问题解决

```
客户端每次请求都要和服务端建⽴新的连接，即三次握⼿将会⾮常耗时
通过http连接池可以减少连接建⽴与释放的时间，提升http请求的性能
Spring的restTemplate是对httpclient进⾏了封装, ⽽httpclient是⽀持池化机制


拓展
对httpclient进⾏封装的有：Apache的Fluent、es的restHighLevelClient、spring的restTemplate等
```

### 10.2高性能RestTemplate

common/RestTemplateConfig

**作用就是提高消费的性能**

```
package net.xdclass.config;


import org.apache.http.client.HttpClient;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate(ClientHttpRequestFactory requestFactory) {
        return new RestTemplate(requestFactory);
    }

    @Bean
    public ClientHttpRequestFactory  httpRequestFactory(){
        return new HttpComponentsClientHttpRequestFactory(httpClient());
    }

    @Bean
    public HttpClient httpClient() {
        Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create()
                .register("http", PlainConnectionSocketFactory.getSocketFactory())
                .register("https", SSLConnectionSocketFactory.getSocketFactory())
                .build();

        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(registry);
        //设置连接池最大是500个连接
        connectionManager.setMaxTotal(500);
        //MaxPerRoute是对maxtotal的细分，每个主机的并发最大是300，route是指域名
        connectionManager.setDefaultMaxPerRoute(300);
        RequestConfig requestConfig = RequestConfig.custom()
                //返回数据的超时时间
                .setSocketTimeout(20000)
                //连接上服务器的超时时间
                .setConnectTimeout(10000)
                //从连接池中获取连接的超时时间
                .setConnectionRequestTimeout(1000)
                .build();
        CloseableHttpClient closeableHttpClient = HttpClientBuilder.create().setDefaultRequestConfig(requestConfig)
                .setConnectionManager(connectionManager)
                .build();

        return closeableHttpClient;

    }
}
```

### 10.3十倍QPS提升

- 同步发送+resttemplate未池化

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.service.NotifyService;
import net.xdclass.util.CommonUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
@Slf4j
public class NotifyServiceImpl implements NotifyService {

    @Autowired
    private RestTemplate restTemplate;


    @Override
    #注释掉下一行，表示同步
    //@Async("threadPoolTaskExecutor")
    public void testSend() {
//        try {
//            TimeUnit.MILLISECONDS.sleep(200);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//    }

        long beginTime = CommonUtil.getCurrentTimestamp();
        ResponseEntity<String> forEntity = restTemplate.getForEntity("https://www.toutiao.com/", String.class);
        String body = forEntity.getBody();
        long endTime = CommonUtil.getCurrentTimestamp();
        log.info("耗时={},body={}",endTime-beginTime,body);
    }
}
```

​          压测结果 ⼏百 吞吐量

- 同步发送+resttemplate池化

![1673601040643](短链平台项目.assets/1673601040643.png)

## 11.短信验证码优化

### 11.1调用第三方短信验证码优化实战

**SmsComponent**

- 调整代码
- 采用异步调用方式
- 采⽤resttemplate池化方式

```
package net.xdclass.component;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.config.SmsConfig;
import net.xdclass.util.CommonUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
@Slf4j
public class SmsComponent {
    /**
     * 发送地址
     */
    private static final String URL_TEMPLATE = "https://jmsms.market.alicloudapi.com/sms/send?mobile=%s&templateId=%s&value=%s";

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private SmsConfig smsConfig;



    /**
     * 发送短信验证码
     * @param to
     * @param templateId
     * @param value
     */
     #在此处添加异步注解
    @Async("threadPoolTaskExecutor")
    public void send(String to,String templateId,String value) {

        long beginTime = CommonUtil.getCurrentTimestamp();

        String url = String.format(URL_TEMPLATE,to,templateId,value);
        HttpHeaders headers = new HttpHeaders();
        //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
        headers.set("Authorization","APPCODE " + smsConfig.getAppCode());
        HttpEntity entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);

        long endTime = CommonUtil.getCurrentTimestamp();

        log.info("耗时={},url={},body={}",endTime - beginTime,url,response.getBody());
        if (response.getStatusCode().is2xxSuccessful()) {
            log.info("发送短信验证码成功");
        }else {
            log.error("发送短信验证码失败:{}",response.getBody());
        }
    }
}
```

### 11.2图形验证码kaptcha引入

#### 11.2.1聚合工程依赖添加

**pom.xml**

```
        <!--验证码kaptcha依赖包-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>kaptcha-spring-boot-starter</artifactId>
                <version>${captcha.version}</version>
            </dependency>
```

#### 11.2.2account依赖添加

**pom.xml**

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>dcloud-short-link</artifactId>
        <groupId>net.xdclass</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>dcloud-account</artifactId>

    <dependencies>
        <dependency>
            <groupId>net.xdclass</groupId>
            <artifactId>dcloud-common</artifactId>
            <version>1.0-SNAPSHOT</version>
            <!--因为引入shardingsphere启动这个account的微服务会报数据源错误
            故需要排除-->
            <exclusions>
                <exclusion>
                    <groupId>org.apache.shardingsphere</groupId>
                    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!--图形验证码引入-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>kaptcha-spring-boot-starter</artifactId>
        </dependency>
    </dependencies>
</project>
```

#### 11.2.3开发配置

```
package net.xdclass.config;

import com.google.code.kaptcha.Constants;
import com.google.code.kaptcha.impl.DefaultKaptcha;
import com.google.code.kaptcha.util.Config;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Properties;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
public class CaptchaConfig {
    /**
     * 验证码配置类
     * @return
     */
    @Bean
    @Qualifier("captchaProducer")
    public DefaultKaptcha kaptcha() {
        DefaultKaptcha kaptcha = new DefaultKaptcha();
        Properties properties = new Properties();
//		properties.setProperty(Constants.KAPTCHA_BORDER, "yes");
//		properties.setProperty(Constants.KAPTCHA_BORDER_COLOR, "220,220,220");
//		//properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_COLOR, "38,29,12");
//		properties.setProperty(Constants.KAPTCHA_IMAGE_WIDTH, "147");
//		properties.setProperty(Constants.KAPTCHA_IMAGE_HEIGHT, "34");
//		properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_SIZE, "25");
//		//properties.setProperty(Constants.KAPTCHA_SESSION_KEY, "code");
        //验证码个数
        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, "4");
//		properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_NAMES, "Courier");
        //字体间隔
        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_SPACE,"8");
        //干扰线颜色
//		properties.setProperty(Constants.KAPTCHA_NOISE_COLOR, "white");
        //干扰实现类
        properties.setProperty(Constants.KAPTCHA_NOISE_IMPL, "com.google.code.kaptcha.impl.NoNoise");
        //图片样式
        properties.setProperty(Constants.KAPTCHA_OBSCURIFICATOR_IMPL, "com.google.code.kaptcha.impl.WaterRipple");
        //文字来源
        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_STRING, "0123456789");
        Config config = new Config(properties);
        kaptcha.setConfig(config);
        return kaptcha;
    }
}
```

#### 11.2.4Controller测试

```
package net.xdclass.controller;


import com.google.code.kaptcha.Producer;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.service.NotifyService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.IOException;

@RestController
@RequestMapping("/api/account/v1")
@Slf4j
public class NotifyController {

    @Autowired
    private NotifyService notifyService;

    @Autowired
    private Producer captchProducer;



    /**
     * 生成验证码
     * @param request
     * @param response
     */
    @GetMapping("captcha")
    public void getCaptcha(HttpServletRequest request, HttpServletResponse response) {
        String captchaText = captchProducer.createText();
        log.info("验证码内容:{}",captchaText);

        //存储redis,配置过期时间 TODO
        //生成图片内容,缓冲流
        BufferedImage bufferedImage = captchProducer.createImage(captchaText);
        try {
            ServletOutputStream outputStream = response.getOutputStream();
            ImageIO.write(bufferedImage,"jpg",outputStream);
            outputStream.flush();
            outputStream.close();
        } catch (IOException e) {
            log.error("获取流出错{}",e.getMessage());
        }

    }


    /**
     * 测试发送验证码接口，主要用于对比优化区别
     * @return
     */
    @RequestMapping("send_code")
    public JsonData sendCode() {
        return JsonData.buildSuccess();
    }
}
```

![1673620718187](短链平台项目.assets/1673620718187.png)

### 11.3Redis6.X配置连接池

- 连接池好处

```
1.使⽤连接池不⽤每次都⾛三次握⼿、每次都关闭Jedis
2.相对于直连，使⽤相对麻烦，在资源管理上需要很多参数来保证，规划不合理也会出现问题
3.如果pool已经分配了maxActive个jedis实例，则此时pool的状态就成exhausted了
```

#### 11.3.1配置common项目

- pom.xml

```
 <!--redis客户端-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>io.lettuce</groupId>
                    <artifactId>lettuce-core</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
```

#### 11.3.2配置Redis连接

- application.yml

```
server:
  port: 8001


#应用名称
spring:
  application:
    name: dcloud-account

#服务注册发现
  cloud:
    nacos:
      discovery:
        server-addr: 101.200.159.132:8848
        username: nacos
        password: nacos

#数据库配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://101.200.159.132:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: Liu19971009


#redis配置
  redis:
    client-type: jedis
    host: 101.200.159.132
    password: Liu19971009
    port: 6379
    jedis:
      pool:
        # 连接池最大连接数（使用负值表示没有限制）
        max-active: 100
        # 连接池中的最大空闲连接
        max-idle: 100
        # 连接池中的最小空闲连接
        min-idle: 100
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: 60000

#配置plus打印sql日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

#----------sms短信配置--------------
sms:
  app-code: e5d8caac8369401b91462f8f1c6e4c58
  template-id: M105EABDEC
```

#### 11.3.3序列化配置

- common/config/RedisTemplateConfiguration

```
package net.xdclass.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
public class RedisTemplateConfiguration {


    @Bean
    public RedisTemplate<Object,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){

        RedisTemplate<Object,Object> redisTemplate = new RedisTemplate<>();

        redisTemplate.setConnectionFactory(redisConnectionFactory);

        //配置序列化规则
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        //ObjectMapper是Jackson里面的
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);


        //设置key-value序列化规则
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);

        //设置hash-value序列化规则
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);

        return redisTemplate;

    }

}
```

### 11.4图形验证码加入缓存

```
redis做隔离, 多集群：核⼼集群和⾮核⼼集群，⾼并发集群和⾮⾼并发集群
资源隔离
数据保护
提⾼性能
key规范：业务划分，冒号隔离
account-service:captcha:xxxx
⻓度不能过⻓
```

- 验证码接⼝开发

```
package net.xdclass.controller;

import com.google.code.kaptcha.Producer;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.service.NotifyService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.concurrent.TimeUnit;

/**
 * @Description
 * @Author 刘森飚
 **/

@RestController
@RequestMapping("/api/account/v1")
@Slf4j
public class NotifyController {


    @Autowired
    private Producer captchaProducer;


    @Autowired
    private NotifyService notifyService;

    @Autowired
    private StringRedisTemplate redisTemplate;


    /**
     * 验证码过期时间
     */
    private static final long CAPTCHA_CODE_EXPIRED = 1000 * 10 *  60;

    /**
     * 生成验证码
     * @param request
     * @param response
     */
    @GetMapping("captcha")
    public void getCaptcha(HttpServletRequest request, HttpServletResponse response){


        String captchaText = captchaProducer.createText();
        log.info("验证码内容:{}",captchaText);

        //存储redis,配置过期时间 ， jedis/lettuce
        redisTemplate.opsForValue().set(getCaptchaKey(request),captchaText,CAPTCHA_CODE_EXPIRED,TimeUnit.MILLISECONDS);


        BufferedImage bufferedImage = captchaProducer.createImage(captchaText);

        try (ServletOutputStream outputStream = response.getOutputStream()){

            ImageIO.write(bufferedImage,"jpg",outputStream);
            outputStream.flush();

        } catch (IOException e) {
            log.error("获取流出错:{}",e.getMessage());
        }

    }



    private String getCaptchaKey(HttpServletRequest request){

        String ip = CommonUtil.getIpAddr(request);
        String userAgent = request.getHeader("User-Agent");
        String key = "account-service:captcha:"+CommonUtil.MD5(ip+userAgent);
        log.info("验证码key:{}",key);
        return key;
    }
```

![1673681255237](短链平台项目.assets/1673681255237.png)

![1673681268434](短链平台项目.assets/1673681268434.png)

![1673681331687](短链平台项目.assets/1673681331687.png)

- try-with-resources

```
资源的关闭很多⼈停留在旧的流程上，jdk7新特性就有, 但是很多⼈以为是jdk8的
在try( ...)⾥声 明的资源，会在try-catch代码块结束后⾃动关闭掉


注意点
实现了AutoCloseable接⼝的类，在try()⾥声明该类实例的时候，try结束后⾃动调⽤的 close⽅法，这个动作会早于finally⾥调⽤的⽅法
不管是否出现异常，try()⾥的实例都会被调⽤close⽅法
try⾥⾯可以声明多个⾃动关闭的对象，越早声明的对象，会越晚被close掉
```

### 11.5短信验证码开发

#### 11.5.1SendCodeRequest

- account/controller/request/SendCodeRequest

```
package net.xdclass.controller.request;

import lombok.Data;

/**
 * @Author 刘森飚
 **/


@Data
public class SendCodeRequest {

    private String captcha;

    private String to;
}
```

#### 11.5.2NotifyController

- account/controller/NotifyController

```
package net.xdclass.controller;

import com.google.code.kaptcha.Producer;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.controller.request.SendCodeRequest;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.SendCodeEnum;
import net.xdclass.service.NotifyService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.*;

import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.concurrent.TimeUnit;

/**
 * @Description
 * @Author 刘森飚
 **/

@RestController
@RequestMapping("/api/account/v1")
@Slf4j
public class NotifyController {


    @Autowired
    private Producer captchaProducer;


    @Autowired
    private NotifyService notifyService;

    @Autowired
    private StringRedisTemplate redisTemplate;


    /**
     * 验证码过期时间
     */
    private static final long CAPTCHA_CODE_EXPIRED = 1000 * 10 *  60;

    /**
     * 生成验证码
     * @param request
     * @param response
     */
    @GetMapping("captcha")
    public void getCaptcha(HttpServletRequest request, HttpServletResponse response){


        String captchaText = captchaProducer.createText();
        log.info("验证码内容:{}",captchaText);

        //存储redis,配置过期时间
        redisTemplate.opsForValue().set(getCaptchaKey(request),captchaText,CAPTCHA_CODE_EXPIRED,TimeUnit.MILLISECONDS);


        BufferedImage bufferedImage = captchaProducer.createImage(captchaText);

        try (ServletOutputStream outputStream = response.getOutputStream()){

            ImageIO.write(bufferedImage,"jpg",outputStream);
            outputStream.flush();

        } catch (IOException e) {
            log.error("获取流出错:{}",e.getMessage());
        }

    }



    private String getCaptchaKey(HttpServletRequest request){

        String ip = CommonUtil.getIpAddr(request);
        String userAgent = request.getHeader("User-Agent");
        String key = "account-service:captcha:"+CommonUtil.MD5(ip+userAgent);
        log.info("验证码key:{}",key);
        return key;
    }




    /**
     * 发送验证码接口
     * @return
     */
    @PostMapping("send_code")
    public JsonData sendCode(@RequestBody SendCodeRequest sendCodeRequest,HttpServletRequest request){
        String key = getCaptchaKey(request);
        String cacheCaptcha = redisTemplate.opsForValue().get(key);

        String captcha = sendCodeRequest.getCaptcha();
        if (captcha != null && cacheCaptcha != null && cacheCaptcha.equalsIgnoreCase(captcha)) {
            //成功
            redisTemplate.delete(key);
            JsonData jsonData = notifyService.sendCode(SendCodeEnum.USER_REGISTER,sendCodeRequest.getTo());
            return jsonData;

        }else {
        return JsonData.buildResult(BizCodeEnum.CODE_CAPTCHA_ERROR);
        }
    }

}
```

#### 11.5.3NotifyService

```
package net.xdclass.service;

import net.xdclass.enums.SendCodeEnum;
import net.xdclass.util.JsonData;

public interface NotifyService {


    /**
     * 发送短信验证码
     * @param sendCodeEnum
     * @param to
     * @return
     */
    JsonData sendCode(SendCodeEnum sendCodeEnum, String to);
}
```

#### 11.5.4NotifyServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.component.SmsComponent;
import net.xdclass.config.SmsConfig;
import net.xdclass.constant.RedisKey;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.SendCodeEnum;
import net.xdclass.service.NotifyService;
import net.xdclass.util.CheckUtil;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JsonData;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class NotifyServiceImpl implements NotifyService {

    /**
     * 10分钟有效
     */
    private static final int CODE_EXPIRED = 60*1000*10;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private SmsComponent smsComponent;

    @Autowired
    private SmsConfig smsConfig;

    @Autowired
    private StringRedisTemplate redisTemplate;


    @Override
    public JsonData sendCode(SendCodeEnum sendCodeEnum, String to) {
        String cacheKey = String.format(RedisKey.CHECK_CODE_KEY, sendCodeEnum.name(), to);
        String cacheValue = redisTemplate.opsForValue().get(cacheKey);

        //如果不为空，再判断是否60s内重复发送
        if (StringUtils.isNotBlank(cacheValue)) {
            long ttl = Long.parseLong(cacheValue.split("_")[1]);
            //当前时间戳-验证码发送的时间戳，如果小于60秒，则不给重复发送
            long leftTime = CommonUtil.getCurrentTimestamp() - ttl;
            if (leftTime < (1000 * 60)) {
                log.info("重复发送短信验证码，时间间隔:{}秒",leftTime);
                return JsonData.buildResult(BizCodeEnum.CODE_LIMITED);
            }
        }

        String code = CommonUtil.getRandomCode(6);
        //生成拼接好的验证码
        String value = code + "_" + CommonUtil.getCurrentTimestamp();
        redisTemplate.opsForValue().set(cacheKey,value,CODE_EXPIRED, TimeUnit.MILLISECONDS);

        if (CheckUtil.isEmail(to)) {
            //发送邮箱验证码 TODO
        }else if(CheckUtil.isPhone(to)) {
            //发送手机验证码
            smsComponent.send(to,smsConfig.getTemplateId(),code);
        }
        return JsonData.buildSuccess();
    }
}
```

#### 11.5.5CheckUtil

- common/util/CheckUtil

```
package net.xdclass.util;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Description
 * @Author 刘森飚

 **/
public class CheckUtil {

    /**
     * 邮箱正则
     */
    private static final Pattern MAIL_PATTERN = Pattern.compile
            ("^([a-z0-9A-Z]+[-|\\.]?)+[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\.)+[a-zA-Z]{2,}$");

    /**
     * 手机号正则
     */
    private static final Pattern PHONE_PATTERN = Pattern.compile
            ("^((13[0-9])|(14[0-9])|(15[0-9])|(17[0-9])|(18[0-9]))\\d{8}$");

    /**
     * @param email
     * @return
     */
    public static  boolean isEmail(String email) {
        if (null == email || "".equals(email)) {
            return false;
        }
        Matcher m = MAIL_PATTERN.matcher(email);
        return m.matches();
    }

    /**
     *
     * @param phone
     * @return
     */
    public static boolean isPhone(String phone) {
        if (null == phone || "".equals(phone)) {
            return false;
        }
        Matcher m = PHONE_PATTERN.matcher(phone);
        boolean result = m.matches();
        return result;
    }
}
```

#### 11.5.6RedisKey

- common/constant/RedisKey

```
package net.xdclass.constant;


/**
 * author:刘森飚
 */
public class RedisKey {
    /**
     * 验证码缓存key，第一个是类型,第二个是唯一标识比如手机号或者邮箱
     */
    public static final String CHECK_CODE_KEY = "code:%s:%s";
}
```

#### 11.5.7验证结果

![1673704521920](短链平台项目.assets/1673704521920.png)

![1673704562915](短链平台项目.assets/1673704562915.png)

![1673705481446](短链平台项目.assets/1673705481446.png)

![1673704574302](短链平台项目.assets/1673704574302.png)

![1673704598593](短链平台项目.assets/1673704598593.png)

## 12阿里云OSS实战

### 12.1OSS开通

- 开通阿里云OSS

```
有阿⾥云账号、实名认证
OSS介绍：https://www.aliyun.com/product/oss
OSS控制台：https://oss.console.aliyun.com/bucket
学习路径：https://help.aliyun.com/learn/learningpath/oss.html
```

- 开通后的操作

```
创建Bucket
上传⽂件
访问⽂件
```

![1673708434013](短链平台项目.assets/1673708434013.png)

![1673708456339](短链平台项目.assets/1673708456339.png)

### 12.2OSS权限知识

- ACL: Access Control List 访问控制列表

```
以前盛⾏的⼀种权限设计，它的核⼼在于⽤户直接和权限挂钩
优点：简单易⽤，开发便捷
缺点：⽤户和权限直接挂钩，导致在授予时的复杂性，⽐较分散，不便于管理
例⼦：常⻅的⽂件系统权限设计, 直接给⽤户加权限
```

- RBAC: Role Based Access Control

```
基于⻆⾊的访问控制系统。权限与⻆⾊相关联，⽤户通过成为适当⻆⾊的成员⽽得到这些⻆⾊的权限
优点：简化了⽤户与权限的管理，通过对⽤户进⾏分类，使得⻆⾊与权限关联起来
缺点：开发对⽐ACL相对复杂
例⼦：基于RBAC模型的权限验证框架与应⽤ Apache Shiro、spring Security

总结：不能过于复杂，规则过多，维护性和性能会下降， 更多分类 ABAC、PBAC等
```

- RAM权限介绍

```
阿⾥云⽤于各个产品的权限，基于RBAC、ACL模型都有，进⾏简单管理账号、统⼀分配权限、集中管控资源，从⽽建⽴安全、完善的资源控制体系。
众多产品，⼀般采⽤⼦账号进⾏分配权限，防⽌越权攻击
建⽴⽤户，勾选编程访问（保存accessKey和accessSecret，只出现⼀次）
```

![1673709658426](短链平台项目.assets/1673709658426.png)

![1673709860884](短链平台项目.assets/1673709860884.png)

![1673709912557](短链平台项目.assets/1673709912557.png)

```
AccessKey ID：LTAI5tHjCyZXXsqXqPzMtBvu
AccessKey Secret：I4Jhw3NTmz7H7DJXHmzafT2CTE7ZkM
```

- 为新建用户授权OSS全部权限

![1673710672550](短链平台项目.assets/1673710672550.png)

![1673710710620](短链平台项目.assets/1673710710620.png)

### 12.3SDK集成和上传组件开发

- **文件上传流程**

```
先上传⽂件，返回url地址，再和普通表单⼀并提交（推荐这种,更加灵活，失败率低）
⽂件和普通表单⼀并提交（设计流程⽐较多，容易超时和失败）
注意：默认SpringBoot2最⼤⽂件上传是1M

@requestPart注解 接收⽂件以及其他更为复杂的数据类型
```

#### 12.3.1添加maven依赖

```
 <!--阿里云oss-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun.oss.version}</version>
            </dependency>
```

#### 12.3.2账号微服务添加

```
<!-- OSS各个项目单独加依赖，根据需要进行添加-->
        <dependency>
            <groupId>com.aliyun.oss</groupId>
            <artifactId>aliyun-sdk-oss</artifactId>
        </dependency>
```

#### 12.3.3账号微服务配置application.yml

```
aliyun:
  oss:
    endpoint: oss-cn-hangzhou.aliyuncs.com
    access-key-id: LTAI5tHjCyZXXsqXqPzMtBvu
    access-key-secret: I4Jhw3NTmz7H7DJXHmzafT2CTE7ZkM
    bucketname: dcloud-link-liu
```

#### 12.3.4新建配置类

- account/config/OSSConfig

```
package net.xdclass.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/
@ConfigurationProperties(prefix = "aliyun.oss")
@Configuration
@Data
public class OSSConfig {

    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketname;
}
```

#### 12.3.5开发controller

```
package net.xdclass.controller;


import net.xdclass.enums.BizCodeEnum;
import net.xdclass.service.FileService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

/**
 * @author 刘森飚
 * @since 2023-01-09
 */
@RestController
@RequestMapping("/api/v1/account")
public class AccountController {

    @Autowired
    private FileService fileService;

    /**
     * 文件上传 最大默认1M
     * @param file
     * @return
     */
    @PostMapping("upload")
    public JsonData uploadUserImg(@RequestPart("file")MultipartFile file) {
        String result = fileService.uploadUserImg(file);
        return result != null ? JsonData.buildSuccess(result) :
                JsonData.buildResult(BizCodeEnum.FILE_UPLOAD_USER_IMG_FAIL);
    }
}
```

#### 12.3.6开发service

```
package net.xdclass.service;

import org.springframework.web.multipart.MultipartFile;

public interface FileService {

    /**
     * 文件上传
     * @param file
     * @return
     */
    String uploadUserImg(MultipartFile file);
}
```

#### 12.3.7开发FileServiceImpl

```
package net.xdclass.service.impl;

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.model.PutObjectResult;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.config.OSSConfig;
import net.xdclass.service.FileService;
import net.xdclass.util.CommonUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;


@Service
@Slf4j
public class FileServiceImpl implements FileService {

    @Autowired
    private OSSConfig ossConfig;

    @Override
    public String uploadUserImg(MultipartFile file) {
        String bucketname = ossConfig.getBucketname();
        String endpoint = ossConfig.getEndpoint();
        String accessKeyId = ossConfig.getAccessKeyId();
        String accessKeySecret = ossConfig.getAccessKeySecret();

        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        //xxx.jpg
        String originalFilename = file.getOriginalFilename();

        //jdk8语法获取日期格式
        LocalDateTime ldt = LocalDateTime.now();
        DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy/MM/dd");

        String folder = pattern.format(ldt);
        String fileName = CommonUtil.generateUUID();

        //拿到后缀
        String extendsion = originalFilename.substring(originalFilename.lastIndexOf("."));

        //在oss的bucket上创建文件夹
        String newFilename = "user/" + folder + "/" + fileName + extendsion;

        //推送到阿里云上
        try {
            PutObjectResult putObjectResult = ossClient.putObject(bucketname, newFilename, file.getInputStream());
            //拼装返回路径
            if (putObjectResult != null) {
                String imgUrl = "https://" + bucketname + "." + endpoint + "/" + newFilename;
                return imgUrl;
            }
        } catch (IOException e) {
            log.error("文件上传失败:{}",e.getMessage());
        }finally {
            ossClient.shutdown();
        }

        return null;
    }
}
```

![1673715233496](短链平台项目.assets/1673715233496.png)

![1673715276949](短链平台项目.assets/1673715276949.png)

## 13.账号模块

### 13.1注册接口开发

#### 13.1.1AccountRegisterRequest

```
package net.xdclass.controller.request;

import lombok.Data;

/**
 * @Description
 * @Author 刘森飚
 **/

@Data
public class AccountRegisterRequest {

    /**
     * 头像
     */
    private String headImg;

    /**
     * 手机号
     */
    private String phone;

    /**
     * 密码
     */
    private String pwd;



    /**
     * 邮箱
     */
    private String mail;

    /**
     * 用户名
     */
    private String username;


    /**
     * 短信验证码
     */
    private String code;

}
```

#### 13.1.2AccountController

```
  /**
     * 用户注册
     * @param registerRequest
     * @return
     */
    @PostMapping("register")
    public JsonData register(@RequestBody AccountRegisterRequest registerRequest) {
        JsonData jsonData = accountService.register(registerRequest);
        return jsonData;
    }
```

#### 13.1.3AccountService

```
package net.xdclass.service;

import net.xdclass.controller.request.AccountRegisterRequest;
import net.xdclass.model.AccountDO;
import com.baomidou.mybatisplus.extension.service.IService;
import net.xdclass.util.JsonData;

/**
 * @author 刘森飚
 * @since 2023-01-09
 */
public interface AccountService {
    /**
     * 用户注册
     * @param registerRequest
     * @return
     */
    JsonData register(AccountRegisterRequest registerRequest);
}
```

#### 13.1.4AccountServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.controller.request.AccountRegisterRequest;
import net.xdclass.enums.AuthTypeEnum;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.SendCodeEnum;
import net.xdclass.manager.AccountManager;
import net.xdclass.model.AccountDO;
import net.xdclass.mapper.AccountMapper;
import net.xdclass.service.AccountService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import net.xdclass.service.NotifyService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JsonData;
import org.apache.commons.codec.digest.Md5Crypt;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @author 刘森飚
 * @since 2023-01-09
 */
@Service
@Slf4j
public class AccountServiceImpl implements AccountService {

    @Autowired
    private NotifyService notifyService;

    @Autowired
    private AccountManager accountManager;


    /**
     * ⼿机验证码验证
     * 密码加密（TODO）
     * 账号唯⼀性检查(TODO)
     * 插⼊数据库
     * 新注册用户福利发放(TODO)
     * @param registerRequest
     * @return
     */
    @Override
    public JsonData register(AccountRegisterRequest registerRequest) {
        boolean checkCode = false;
        //判断验证码
        if (StringUtils.isNotBlank(registerRequest.getPhone())) {
            checkCode = notifyService.checkCode(SendCodeEnum.USER_REGISTER, registerRequest.getPhone(), registerRequest.getCode());
        }

        //验证码错误
        if (!checkCode) {
            return JsonData.buildResult(BizCodeEnum.CODE_ERROR);
        }

        AccountDO accountDO = new AccountDO();
        BeanUtils.copyProperties(registerRequest,accountDO);
        //认证级别
        accountDO.setAuth(AuthTypeEnum.DEFAULT.name());

        //密码加密 密钥(盐)
        accountDO.setSecret("$1$" + CommonUtil.getStringNumRandom(8));

        String cryptPwd = Md5Crypt.md5Crypt(registerRequest.getPwd().getBytes(), accountDO.getSecret());
        accountDO.setPwd(cryptPwd);

        int rows = accountManager.insert(accountDO);
        log.info("rows:{},注册成功:{}",rows,accountDO);

        //用户注册成功，发放福利
        userRegisterInitTask(accountDO);
        return JsonData.buildSuccess();
    }

    /**
     * 用户初始化福利，流量包 TODO
     * @param accountDO
     */
    private void userRegisterInitTask(AccountDO accountDO) {

    }
}
```

#### 13.1.5NotifyService

```
    /**
     * 校验验证码
     * @param sendCodeEnum
     * @param to
     * @param code
     * @return
     */
    boolean checkCode(SendCodeEnum sendCodeEnum, String to,String code);
```

#### 13.1.6NotifyServiceImpl

```
/**
     * 验证码校验逻辑
     * @param sendCodeEnum
     * @param to
     * @param code
     * @return
     */
    @Override
    public boolean checkCode(SendCodeEnum sendCodeEnum, String to, String code) {
        String cacheKey = String.format(RedisKey.CHECK_CODE_KEY, sendCodeEnum.name(), to);
        String cacheValue = redisTemplate.opsForValue().get(cacheKey);

        if (StringUtils.isNotBlank(cacheValue)) {
            String cacheCode = cacheValue.split("_")[0];
            if (cacheCode.equalsIgnoreCase(code)) {
                //删除验证码
                redisTemplate.delete(code);
                return true;
            }
        }
        return false;
    }
```

#### 13.1.7AuthTypeEnum

- common/enums/AuthTypeEnum

```
package net.xdclass.enums;

public enum AuthTypeEnum {

    /**
     * 默认级别
     */
    DEFAULT,

    /**
     * 实名制
     */
    REALNAME,

    /**
     * 企业
     */
    ENTERPRISE;

}
```

#### 13.1.8AccountManager

```
package net.xdclass.manager;

import net.xdclass.model.AccountDO;

public interface AccountManager {

    int insert(AccountDO accountDO);
}
```

#### 13.1.9AccountManagerImpl

```
package net.xdclass.manager.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.AccountManager;
import net.xdclass.mapper.AccountMapper;
import net.xdclass.model.AccountDO;
import net.xdclass.service.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

/**
 * @Description
 * @Author 刘森飚
 **/

@Component
@Slf4j
public class AccountManagerImpl implements AccountManager {

    @Autowired
    private AccountMapper accountMapper;

    @Override
    public int insert(AccountDO accountDO) {

        return accountMapper.insert(accountDO);
    }
}

```

- 注册接口json数据

```
{
    "phone":"15861364032",
    "pwd":"123456",
    "username":"paranoid",
    "headImg":"https://dcloud-link-liu.oss-cn-hangzhou.aliyuncs.com/user/2023/01/15/69cf38898fe04a6da780e29b26394bd7.jpg",
    "code":"385652"
}
```

![1673786657557](短链平台项目.assets/1673786657557.png)

![1673786683080](短链平台项目.assets/1673786683080.png)

### 13.2登录接口开发

#### 13.2.1AccountLoginRequest

```
package net.xdclass.controller.request;

import lombok.Data;

/**
 * @Description
 * @Author 刘森飚
 **/

@Data
public class AccountLoginRequest {

    private String phone;

    private String pwd;
}
```

#### 13.2.2AccountController

```
   /**
     * 用户登录
     * @param request
     * @return
     */
    @PostMapping("login")
    public JsonData login(@RequestBody AccountLoginRequest request) {
        JsonData jsonData = accountService.login(request);
        return jsonData;
    }
```

#### 13.2.3AccountService

```
/**
     * 用户登录
     * @param request
     * @return
     */
    JsonData login(AccountLoginRequest request); 
```

#### 13.2.4AccountServiceImpl

```
/**
     * 用户登录逻辑
     * @param request
     * @return
     */
    @Override
    public JsonData login(AccountLoginRequest request) {
        List<AccountDO> accountDOList = accountManager.findByPhone(request.getPhone());
        if (accountDOList != null && accountDOList.size() == 1) {
            AccountDO accountDO = accountDOList.get(0);
            //前端传来的密码和数据库的盐进行加密,生成密文
            String md5Crypt = Md5Crypt.md5Crypt(request.getPwd().getBytes(), accountDO.getSecret());
            if (md5Crypt.equalsIgnoreCase(accountDO.getPwd())) {
                LoginUser loginUser = LoginUser.builder().build();
                BeanUtils.copyProperties(accountDO,loginUser);
                //生成TOKEN
                String token = JWTUtil.geneJsonWebTokne(loginUser);
                return JsonData.buildSuccess(token);
            }else {
                return JsonData.buildResult(BizCodeEnum.ACCOUNT_PWD_ERROR);
            }
        }else {
            return JsonData.buildResult(BizCodeEnum.ACCOUNT_UNREGISTER);
        }
    }
```

#### 13.2.5AccountManager

```
package net.xdclass.manager;

import net.xdclass.model.AccountDO;

import java.util.List;

public interface AccountManager {

    int insert(AccountDO accountDO);

    List<AccountDO> findByPhone(String phone);
}
```

#### 13.2.6AccountManagerImpl

```
@Override
    public List<AccountDO> findByPhone(String phone) {

        List<AccountDO> accountDOList = accountMapper.selectList
                (new QueryWrapper<AccountDO>().eq("phone", phone));

        return accountDOList;
    }
```

#### 13.2.7LoginUser

- common/model/LoginUser

```
package net.xdclass.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @Description
 * @Author 刘森飚
 **/

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class LoginUser {

    /**
     * 账号
     */
    private long accountNo;

    /**
     * 用户名
     */
    private String username;

    /**
     * 头像
     */
    private String headImg;

    /**
     * 邮箱
     */
    private String mail;

    /**
     * 手机号
     */
    private String phone;

    /**
     * 认证级别
     */
    private String auth;
}
```

#### 13.2.8JWTUtil

- common/util/JWTUtil

```
package net.xdclass.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.model.LoginUser;

import java.util.Date;

/**
 * @Description
 * @Author 刘森飚
 **/
@Slf4j
public class JWTUtil {


    /**
     * 主题
     */
    private static final String SUBJECT = "liusenbiao";

    /**
     * 加密密钥
     */
    private static final String SECRET = "Liu19971009";

    /**
     * 令牌前缀
     */
    private static final String TOKNE_PREFIX = "dcloud-link";


    /**
     * token过期时间，7天
     */
    private static final long EXPIRED = 1000 * 60 * 60 * 24 * 7;


    /**
     * 生成token
     * @param loginUser
     * @return
     */
    public static String geneJsonWebTokne(LoginUser loginUser) {

        if (loginUser == null) {
            throw new NullPointerException("对象为空");
        }

        String token = Jwts.builder().setSubject(SUBJECT)
                //配置payload
                .claim("head_img", loginUser.getHeadImg())
                .claim("account_no", loginUser.getAccountNo())
                .claim("username", loginUser.getUsername())
                .claim("mail", loginUser.getMail())
                .claim("phone", loginUser.getPhone())
                .claim("auth", loginUser.getAuth())
                .setIssuedAt(new Date())
                .setExpiration(new Date(CommonUtil.getCurrentTimestamp() + EXPIRED))
                .signWith(SignatureAlgorithm.HS256, SECRET).compact();

        token = TOKNE_PREFIX + token;
        return token;
    }


    /**
     * 解密jwt
     * @param token
     * @return
     */
    public static Claims checkJWT(String token) {

        try {
            final Claims claims = Jwts.parser().setSigningKey(SECRET)
                    .parseClaimsJws(token.replace(TOKNE_PREFIX, "")).getBody();
            return claims;
        } catch (Exception e) {

            log.error("jwt 解密失败");
            return null;
        }

    }
}
```

- 登录接口json数据

```
{
    "phone":"15861364032",
    "pwd":"123456"
}
```

![1673786636363](短链平台项目.assets/1673786636363.png)

### 13.3JWT应用

#### 13.3.1什么是JWT

```
JWT 是⼀个开放标准，它定义了⼀种⽤于简洁，⾃包含的⽤于通信双⽅之间以 JSON 对象的形式安全传递信息的⽅法。 可以使⽤ HMAC 算法或者是 RSA 的公钥密钥对进⾏签名
简单来说: 就是通过⼀定规范来⽣成token，然后可以通过解密算法逆向解密token，这样就可以获取⽤户信息。


优点
⽣产的token可以包含基本信息，⽐如id、⽤户昵称、头像等信息，避免再次查库
存储在客户端，不占⽤服务端的内存资源。

缺点
token是经过base64编码，所以可以解码，因此token加密前的对象不应该包含敏感信息，如⽤户权限，密码等。
如果没有服务端存储，则不能做登录失效处理，除⾮服务端改秘钥。
```

#### 13.3.2JWT格式组成

```
头部：主要是描述签名算法。
负载：主要描述是加密对象的信息，如⽤户的id等，也可以加些规范⾥⾯的东⻄，如iss签发者，exp 过期时间，sub ⾯向的⽤户。
签名：主要是把前⾯两部分进⾏加密，防⽌别⼈拿到token进⾏base解密后篡改token。


关于jwt客户端存储
可以存储在cookie，localstorage和sessionStorage⾥⾯
```

#### 13.3.3JWT封装

##### 13.3.3.1聚合工程和common模块添加依赖

```
             <!-- JWT相关 -->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>0.7.0</version>
            </dependency>
```

##### 13.3.3.2common项目中封装token方法

```
package net.xdclass.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.model.LoginUser;

import java.util.Date;

/**
 * @Description
 * @Author 刘森飚
 **/
@Slf4j
public class JWTUtil {


    /**
     * 主题
     */
    private static final String SUBJECT = "liusenbiao";

    /**
     * 加密密钥
     */
    private static final String SECRET = "Liu19971009";

    /**
     * 令牌前缀
     */
    private static final String TOKNE_PREFIX = "dcloud-link";


    /**
     * token过期时间，7天
     */
    private static final long EXPIRED = 1000 * 60 * 60 * 24 * 7;


    /**
     * 生成token
     * @param loginUser
     * @return
     */
    public static String geneJsonWebTokne(LoginUser loginUser) {

        if (loginUser == null) {
            throw new NullPointerException("对象为空");
        }

        String token = Jwts.builder().setSubject(SUBJECT)
                //配置payload
                .claim("head_img", loginUser.getHeadImg())
                .claim("account_no", loginUser.getAccountNo())
                .claim("username", loginUser.getUsername())
                .claim("mail", loginUser.getMail())
                .claim("phone", loginUser.getPhone())
                .claim("auth", loginUser.getAuth())
                .setIssuedAt(new Date())
                .setExpiration(new Date(CommonUtil.getCurrentTimestamp() + EXPIRED))
                .signWith(SignatureAlgorithm.HS256, SECRET).compact();

        token = TOKNE_PREFIX + token;
        return token;
    }


    /**
     * 解密jwt
     * @param token
     * @return
     */
    public static Claims checkJWT(String token) {

        try {
            final Claims claims = Jwts.parser().setSigningKey(SECRET)
                    .parseClaimsJws(token.replace(TOKNE_PREFIX, "")).getBody();
            return claims;
        } catch (Exception e) {

            log.error("jwt 解密失败");
            return null;
        }

    }
}
```

##### 13.3.3.3登录整合

```
   /**
     * 用户登录逻辑
     * @param request
     * @return
     */
    @Override
    public JsonData login(AccountLoginRequest request) {
        List<AccountDO> accountDOList = accountManager.findByPhone(request.getPhone());
        if (accountDOList != null && accountDOList.size() == 1) {
            AccountDO accountDO = accountDOList.get(0);
            //前端传来的密码和数据库的盐进行加密,生成密文
            String md5Crypt = Md5Crypt.md5Crypt(request.getPwd().getBytes(), accountDO.getSecret());
            if (md5Crypt.equalsIgnoreCase(accountDO.getPwd())) {
                LoginUser loginUser = LoginUser.builder().build();
                BeanUtils.copyProperties(accountDO,loginUser);
                //生成TOKEN
                String token = JWTUtil.geneJsonWebTokne(loginUser);
                return JsonData.buildSuccess(token);
            }else {
                return JsonData.buildResult(BizCodeEnum.ACCOUNT_PWD_ERROR);
            }
        }else {
            return JsonData.buildResult(BizCodeEnum.ACCOUNT_UNREGISTER);
        }
    }
```

### 13.4开发登录拦截器

- common/interceptor/LoginInterceptor

```
package net.xdclass.interceptor;

import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.model.LoginUser;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JWTUtil;
import net.xdclass.util.JsonData;
import org.apache.commons.lang3.StringUtils;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Slf4j
public class LoginInterceptor implements HandlerInterceptor {

    public static ThreadLocal<LoginUser> threadLocal = new ThreadLocal<>();

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        //options请求都放行
        if (HttpMethod.OPTIONS.toString().equalsIgnoreCase(request.getMethod())) {
            response.setStatus(HttpStatus.NO_CONTENT.value());
            return true;
        }
        String accessToken = request.getHeader("token");
        if (StringUtils.isBlank(accessToken)) {
            accessToken = request.getParameter("token");
        }

        if (StringUtils.isNotBlank(accessToken)) {
            //解密
            Claims claims = JWTUtil.checkJWT(accessToken);
            if (claims == null) {
                //未登录
                CommonUtil.sendJsonMessage(response,JsonData.buildResult(BizCodeEnum.ACCOUNT_UNLOGIN));
            }
            Long accountNo = Long.parseLong(claims.get("account_no").toString());
            String headImg = (String) claims.get("head_img");
            String username = (String) claims.get("username");
            String mail = (String) claims.get("mail");
            String phone = (String) claims.get("phone");
            String auth = (String) claims.get("auth");

            LoginUser loginUser = LoginUser.builder()
                    .accountNo(accountNo)
                    .auth(auth)
                    .phone(phone)
                    .headImg(headImg)
                    .mail(mail)
                    .username(username)
                    .build();

            threadLocal.set(loginUser);
            return true;
        }
        CommonUtil.sendJsonMessage(response,JsonData.buildResult(BizCodeEnum.ACCOUNT_UNLOGIN));
        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

        //防止内存泄漏
        threadLocal.remove();
    }
}
```

### 13.5放行路径开发配置

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Slf4j
public class InterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(new LoginInterceptor())
                //添加拦截的路径
                .addPathPatterns("/api/account/*/**", "/api/traffic/*/**")

                //排除不拦截
                .excludePathPatterns(
                        "/api/account/*/register","/api/account/*/upload","/api/account/*/login",
                        "/api/notify/v1/captcha","/api/notify/*/send_code");
    }
}
```

## 14.海量数据下分库分表

### 14.1数据库相关面试题

- 这边有个数据库单表1千万数据，未来1年还会增长多500万，性能比较慢，说下你的优化思路

```
千万不要⼀上来就说分库分表，这个是最忌讳的事项
⼀定要根据实际情况分析，两个⻆度思考
不分库分表

软优化
数据库参数调优
分析慢查询SQL语句，分析执⾏计划，进⾏sql改写
和程序改写
优化数据库索引结构
优化数据表结构优化
引⼊NOSQL和程序架构调整


硬优化
提升系统硬件（更快的IO、更多的内存）：带宽、CPU、硬盘


分库分表
根据业务情况⽽定，选择合适的分库分表策略（没有通⽤的策略）
外卖、物流、电商领域
先看只分表是否满⾜业务的需求和未来增⻓
数据库分表能够解决单表数据ᰁ很⼤的时,数据查询的效率问题，
⽆法给数据库的并发操作带来效率上的提⾼，分表的实质还是在⼀个数据库上进⾏的操作，受数据库IO性能的限制
如果单分表满⾜不了需求，再分库分表⼀起


结论
在数据库及访问压⼒不是特别⼤的情况，⾸先考虑缓存、读写分离、索引技术等⽅案
如果数据库极⼤，且业务持续增⻓快，再考虑分库分表⽅案
```

### 14.2分库分表

#### 14.2.1垂直分表

- 需求

```
商品表字段太多，每个字段访问频次不⼀样，浪费了IO资源，需要进⾏优化。
```

- 垂直分表介绍

```
也就是“⼤表拆⼩表”，基于列字段进⾏的。
拆分原则⼀般是表中的字段较多，将不常⽤的或者数据较⼤，⻓度较⻓的拆分到“扩展表 如text类型字段。
访问频次低、字段⼤的商品描述信息单独存放在⼀张表中;
访问频次᫾⾼的商品基本信息单独放在⼀张表中。
```

- 垂直拆分原则

```
把不常⽤的字段单独放在⼀张表;
把text，blob等⼤字段拆分出来放在附表中;
业务经常组合查询的列放在⼀张表中
```

- 例⼦：商品详情⼀般是拆分主表和附表

```
//拆分前
CREATE TABLE `product` (
 `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
 `title` varchar(524) DEFAULT NULL COMMENT '视频标题',
 `cover_img` varchar(524) DEFAULT NULL COMMENT '封⾯图',
 `price` int(11) DEFAULT NULL COMMENT '价格,分',
 `total` int(10) DEFAULT '0' COMMENT '总库存',
 `left_num` int(10) DEFAULT '0' COMMENT '剩余',
 
 `learn_base` text COMMENT '课前须知，学习基础',
 `learn_result` text COMMENT '达到⽔平',
 `summary` varchar(1026) DEFAULT NULL COMMENT '概述', 
 `detail` text COMMENT '视频商品详情',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULTCHARSET=utf8;


//拆分后
CREATE TABLE `product` (
 `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
 `title` varchar(524) DEFAULT NULL COMMENT '视频标题',
 `cover_img` varchar(524) DEFAULT NULL COMMENT '封⾯图',
 `price` int(11) DEFAULT NULL COMMENT '价格,分',
 `total` int(10) DEFAULT '0' COMMENT '总库存',
 `left_num` int(10) DEFAULT '0' COMMENT '剩余',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULTCHARSET=utf8;

CREATE TABLE `product_detail` (
 `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
 `product_id` int(11) DEFAULT NULL COMMENT '产品主键',
 `learn_base` text COMMENT '课前须知，学习基础',
 `learn_result` text COMMENT '达到⽔平',
 `summary` varchar(1026) DEFAULT NULL COMMENT '概述', 
 `detail` text COMMENT '视频商品详情',
  PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULTCHARSET=utf8;
```

#### 14.2.2垂直分库

- 需求

```
C端项⽬⾥⾯，单个数据库的CPU、内存⻓期处于90%+的利⽤率，数据库连接经常不够，需要进⾏优化。
```

- 垂直分库讲解

```
垂直分库针对的是⼀个系统中的不同业务进⾏拆分， 数据库的连接资源⽐较宝贵且单机处理能⼒也有限。
没拆分之前全部都是落到单⼀的库上的，单库处理能⼒成为瓶颈，还有磁盘空间，内存，tps等限制。
拆分之后，避免不同库竞争同⼀个物理机的CPU、内存、⽹络IO、磁盘，所以在⾼并发场景下，垂直分库⼀定程度上能够突破IO、连接数及单机硬件资源的瓶颈。
垂直分库可以更好解决业务层⾯的耦合，业务清晰，且⽅便管理和维护。
⼀般从单体项⽬升级改造为微服务项⽬，就是垂直分库。
```

- 问题

```
垂直分库分表可以提⾼并发，但是依然没有解决单表数据量过⼤的问题。
```

#### 14.2.3水平分表

- 需求

```
当⼀张表的数据达到⼏千万时，查询⼀次所花的时间⻓，需要进⾏优化，缩短查询时间。
```

- 都是大表拆小表

```
垂直分表：表结构拆分
⽔平分表：数据拆分
```

- 水平分表

```
把⼀个表的数据分到⼀个数据库的多张表中，每个表只有这个表的部分数据。
核⼼是把⼀个⼤表，分割N个⼩表，每个表的结构是⼀样的，数据不⼀样，全部表的数据合起来就是全部数据。
针对数据ᰁ巨⼤的单张表（⽐如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表⾥⾯去。
但是这些表还是在同⼀个库中，所以单数据库操作还是有IO瓶颈，主要是解决单表数据量过⼤的问题。
减少锁表时间，没分表前，如果是DDL(create/alter/add等)语句，当需要添加⼀列的时候mysql会锁表，期间所有的读写操作只能等待。
```

#### 14.2.4水平分库

- 需求

```
高并发的项⽬中，⽔平分表后依旧在单个库上⾯，1个数据库资源瓶颈 CPU/内存/带宽等限制导致响应慢，需要进⾏优化。
```

- 水平分库

```
把同个表的数据按照⼀定规则分到不同的数据库中，数据库在不同的服务器上。
⽔平分库是把不同表拆到不同数据库中，它是对数据⾏的拆分，不影响表结构。
每个库的结构都⼀样,但每个库的数据都不⼀样，没有交集，所有库的并集就是全量数据
⽔平分库的粒度，比⽔平分表更大。
```

![1673797817351](短链平台项目.assets/1673797817351.png)

### 14.3分库分表策略介绍

#### 14.3.1根据ID范围进行分表（左闭右开）

- 规则案例

```
1~1,000,000 是 table_1
1,000,000 ~2,000,000 是 table_2
2,000,000~3,000,000 是 table_3
...更多
```

- 优点

```
id是⾃增⻓，可以⽆限增⻓。
扩容不⽤迁移数据，容易理解和维护。
常用于记录日志，签到流水等
```

- 缺点

```
⼤部分读和写都访会问新的数据，有IO瓶颈，整体资源利⽤率低。
数据倾斜严重，热点数据过于集中，部分节点有瓶颈。
```

#### 14.3.2Hash取模

- 案例规则

```
⽤户ID是整数型的，要分2库，每个库表数量4表，⼀共8张表
⽤户ID取模后，值是0到7的要平均分配到每张表

库ID = userId % 库数量 2
表ID = userId / 库数量 2 % 表数量4
```

![1673872749123](短链平台项目.assets/1673872749123.png)

- 优点

```
保证数据量均匀的分散落在不同的库、表中，可以有效的避免热点数据集中问题。
```

- 缺点

```
扩容不是很⽅便，需要数据迁移。
```

### 14.4ShardingSphere

#### 14.4.1什么是ShardingSphere

```
已于2020年4⽉16⽇成为 Apache 软件基⾦会的顶级项⽬，懂的都懂。
是⼀套开源的分布式数据库解决⽅案组成的⽣态圈，定位为Database Plus。
它由 JDBC、Proxy 和Sidecar这 3 款既能够独⽴部署，⼜⽀持混合部署配合使⽤的产品组成。



ShardingSphere-JDBC
它使⽤客户端直连数据库，以 jar 包形式提供服务⽆需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。
适⽤于任何基于 JDBC 的 ORM 框架，如：JPA,Hibernate,Mybatis,或直接使⽤JDBC。
⽀持任何第三⽅的数据库连接池，如：DBCP, C3P0,BoneCP, HikariCP等；
⽀持任意实现 JDBC 规范的数据库，⽬前⽀持 MySQL，PostgreSQL，Oracle，SQLServer 以及任何可使⽤ JDBC访问的数据库。
采⽤⽆中⼼化架构，与应⽤程序共享资源，适⽤于 Java 开发的⾼性能的轻量级OLTP应⽤。
```

![1673874804819](短链平台项目.assets/1673874804819.png)

#### 14.4.2ShardingSphere-Proxy

```
数据库代理端，提供封装了数据库⼆进制协议的服务端版本，⽤于完成对异构语⾔的⽀持。
向应⽤程序完全透明，可直接当做 MySQL/PostgreSQL。
它可以使⽤任何兼容 MySQL/PostgreSQL 协议的访问客户端（如：MySQL Command Client, MySQL Workbench,Navicat 等）操作数据。
```

![1673874897617](短链平台项目.assets/1673874897617.png)

#### 14.4.3Sharding-Jdbc算法

- 分片键 (PartitionKey)

```
⽤于分⽚的数据库字段，是将数据库(表)⽔平拆分的关键字段。
比如prouduct_order订单表，根据订单号 out_trade_no做哈希取模，则out_trade_no是分⽚键。
除了对单分⽚字段的⽀持，ShardingSphere也⽀持根据多个字段进⾏分片。
```

- 分片策略
- 行表达式分片策略 InlineShardingStrategy

```
只⽀持【单分⽚键】使⽤Groovy的表达式，提供对SQL语句中的 =和IN 的分⽚操作⽀持。
可以通过简单的配置使⽤，⽆需⾃定义分⽚算法，从⽽避免繁琐的Java代码开发。

prouduct_order_$->{user_id % 8}` 表示订单表根据 user_id模8，⽽分成8张表，表名称为`prouduct_order_0`到`prouduct_order_7。
```

- 标准分片策略StandardShardingStrategy

```
只⽀持【单分⽚键】，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分⽚算法
PreciseShardingAlgorithm 精准分⽚是必选的，⽤于处理=和IN的分⽚。
RangeShardingAlgorithm 范围分配 是可选的，⽤于处理BETWEEN AND分⽚。
如果不配置RangeShardingAlgorithm，如果SQL中⽤了BETWEEN AND语法，则将按照全库路由处理，性能下降。
```

- 复合分片策略ComplexShardingStrategy

```
⽀持【多分⽚键】，多分⽚键之间的关系复杂，由开发者⾃⼰实现，提供最⼤的灵活度。
提供对SQL语句中的=, IN和BETWEEN AND的分⽚操作⽀持。
prouduct_order_0_0、prouduct_order_0_1、prouduct_order_1_0、prouduct_order_1_1。
```

- Hint分片策略HintShardingStrategy

```
这种分⽚策略⽆需配置分⽚健，分⽚健值也不再从SQL中解析，外部⼿动指定分⽚健或分⽚库，让 SQL在指定的分库、分表中执⾏。
⽤于处理使⽤Hint⾏分⽚的场景，通过Hint⽽⾮SQL解析的⽅式分⽚的策略。
Hint策略会绕过SQL解析的，对于这些⽐较复杂的需要分⽚的查询，Hint分⽚策略性能可能会更好。
```

## 15.流量包模块

### 15.1流量包开发

#### 15.1.1需求分析

```
未来2年，短链平台累计5百万⽤户
付费流量包记录：⼀个⽤户10条/年，总量就是5千万条。
单表不超过1千万数据，需要分5张表。
进⼀步延伸，进⾏⽔平分表，⽐如 2张表、4张表、8张表、16张表。
流量包traffic表数据太多，选取可⽤流量包 会影响性能，需要降低单表数据量，进⾏⽔平分表。
分表数量：线上分8张表，本地分2张表即可
分⽚key： account_no，查询维度都是根据account_no进⾏查询。
分⽚策略：行表达式分片策略 InlineShardingStrategy。
```

#### 15.1.2新建表

- traffic_0


- traffic_1

```
CREATE TABLE `traffic_0` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `day_limit` int DEFAULT NULL COMMENT '每天限制多少条，短链',
  `day_used` int DEFAULT NULL COMMENT '当天用了多少条，短链',
  `total_limit` int DEFAULT NULL COMMENT '总次数，活码才用',
  `account_no` bigint DEFAULT NULL COMMENT '账号',
  `out_trade_no` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '订单号',
  `level` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '产品层级：FIRST青铜、SECOND黄金、THIRD钻石',
  `expired_date` date DEFAULT NULL COMMENT '过期日期',
  `plugin_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '插件类型',
  `product_id` bigint DEFAULT NULL COMMENT '商品主键',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_trade_no` (`out_trade_no`,`account_no`) USING BTREE,
  KEY `idx_account_no` (`account_no`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

![1673879681653](短链平台项目.assets/1673879681653.png)

#### 15.1.3配置application.yml

- 加入sharding-jdbc依赖包，account项目注释下⾯的依赖排除

**聚合pom.xml加入依赖**

```
<!--https://mvnrepository.com/artifact/org.apache.shardingsphere/sharding-jdbc-spring-boot-starter-->
            <dependency>
                <groupId>org.apache.shardingsphere</groupId>
                <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
                <version>4.1.1</version>
            </dependency>
```

**account下pom.xml**

```
<dependency>
            <groupId>net.xdclass</groupId>
            <artifactId>dcloud-common</artifactId>
            <version>1.0-SNAPSHOT</version>
            <!--因为引入shardingsphere启动这个account的微服务会报数据源错误
            故需要排除-->
            <!--<exclusions>-->
                <!--<exclusion>-->
                    <!--<groupId>org.apache.shardingsphere</groupId>-->
                    <!--<artifactId>sharding-jdbc-spring-boot-starter</artifactId>-->
                <!--</exclusion>-->
            <!--</exclusions>-->
        </dependency>
```

- 配置文件 (注释之前jdbc单库配置)

```
server:
  port: 8001


#应用名称
spring:
  application:
    name: dcloud-account

#服务注册发现
  cloud:
    nacos:
      discovery:
        server-addr: 101.200.159.132:8848
        username: nacos
        password: nacos

##数据库配置
#  datasource:
#    driver-class-name: com.mysql.cj.jdbc.Driver
#    url: jdbc:mysql://101.200.159.132:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
#    username: root
#    password: Liu19971009


  #在这一行添加
  # 数据源 ds0 第一个数据库
  shardingsphere:
    datasource:
      #数据源名称
      names: ds0
      ds0:
        connectionTimeoutMilliseconds: 30000
        driver-class-name: com.mysql.cj.jdbc.Driver
        idleTimeoutMilliseconds: 60000
        jdbc-url: jdbc:mysql://101.200.159.132:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
        maintenanceIntervalMilliseconds: 30000
        maxLifetimeMilliseconds: 1800000
        maxPoolSize: 50
        minPoolSize: 50
        password: Liu19971009
        type: com.zaxxer.hikari.HikariDataSource
        username: root

    props:
      # 打印执行的数据库以及语句
      sql:
        show: true

    sharding:
      tables:
        traffic:
          # 指定traffic表的数据分布情况，配置数据节点,行表达式标识符使用 ${...} 或 $->{...}，但前者与 Spring 本身的文件占位符冲突，所以在 Spring 环境中建议使用 $->{...}
          actual-data-nodes: ds0.traffic_$->{0..1}
          #水平分表策略+行表达式分片
          table-strategy:
            inline:
              algorithm-expression: traffic_$->{ account_no % 2 }
              sharding-column: account_no

#redis配置
  redis:
    client-type: jedis
    host: 101.200.159.132
    password: Liu19971009
    port: 6379
    jedis:
      pool:
        # 连接池最大连接数（使用负值表示没有限制）
        max-active: 100
        # 连接池中的最大空闲连接
        max-idle: 100
        # 连接池中的最小空闲连接
        min-idle: 100
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: 60000

##配置plus打印sql日志
#mybatis-plus:
#  configuration:
#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

#----------sms短信配置--------------
sms:
  app-code: e5d8caac8369401b91462f8f1c6e4c58
  template-id: M105EABDEC


aliyun:
  oss:
    endpoint: oss-cn-hangzhou.aliyuncs.com
    access-key-id: LTAI5tHjCyZXXsqXqPzMtBvu
    access-key-secret: I4Jhw3NTmz7H7DJXHmzafT2CTE7ZkM
    bucketname: dcloud-link-liu
```

#### 15.1.4水平分表配置

```
#水平分表策略+行表达式分片
          table-strategy:
            inline:
              algorithm-expression: traffic_$->{ account_no % 2 }
              sharding-column: account_no
```

#### 15.1.5单元测试

- account/test/biz/TrafficTest

```
package net.xdclass.biz;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.AccountApplication;
import net.xdclass.mapper.TrafficMapper;
import net.xdclass.model.TrafficDO;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.Random;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = AccountApplication.class)
@Slf4j
public class TrafficTest {

    @Autowired
    private TrafficMapper trafficMapper;

    @Test
    public void testSendSms() {
        Random random = new Random();
        for (int i = 0; i < 10; i++) {
            TrafficDO trafficDO = new TrafficDO();
            trafficDO.setAccountNo(Long.valueOf(random.nextInt(100)));
            trafficMapper.insert(trafficDO);
        }

    }
}
```

![1673883042444](短链平台项目.assets/1673883042444.png)

**traffic_0**

![1673883107859](短链平台项目.assets/1673883107859.png)

**traffic_1**

![1673883169177](短链平台项目.assets/1673883169177.png)

- 问题

主键id重复

### 15.2ID冲突解决方案

```
单库下⼀般使⽤Mysql⾃增ID, 但是分库分表后，会造成不同分⽚上的数据表主键会重复。
```

- 需求

```
性能强劲
全局唯⼀
防⽌恶意⽤户根据id的规则来获取数据
```

- 业界常⽤ID解决⽅案
- 方案一

```
数据库⾃增ID
利⽤⾃增id, 设置不同的⾃增步⻓，
auto_increment_offset、auto-increment-increment

DB1: 单数
//从1开始、每次加2
DB2: 偶数
//从2开始，每次加2


缺点
依靠数据库系统的功能实现，但是未来扩容麻烦。
主从切换时的不⼀致可能会导致重复发号。
性能瓶颈存在单台sql上。
```

- 方案二

```
UUID
性能⾮常⾼，没有⽹络消耗。
缺点
⽆序的字符串，不具备趋势⾃增特性。
UUID太⻓，不易于存储，浪费存储空间，很多场景不适⽤。
```

- 方案三

```
Redis发号器
利⽤Redis的INCR和INCRBY来实现，原⼦操作，线程安全，性能⽐Mysql强劲。

缺点
需要占⽤⽹络资源，增加系统复杂度
```

- 方案四

```
Snowflake雪花算法
twitter开源的分布式 ID ⽣成算法，代码实现简单、不占⽤宽带、数据迁移不受影响。
⽣成的id中包含有时间戳，所以⽣成的id按照时间递增。
部署了多台服务器，需要保证系统时间⼀样，机器编号不⼀样。
缺点
依赖系统时钟（多台服务器时间⼀定要⼀样）。
```

### 15.3雪花算法

#### 15.3.1snowflake介绍

![1673931288041](短链平台项目.assets/1673931288041.png)

#### 15.3.2snowflake配置

- 使⽤Sharding-Jdbc配置⽂件,注释DO类⾥⾯的id分配策略

![1673932931266](短链平台项目.assets/1673932931266.png)

- account/application.yml

```
    sharding:
      tables:
        traffic:
          # 指定traffic表的数据分布情况，配置数据节点,行表达式标识符使用 ${...} 或 $->{...}，但前者与 Spring 本身的文件占位符冲突，所以在 Spring 环境中建议使用 $->{...}
          actual-data-nodes: ds0.traffic_$->{0..1}
          #水平分表策略+行表达式分片
          table-strategy:
            inline:
              algorithm-expression: traffic_$->{ account_no % 2 }
              sharding-column: account_no
          #id生成策略,这一行添加雪花算法
          key-generator:
            column: id
            props:
              worker:
                id: ${workId}
            #id生成策略
            type: SNOWFLAKE
```

#### 15.3.3Snowflake自定义wrokId

```
动态指定sharding jdbc的雪花算法中的属性work.id属性
使⽤sharding-jdbc中的使⽤IP后⼏位来做workId, 但在某些情况下会出现⽣成重复ID的情况


解决办法时
在启动时给每个服务分配不同的workId, 引⼊redis/zk都⾏，缺点就是多了依赖。
启动程序的时候，通过JVM参数去控制，覆盖变量。
```

- common/config/SnowFlakeWordIdConfig

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.UnknownHostException;

/**
 * @Description
 * @Author:刘森飚
 **/    

@Configuration
@Slf4j
public class SnowFlakeWordIdConfig {


    /**
     * 动态指定sharding jdbc 的雪花算法中的属性work.id属性
     * 通过调用System.setProperty()的方式实现,可用容器的 id 或者机器标识位
     * workId最大值 1L << 100，就是1024，即 0<= workId < 1024
     * {@link SnowflakeShardingKeyGenerator#getWorkerId()}
     *
     */
    static {

        try {
            InetAddress inetAddress = Inet4Address.getLocalHost();

            String hostAddressIp = inetAddress.getHostAddress();

            String workId = Math.abs(hostAddressIp.hashCode()) % 1024+"";

            System.setProperty("workId",workId);

            log.info("workId:{}",workId);

        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
```

- account/application.yml

```
server:
  port: 8001


#应用名称
spring:
  application:
    name: dcloud-account

#服务注册发现
  cloud:
    nacos:
      discovery:
        server-addr: 101.200.159.132:8848
        username: nacos
        password: nacos

##数据库配置
#  datasource:
#    driver-class-name: com.mysql.cj.jdbc.Driver
#    url: jdbc:mysql://101.200.159.132:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
#    username: root
#    password: Liu19971009



  # 数据源 ds0 第一个数据库
  shardingsphere:
    datasource:
      #数据源名称
      names: ds0
      ds0:
        connectionTimeoutMilliseconds: 30000
        driver-class-name: com.mysql.cj.jdbc.Driver
        idleTimeoutMilliseconds: 60000
        jdbc-url: jdbc:mysql://101.200.159.132:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
        maintenanceIntervalMilliseconds: 30000
        maxLifetimeMilliseconds: 1800000
        maxPoolSize: 50
        minPoolSize: 50
        password: Liu19971009
        type: com.zaxxer.hikari.HikariDataSource
        username: root

    props:
      # 打印执行的数据库以及语句
      sql:
        show: true

    sharding:
      tables:
        traffic:
          # 指定traffic表的数据分布情况，配置数据节点,行表达式标识符使用 ${...} 或 $->{...}，但前者与 Spring 本身的文件占位符冲突，所以在 Spring 环境中建议使用 $->{...}
          actual-data-nodes: ds0.traffic_$->{0..1}
          #水平分表策略+行表达式分片
          table-strategy:
            inline:
              algorithm-expression: traffic_$->{ account_no % 2 }
              sharding-column: account_no
          #id生成策略
          key-generator:
            column: id
            props:
              worker:
                id: ${workId}
            #id生成策略
            type: SNOWFLAKE
#redis配置
  redis:
    client-type: jedis
    host: 101.200.159.132
    password: Liu19971009
    port: 6379
    jedis:
      pool:
        # 连接池最大连接数（使用负值表示没有限制）
        max-active: 100
        # 连接池中的最大空闲连接
        max-idle: 100
        # 连接池中的最小空闲连接
        min-idle: 100
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: 60000

##配置plus打印sql日志
#mybatis-plus:
#  configuration:
#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

#----------sms短信配置--------------
sms:
  app-code: e5d8caac8369401b91462f8f1c6e4c58
  template-id: M105EABDEC


aliyun:
  oss:
    endpoint: oss-cn-hangzhou.aliyuncs.com
    access-key-id: LTAI5tHjCyZXXsqXqPzMtBvu
    access-key-secret: I4Jhw3NTmz7H7DJXHmzafT2CTE7ZkM
    bucketname: dcloud-link-liu
```

![1673935923038](短链平台项目.assets/1673935923038.png)

#### 15.3.4封装ID生成器

- 需求

```
⽤户注册-⽣成的account_no需要是long类型，且全局唯⼀
```

- 利⽤Sharding-Jdbc封装id⽣成器

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.UnknownHostException;

/**
 * @Description
 * @Author:刘森飚
 **/

@Configuration
@Slf4j
public class SnowFlakeWordIdConfig {


    /**
     * 动态指定sharding jdbc 的雪花算法中的属性work.id属性
     * 通过调用System.setProperty()的方式实现,可用容器的 id 或者机器标识位
     * workId最大值 1L << 100，就是1024，即 0<= workId < 1024
     * {@link SnowflakeShardingKeyGenerator#getWorkerId()}
     *
     */
    static {

        try {
            InetAddress inetAddress = Inet4Address.getLocalHost();

            String hostAddressIp = inetAddress.getHostAddress();

            String workId = Math.abs(hostAddressIp.hashCode()) % 1024+"";

            System.setProperty("workId",workId);

            log.info("workId:{}",workId);

        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
```

- account/AccountServiceImpl

```
 public JsonData register(AccountRegisterRequest registerRequest) {
 .....
         //生成唯一的账号       accountDO.setAccountNo(Long.valueOf(IDUtil.geneSnowFlakeID().toString()));
 .....
 }
```

## 16.短链服务

### 16.1短链的生命周期

![1673961362411](短链平台项目.assets/1673961362411.png)

### 16.2短链接口

- 流量包管理

```
免费流量包
付费流量包
```

![1673961511445](短链平台项目.assets/1673961511445.png)

- 分组管理

```
新增分组
删除分组
修改分组
查看分组下的短链
```

![1673961579585](短链平台项目.assets/1673961579585.png)

- 短链管理
- 创建短链

```
⽬标地址
短链标题
短链域名
所属分组
有效期
```

![1673961727024](短链平台项目.assets/1673961727024.png)

- 删除短链
- 修改短链
- 查看短链

```
访问PV、UV
地域分布
时间分布
来源分布
```

- 访问者

```
访问短链
跳转⽬标站点
```

### 16.3短链服务相关问题

- 问题⼀：⻓链的关系和短链的关系是⼀对⼀还是⼀对多？

```
⼀个⻓链，在不同情况下，⽣成的短⽹址应该不⼀样，才不会造成冲突。
多渠道推⼴下，也可以区分统计不同渠道的效果质量。
所以是 ⼀个短链接只能对应⼀个⻓链接，当然⼀个⻓链接可以对应多个短链接。
```

- 问题⼆：前端访问短链是如何跳转到对应的⻚⾯的？

```
服务端转发

由服务器端进⾏的⻚⾯跳转，刚学Servlet时， 从OneServlet中转发到TwoServlet。
地址栏不发⽣变化，显示的是上⼀个⻚⾯的地址。
请求次数：只有1次请求
转发只能在同⼀个应⽤的组件之间进⾏，不可以转发给其他应⽤的地址。
```

![1673963528179](短链平台项目.assets/1673963528179.png)

- 页面的跳转-重定向

```
由浏览器端进⾏的⻚⾯跳转

重定向涉及到3xx状态码，访问跳转是301还是302，301和302代表啥意思？
301 是永久重定向
会被浏览器硬缓存，第⼀次会经过短链服务，后续再访问直接从浏览器缓存中获取⽬标地址。

302 是临时重定向
不会被浏览器硬缓存，每次都是会访问短链服务短地址⼀经⽣成就不会变化，所以⽤ 301 是同时对服务器压⼒也会有⼀定减少。
但是如果使⽤了301，⽆法统计到短地址被点击的次数。
所以选择302虽然会增加服务器压⼒，但是有很多数据可以获取进⾏分析。
选择使⽤302，这个也可以对违规推⼴的链接进⾏实时封禁。
```

![1673963771460](短链平台项目.assets/1673963771460.png)

- 问题三：短链码如何是如何⽣成的


- 短链码特点

```
⽣成性能强劲
碰撞概率低
避免重复
恶意猜测
业务规则安全
```

![1673964997571](短链平台项目.assets/1673964997571.png)

- ⽅式


- ⾃增ID

```
利⽤插⼊数据库，利⽤数据库⾃增id
把⾃增id转成62进制作为短链码
短链码的⻓度不固定，随着 id 变⼤，短链码⻓度也增⻓
可以指定从某个⻓度开始增⻓，到百亿、千亿数量
转换⼯具：https://tool.lu/hexconvert/
是否存在量复: 不量复
但短链码是有序的递增，存在【业务数据安全】问题
```

- MD5内容压缩

```
⻓链接做md5加密
加密串查询是否已经⽣成过短链接
如果已经存在，则拼接时间戳再MD5加密，插⼊数据库
如果不存在则把⻓链接、⻓链接加密串插⼊数据库

取MD5后 最后1个8 位字符串作为短链码
是否存在重复: 存在碰撞（重复）可能
是有损压缩算法，数据量超⼤情况碰撞概念越⼤
⽐如 【⽼王的⼥友】有300多个，每再多1个，再同⼀天⽣⽇的概率越⼤，就更加复杂
```

- MurMurHash(最终采用)

```
是⼀种【⾮加密型】哈希函数且【随机分布】特征表现更良好。
由于是⾮加密的哈希函数，性能会⽐MD5强。
再很多地⽅都⽤到⽐如Guava、Jedis、HBase、Lucence等。

存在两个版本
MurmurHash2（产⽣32位或64位值）
MurmurHash3（产⽣32位或128位值）

数据量
MurmurHash的 32 bit 能表示的最⼤值近 43 亿的10进制
满⾜多数业务,如果接近43亿则冲突概率⼤

MurMurHash得到的数值是10进制，⼀般会转化为62进制进⾏缩短
例⼦
10进制：1813342104
转62进制：1YIB7i
https://tool.lu/hexconvert/
常规短链码是6~8位数字+⼤⼩写字⺟组合


MurmurHash的 32 bit 满⾜多数业务 43亿
拼接上库-表位则可以表示更多数据
7位则可以到到 43亿 * 62 = 2666亿
8位则可以到到 2666亿 * 62 = 1.65万亿条数据
结合短链过期数据归档，理论上满⾜未来全部需求了
数据库存储
单表1千万 * 62个库 * 62表 = 384亿数据
```

### 16.4Murmur哈希算法封装

#### 16.4.1单元测试

```
package net.xdclass.biz;


import com.google.common.hash.Hashing;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.util.CommonUtil;
import org.junit.Test;

@Slf4j
public class ShortLinkTest {

    @Test
    public void testMurmurHash() {
        for (int i = 0; i < 5; i++) {
            String originalUrl = "https://xdclass.net?id="+
                    CommonUtil.generateUUID()+"pwd="+CommonUtil.getStringNumRandom(7);
            long murmur3_32 = Hashing.murmur3_32().hashUnencodedChars(originalUrl).padToLong();
            log.info("murmur3_32={}",murmur3_32);
        }
    }
}
```

![1673968695042](短链平台项目.assets/1673968695042.png)

#### 16.4.2CommonUtil工具类

```
/**
 * murmurhash算法
 * @param param
 * @return
 */
public static long murmurHash32(String param){
    long murmurHash32 = Hashing.murmur3_32().hashUnencodedChars(param).padToLong();
    return murmurHash32;
}
```

### 16.5ShortLinkComponent封装

#### 16.5.1ShortLinkComponent

```
package net.xdclass.component;

import net.xdclass.util.CommonUtil;
import org.springframework.stereotype.Component;

/**
 * @Author 刘森飚
 * @Version 1.0
 **/

@Component
public class ShortLinkComponent {

    /**
     * 62个字符
     */
    private static final String CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";


    /**
     * 生成短链码
     * @param param
     * @return
     */
    public String createShortLinkCode(String param){

        long murmurhash = CommonUtil.murmurHash32(param);
        //进制转换
        String code = encodeToBase62(murmurhash);

        return code;
    }

    /**
     * 10进制转62进制
     * @param num
     * @return
     */
    private String encodeToBase62(long num){

        // StringBuffer线程安全，StringBuilder线程不安全
        StringBuffer sb = new StringBuffer();
        do{
            int i = (int )(num%62);
            sb.append(CHARS.charAt(i));
            num = num/62;
        }while (num>0);

        String value = sb.reverse().toString();
        return value;

    }
}
```

#### 16.5.2单元测试

```
package net.xdclass.biz;

import com.google.common.hash.Hashing;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.LinkApplication;
import net.xdclass.component.ShortLinkComponent;
import net.xdclass.util.CommonUtil;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.Random;

/**
 * @Description
 * @Author：刘森飚
 **/

@RunWith(SpringRunner.class)
@SpringBootTest(classes = LinkApplication.class)
@Slf4j
public class ShortLinkTest {

    @Autowired
    private ShortLinkComponent shortLinkComponent;

    @Test
    public void testMurmurHash(){

        for(int i=0; i<5; i++){
            String originalUrl = "https://xdclass.net?id="
                    +CommonUtil.generateUUID()+"pwd="+CommonUtil.getStringNumRandom(7);
            long murmur3_32 = Hashing.murmur3_32().hashUnencodedChars(originalUrl).padToLong();
            log.info("murmur3_32={}",murmur3_32);

        }

    }


    /**
     * 测试短链平台
     */
    @Test
    public void testCreateShortLink() {

        Random random = new Random();
        for (int i = 0; i < 10; i++) {
            int num1 = random.nextInt(10);
            int num2 = random.nextInt(10000000);
            int num3 = random.nextInt(10000000);
            String originalUrl = num1 + "xdclass" + num2 + ".net" + num3;
            String shortLinkCode = shortLinkComponent.createShortLinkCode(originalUrl);
            log.info("originalUrl:" + originalUrl + ", shortLinkCode=" + shortLinkCode);
        }
    }
}
```

#### 16.5.3LinkApplication

```
package net.xdclass;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.transaction.annotation.EnableTransactionManagement;

/**
 * @Description
 * @Author 刘森飚
 **/

@MapperScan("net.xdclass.mapper")
@EnableTransactionManagement
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class LinkApplication {

    public static void main(String[] args) {
        SpringApplication.run(LinkApplication.class, args);
    }

}
```

#### 16.5.4application.yml

```
server:
  port: 8003


#应用名称
spring:
  application:
    name: dcloud-link

  #服务注册发现
  cloud:
    nacos:
      discovery:
        server-addr: 101.200.159.132:8848
        username: nacos
        password: nacos


  # 数据源 ds0 第一个数据库
  shardingsphere:
    datasource:
      #数据源名称
      names: ds0
      ds0:
        connectionTimeoutMilliseconds: 30000
        driver-class-name: com.mysql.cj.jdbc.Driver
        idleTimeoutMilliseconds: 60000
        jdbc-url: jdbc:mysql://101.200.159.132:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
        maintenanceIntervalMilliseconds: 30000
        maxLifetimeMilliseconds: 1800000
        maxPoolSize: 50
        minPoolSize: 50
        password: xdclass.net168
        type: com.zaxxer.hikari.HikariDataSource
        username: root

    props:
      # 打印执行的数据库以及语句
      sql:
        show: true


#配置plus打印sql日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

- 为什么要⽤62进制转换,不是64进制

```
62进制转换是因为62进制转换后只含数字+⼩写+⼤写字⺟。
⽽64进制转换会含有/、+这样的符号（不符合正常URL的字符)。
10进制转62进制可以缩短字符，如果我们要6位字符的话，已经有560亿个组合了。
```

### 16.6创建数据库

![1674039388084](短链平台项目.assets/1674039388084.png)

- 短链-分组

```
CREATE TABLE `link_group` (
  `id` bigint unsigned NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '组名',
  `account_no` bigint DEFAULT NULL COMMENT '账号唯一编号',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

- 短链

```
CREATE TABLE `short_link` (
  `id` bigint unsigned NOT NULL,
  `group_id` bigint DEFAULT NULL COMMENT '组',
  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '短链标题',
  `original_url` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '原始url地址',
  `domain` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '短链域名',
  `code` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '短链压缩码',
  `sign` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '长链的md5码，方便查找',
  `expired` datetime DEFAULT NULL COMMENT '过期时间，长久就是-1',
  `account_no` bigint DEFAULT NULL COMMENT '账号唯一编号',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `del` int unsigned NOT NULL COMMENT '0是默认，1是删除',
  `state` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '状态，lock是锁定不可用，active是可用',
  `link_type` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '链接产品层级：FIRST 免费青铜、SECOND黄金、THIRD钻石',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_code` (`code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

### 16.7 MybatisPlus逆向生成java对象

```
package net.xdclass.db;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;


public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();
        // 是否支持AR模式
        config.setActiveRecord(true)
                // 作者
                .setAuthor("刘森飚")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("C:\\Users\\18053\\Desktop")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")

                //生成基本的resultMap
                .setBaseResultMap(true)

                //实体类结尾名称
                .setEntityName("%sDO")
                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://101.200.159.132:3306/dcloud_link?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai")
                .setUsername("root")
                .setPassword("Liu19971009");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("link_group","short_link");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("=======  相关代码生成完毕  ========");
    }
}
```

**LinkGroupDO和ShortLinkDO注释掉@TableId改用雪花算法**

![1674041064558](短链平台项目.assets/1674041064558.png)

### 16.8yml转properties

在线转换⼯具：https://www.toyaml.com

#### 16.8.1account/application.properties

```
server.port=8001
spring.application.name=dcloud-account

#----------服务注册和发现--------------
spring.cloud.nacos.discovery.server-addr=101.200.159.132:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos

#-------redis连接配置-------
spring.redis.client-type=jedis
spring.redis.host=101.200.159.132
spring.redis.password=Liu19971009
spring.redis.port=6379
spring.redis.jedis.pool.max-active=100
spring.redis.jedis.pool.max-idle=100
spring.redis.jedis.pool.min-idle=100
spring.redis.jedis.pool.max-wait=60000


#-------分库分表数据源配置-------
spring.shardingsphere.datasource.names=ds0
spring.shardingsphere.datasource.ds0.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds0.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_account?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds0.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds0.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds0.maxPoolSize=50
spring.shardingsphere.datasource.ds0.minPoolSize=50
spring.shardingsphere.datasource.ds0.password=Liu19971009
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.props.sql.show=true


# 指定traffic表的数据分布情况，配置数据节点,行表达式标识符使用 ${...} 或 $->{...}，但前者与 Spring 本身的文件占位符冲突，所以在 Spring 环境中建议使用 $->{...}
spring.shardingsphere.sharding.tables.traffic.actual-data-nodes=ds0.traffic_$->{0..1}
#水平分表策略+行表达式分片
spring.shardingsphere.sharding.tables.traffic.table-strategy.inline.algorithm-expression=traffic_$->{ account_no % 2 }
spring.shardingsphere.sharding.tables.traffic.table-strategy.inline.sharding-column=account_no

#id生成策略
spring.shardingsphere.sharding.tables.traffic.key-generator.column=id
spring.shardingsphere.sharding.tables.traffic.key-generator.props.worker.id=${workId}
spring.shardingsphere.sharding.tables.traffic.key-generator.type=SNOWFLAKE

#----------sms短信配置--------------
sms.app-code=e5d8caac8369401b91462f8f1c6e4c58
sms.template-id=M105EABDEC

#----------阿里云OSS配置--------------
aliyun.oss.endpoint=oss-cn-hangzhou.aliyuncs.com
aliyun.oss.access-key-id=LTAI5tHjCyZXXsqXqPzMtBvu
aliyun.oss.access-key-secret=I4Jhw3NTmz7H7DJXHmzafT2CTE7ZkM
aliyun.oss.bucketname=dcloud-link-liu
```

#### 16.8.2link/application.properties

```
server.port=8003
spring.application.name=dcloud-link

#服务注册发现
spring.cloud.nacos.discovery.server-addr=101.200.159.132:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos

#分库分表配置
spring.shardingsphere.datasource.names=ds0
spring.shardingsphere.datasource.ds0.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds0.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource

spring.shardingsphere.datasource.ds0.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds0.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds0.maxPoolSize=50
spring.shardingsphere.datasource.ds0.minPoolSize=50
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.datasource.ds0.password=Liu19971009

spring.shardingsphere.props.sql.show=true
```

### 16.9短链分组管理

#### 16.9.1配置登录拦截器

- link/config/InterceptorConfig

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Slf4j
public class InterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(new LoginInterceptor())
                //添加拦截的路径
                .addPathPatterns("/api/link/*/**", "/api/group/*/**","/api/domain/*/**")

                //排除不拦截
                .excludePathPatterns("");
    }
}
```

#### 16.9.2创建短链分组

##### 16.9.2.1LinkGroupAddRequest

- link/controller/LinkGroupAddRequest

```
package net.xdclass.service;

import net.xdclass.controller.request.LinkGroupAddRequest;
import net.xdclass.model.LinkGroupDO;
import com.baomidou.mybatisplus.extension.service.IService;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface LinkGroupService {

    /**
     * 新增分组
     * @param addRequest
     * @return
     */
    int add(LinkGroupAddRequest addRequest);

}
```

##### 16.9.2.2LinkGroupController

```
package net.xdclass.controller;


import net.xdclass.controller.request.LinkGroupAddRequest;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.service.LinkGroupService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RestController;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/api/group/v1")
public class LinkGroupController {

    @Autowired
    private LinkGroupService linkGroupService;

    /**
     * 创建分组
     * @param addRequest
     * @return
     */
    @PostMapping("/add")
    public JsonData add(@RequestBody LinkGroupAddRequest addRequest) {
        int rows = linkGroupService.add(addRequest);
        return rows == 1 ? JsonData.buildSuccess() : JsonData.buildResult(BizCodeEnum.GROUP_ADD_FAIL);
    }
}
```

##### 16.9.2.3LinkGroupService

```
package net.xdclass.service;

import net.xdclass.controller.request.LinkGroupAddRequest;
import net.xdclass.model.LinkGroupDO;
import com.baomidou.mybatisplus.extension.service.IService;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface LinkGroupService {

    /**
     * 新增分组
     * @param addRequest
     * @return
     */
    int add(LinkGroupAddRequest addRequest);

}
```

##### 16.9.2.4LinkGroupServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.controller.request.LinkGroupAddRequest;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.model.LinkGroupDO;
import net.xdclass.mapper.LinkGroupMapper;
import net.xdclass.service.LinkGroupService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class LinkGroupServiceImpl implements LinkGroupService {

    @Autowired
    private LinkGroupManager linkGroupManager;

    @Override
    public int add(LinkGroupAddRequest addRequest) {
        long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        LinkGroupDO linkGroupDO = new LinkGroupDO();
        linkGroupDO.setTitle(addRequest.getTitle());
        linkGroupDO.setAccountNo(accountNo);
        int rows = linkGroupManager.add(linkGroupDO);
        return rows;
    }
}
```

##### 16.9.2.5LinkGroupManager

```
package net.xdclass.manager;

import net.xdclass.model.LinkGroupDO;

public interface LinkGroupManager {

    int add(LinkGroupDO linkGroupDO);
}
```

##### 16.9.2.6LinkGroupManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.mapper.LinkGroupMapper;
import net.xdclass.model.LinkGroupDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @Description
 * @Author:刘森飚
 **/

@Component
public class LinkGroupManagerImpl implements LinkGroupManager {

    @Autowired
    private LinkGroupMapper linkGroupMapper;

    @Override
    public int add(LinkGroupDO linkGroupDO) {
        return linkGroupMapper.insert(linkGroupDO);
    }
}
```

##### 16.9.2.7application.properties

```
server.port=8003
spring.application.name=dcloud-link

#服务注册发现
spring.cloud.nacos.discovery.server-addr=101.200.159.132:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos

#分库分表配置
spring.shardingsphere.datasource.names=ds0
spring.shardingsphere.datasource.ds0.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds0.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource

spring.shardingsphere.datasource.ds0.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds0.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds0.maxPoolSize=50
spring.shardingsphere.datasource.ds0.minPoolSize=50
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.datasource.ds0.password=Liu19971009

spring.shardingsphere.props.sql.show=true



//在这一行配置雪花算法
#配置短链分组的id生成策略
#雪花算法
#id生成策略
spring.shardingsphere.sharding.tables.link_group.key-generator.column=id
spring.shardingsphere.sharding.tables.link_group.key-generator.props.worker.id=${workId}
spring.shardingsphere.sharding.tables.link_group.key-generator.type=SNOWFLAKE
```

![1674056521517](短链平台项目.assets/1674056521517.png)

![1674056859249](短链平台项目.assets/1674056859249.png)

![1674056910919](短链平台项目.assets/1674056910919.png)

![1674056934633](短链平台项目.assets/1674056934633.png)

#### 16.9.3删除短链分组

##### 16.9.3.1LinkGroupController

```
/**
 * 根据id删除分组
 * @param groupId
 * @return
 */
@DeleteMapping("/del/{group_id}")
public JsonData del(@PathVariable("group_id") Long groupId) {
    int rows = linkGroupService.del(groupId);
    return rows == 1 ? JsonData.buildSuccess() : JsonData.buildResult(BizCodeEnum.GROUP_NOT_EXIST);
}
```

##### 16.9.3.2LinkGroupService

```
/**
 * 删除分组
 * @param groupId
 * @return
 */
int del(Long groupId);
```
##### 16.9.3.3LinkGroupServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.controller.request.LinkGroupAddRequest;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.model.LinkGroupDO;
import net.xdclass.mapper.LinkGroupMapper;
import net.xdclass.service.LinkGroupService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class LinkGroupServiceImpl implements LinkGroupService {

    @Autowired
    private LinkGroupManager linkGroupManager;

    /**
     * 创建短链分组
     * @param addRequest
     * @return
     */
    @Override
    public int add(LinkGroupAddRequest addRequest) {
        long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        LinkGroupDO linkGroupDO = new LinkGroupDO();
        linkGroupDO.setTitle(addRequest.getTitle());
        linkGroupDO.setAccountNo(accountNo);
        int rows = linkGroupManager.add(linkGroupDO);
        return rows;
    }


    /**
     * 删除短链分组
     * @param groupId
     * @return
     */
    @Override
    public int del(Long groupId) {
        long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        return linkGroupManager.del(groupId,accountNo);
    }
}
```
##### 16.9.3.4LinkGroupManager

```
package net.xdclass.manager;

import net.xdclass.model.LinkGroupDO;

public interface LinkGroupManager {

    int add(LinkGroupDO linkGroupDO);

    int del(Long groupId, Long accountNo);
}
```

##### 16.9.3.5LinkGroupManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.mapper.LinkGroupMapper;
import net.xdclass.model.LinkGroupDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @Description
 * @Author:刘森飚
 **/

@Component
public class LinkGroupManagerImpl implements LinkGroupManager {

    @Autowired
    private LinkGroupMapper linkGroupMapper;

    @Override
    public int add(LinkGroupDO linkGroupDO) {
        return linkGroupMapper.insert(linkGroupDO);
    }

    @Override
    public int del(Long groupId, Long accountNo) {
        return linkGroupMapper.delete(new QueryWrapper<LinkGroupDO>().
                eq("id",groupId).eq("account_no",accountNo));
    }
}
```

![1674059224402](短链平台项目.assets/1674059224402.png)

#### 16.9.4查询短链详情

##### 16.9.4.1LinkGroupController

```
/**
 * 根据ID找详情
 * @return
 */
@GetMapping("detail/{group_id}")
public JsonData detail(@PathVariable("group_id") Long groupId) {
    LinkGroupVO linkGroupVO = linkGroupService.detail(groupId);
    return JsonData.buildSuccess(linkGroupVO);
}
```
##### 16.9.4.2LinkGroupService

```
package net.xdclass.service;

import net.xdclass.controller.request.LinkGroupAddRequest;
import net.xdclass.controller.request.LinkGroupUpdateRequest;
import net.xdclass.model.LinkGroupDO;
import com.baomidou.mybatisplus.extension.service.IService;
import net.xdclass.vo.LinkGroupVO;

import java.util.List;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface LinkGroupService {
    /**
     * 详情
     * @param groupId
     * @return
     */
    LinkGroupVO detail(Long groupId);
}
```
##### 16.9.4.3LinkGroupServiceImpl

```
/**
 * 详情
 * @param groupId
 * @return
 */
@Override
public LinkGroupVO detail(Long groupId) {
    long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
    LinkGroupDO linkGroupDO = linkGroupManager.detail(groupId,accountNo);
    LinkGroupVO linkGroupVO = new LinkGroupVO();
    BeanUtils.copyProperties(linkGroupDO,linkGroupVO);
    return linkGroupVO;
}
```

##### 16.9.4.4LinkGroupManager

```
package net.xdclass.manager;

import net.xdclass.model.LinkGroupDO;

import java.util.List;

public interface LinkGroupManager {

    int add(LinkGroupDO linkGroupDO);

    int del(Long groupId, Long accountNo);

    LinkGroupDO detail(Long groupId, long accountNo);

    List<LinkGroupDO> listAllGroup(long accountNo);

    int updateById(LinkGroupDO linkGroupDO);
}
```

##### 16.9.4.5LinkGroupManagerImpl

```
@Override
public LinkGroupDO detail(Long groupId, long accountNo) {
    return linkGroupMapper.selectOne(new QueryWrapper<LinkGroupDO>()
    .eq("id",groupId)
    .eq("account_no",accountNo));
}
```
![1674112221525](短链平台项目.assets/1674112221525.png)

#### 16.9.5查看全部分组

##### 16.9.5.1LinkGroupVO

```
package net.xdclass.vo;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.io.Serializable;
import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
public class LinkGroupVO implements Serializable {

    private Long id;

    /**
     * 组名
     */
    private String title;

    /**
     * 账号唯一编号
     */
    private Long accountNo;

    private Date gmtCreate;

    private Date gmtModified;


}
```

##### 16.9.5.2LinkGroupController

```
/**
 * 列出用户全部分组
 * @return
 */
@GetMapping("list")
public JsonData findUserAllLinkGroup() {
    List<LinkGroupVO> list = linkGroupService.listAllGroup();

    return JsonData.buildSuccess(list);
}
```

##### 16.9.5.3LinkGroupService

```
package net.xdclass.service;

import net.xdclass.controller.request.LinkGroupAddRequest;
import net.xdclass.controller.request.LinkGroupUpdateRequest;
import net.xdclass.model.LinkGroupDO;
import com.baomidou.mybatisplus.extension.service.IService;
import net.xdclass.vo.LinkGroupVO;

import java.util.List;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface LinkGroupService {

    /**
     * 新增分组
     * @param addRequest
     * @return
     */
    int add(LinkGroupAddRequest addRequest);

    /**
     * 删除分组
     * @param groupId
     * @return
     */
    int del(Long groupId);

    /**
     * 详情
     * @param groupId
     * @return
     */
    LinkGroupVO detail(Long groupId);

    /**
     * 列出用户全部分组
     * @return
     */
    List<LinkGroupVO> listAllGroup();

    /**
     * 更新组名
     * @param request
     * @return
     */
    int updateById(LinkGroupUpdateRequest request);
}
```

##### 16.9.5.4LinkGroupServiceImpl

```
/**
 * 列出用户全部分组
 * @return
 */
@Override
public List<LinkGroupVO> listAllGroup() {
    long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
    List<LinkGroupDO> linkGroupDOList = linkGroupManager.listAllGroup(accountNo);
    List<LinkGroupVO> groupVOList = linkGroupDOList.stream().map(obj -> {
        LinkGroupVO linkGroupVO = new LinkGroupVO();
        BeanUtils.copyProperties(obj, linkGroupVO);
        return linkGroupVO;
    }).collect(Collectors.toList());
    return groupVOList;
}
```

##### 16.9.5.5LinkGroupManager

```
package net.xdclass.manager;

import net.xdclass.model.LinkGroupDO;

import java.util.List;

public interface LinkGroupManager {

    int add(LinkGroupDO linkGroupDO);

    int del(Long groupId, Long accountNo);

    LinkGroupDO detail(Long groupId, long accountNo);

    List<LinkGroupDO> listAllGroup(long accountNo);

    int updateById(LinkGroupDO linkGroupDO);
}
```

##### 16.9.5.6LinkGroupManagerImpl

```
@Override
public List<LinkGroupDO> listAllGroup(long accountNo) {

    return linkGroupMapper.selectList(new QueryWrapper<LinkGroupDO>()
            .eq("account_no",accountNo));
}
```

![1674112175584](短链平台项目.assets/1674112175584.png)

#### 16.9.6更新短链分组

##### 16.9.5.1LinkGroupUpdateRequest

```
package net.xdclass.controller.request;

import lombok.Data;

/**
 * @Description
 * @Author:刘森飚
 **/

@Data
public class LinkGroupUpdateRequest {

    /**
     * 组id
     */
    private Long id;
    /**
     * 组名
     */
    private String title;
}
```

##### 16.9.5.2LinkGroupController

```
/**
 * 更新短链分组
 * @return
 */
@PutMapping("update")
public JsonData update(@RequestBody LinkGroupUpdateRequest request) {

    int rows = linkGroupService.updateById(request);
    return rows == 1 ? JsonData.buildSuccess() : JsonData.buildResult(BizCodeEnum.GROUP_OPER_FAIL);
}
```

##### 16.9.5.3LinkGroupService

```
package net.xdclass.service;

import net.xdclass.controller.request.LinkGroupAddRequest;
import net.xdclass.controller.request.LinkGroupUpdateRequest;
import net.xdclass.model.LinkGroupDO;
import com.baomidou.mybatisplus.extension.service.IService;
import net.xdclass.vo.LinkGroupVO;

import java.util.List;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface LinkGroupService {
    /**
     * 更新组名
     * @param request
     * @return
     */
    int updateById(LinkGroupUpdateRequest request);
}
```

##### 16.9.5.4LinkGroupServiceImpl

```
/**
 * 更新组名
 * @param request
 * @return
 */
@Override
public int updateById(LinkGroupUpdateRequest request) {
    Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
    LinkGroupDO linkGroupDO = new LinkGroupDO();
    linkGroupDO.setTitle(request.getTitle());
    linkGroupDO.setId(request.getId());
    linkGroupDO.setAccountNo(accountNo);
    int rows = linkGroupManager.updateById(linkGroupDO);
    return rows;
}
```

##### 16.9.5.5LinkGroupManager

```
package net.xdclass.manager;

import net.xdclass.model.LinkGroupDO;

import java.util.List;

public interface LinkGroupManager {

    int add(LinkGroupDO linkGroupDO);

    int del(Long groupId, Long accountNo);

    LinkGroupDO detail(Long groupId, long accountNo);

    List<LinkGroupDO> listAllGroup(long accountNo);

    int updateById(LinkGroupDO linkGroupDO);
}
```

##### 16.9.5.6LinkGroupManagerImpl

```
@Override
public int updateById(LinkGroupDO linkGroupDO) {

    return linkGroupMapper.update(linkGroupDO,new QueryWrapper<LinkGroupDO>()
            .eq("id",linkGroupDO.getId())
            .eq("account_no",linkGroupDO.getAccountNo()));
}
```
![1674112100279](短链平台项目.assets/1674112100279.png)

![1674112126669](短链平台项目.assets/1674112126669.png)

### 16.10水平分库分表(青铜玩法）

#### 16.10.1需求

```
未来2年，短链平台累计5百万⽤户
短链组：⼀个⽤户30个组，就是1.5亿个组
单表不超过1千万数据，需要分15张表
进⼀步延伸，进⾏⽔平分库分表，⽐如 2库、4库、8库、16库
⼀个库⼀张表
需要降低单表数据量，进⾏⽔平分库分表
分库数量：线上分16库，本地分2库即可
分⽚key： account_no，查询维度都是根据account_no进⾏查询
分⽚策略：⾏表达式分⽚策略 InlineShardingStrategy
```

#### 16.10.2创建分库对应的数据库

![1674113526797](短链平台项目.assets/1674113526797.png)

![1674114253877](短链平台项目.assets/1674114253877.png)

- 每个数据库创建link_group表

```
CREATE TABLE `link_group` (
  `id` bigint unsigned NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '组名',
  `account_no` bigint DEFAULT NULL COMMENT '账号唯一编号',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

#### 16.10.3配置application.properties

```
server.port=8003
spring.application.name=dcloud-link

#服务注册发现
spring.cloud.nacos.discovery.server-addr=101.200.159.132:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos

#分库分表配置
spring.shardingsphere.datasource.names=ds0,ds1
spring.shardingsphere.props.sql.show=true

#ds0配置
spring.shardingsphere.datasource.ds0.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds0.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link_0?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds0.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds0.maxPoolSize=50
spring.shardingsphere.datasource.ds0.minPoolSize=50
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.datasource.ds0.password=Liu19971009



#ds1配置
spring.shardingsphere.datasource.ds1.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds1.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link_1?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds1.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds1.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds1.maxPoolSize=50
spring.shardingsphere.datasource.ds1.minPoolSize=50
spring.shardingsphere.datasource.ds1.username=root
spring.shardingsphere.datasource.ds1.password=Liu19971009


#----------短链组，策略：水平分库，水平分表(1张表)--------------
# 先进行水平分库， 水平分库策略，行表达式分片
#配置短链分组的id生成策略
#雪花算法
spring.shardingsphere.sharding.tables.link_group.key-generator.column=id
spring.shardingsphere.sharding.tables.link_group.key-generator.props.worker.id=${workId}
spring.shardingsphere.sharding.tables.link_group.key-generator.type=SNOWFLAKE

spring.shardingsphere.sharding.tables.link_group.database-strategy.inline.sharding-column=account_no
spring.shardingsphere.sharding.tables.link_group.database-strategy.inline.algorithm-expression=ds$->{account_no % 2}
```

![1674116815248](短链平台项目.assets/1674116815248.png)

![1674116843766](短链平台项目.assets/1674116843766.png)

### 16.11水平分库分表(黄金玩法）

#### 16.11.1需要解决的问题

```
数据量增加，扩容避免迁移数据或者免迁移
前期数据量不多，不浪费库表系统资源
分库分表：16个库, 每个库64个表，总量就是 1024个表
```

#### 16.11.2解决方案

- 如何做？

```
从短链码入手-增加库表位
类似案例-阿⾥这边商品订单号-⾥⾯也包括了库表信息。
```

![1674220140648](短链平台项目.assets/1674220140648.png)

- 为啥能做到免迁移扩容？

```
A92AEva1
由于短链码的前缀和后缀是是固定的，所以扩容也不影响旧的数据
类似的免迁移扩容策略还有哪些？
时间范围分库分表
id范围分库分表
```

#### 16.11.3新建数据库

![1674220893791](短链平台项目.assets/1674220893791.png)

- 在dcloud_0/dcloud_1/dcloud_a三个数据库分别建立short_link_0/short_link_a两张表

```
CREATE TABLE `short_link_a` (
  `id` bigint unsigned NOT NULL,
  `group_id` bigint DEFAULT NULL COMMENT '组',
  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '短链标题',
  `original_url` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '原始url地址',
  `domain` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '短链域名',
  `code` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '短链压缩码',
  `sign` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '长链的md5码，方便查找',
  `expired` datetime DEFAULT NULL COMMENT '过期时间，长久就是-1',
  `account_no` bigint DEFAULT NULL COMMENT '账号唯一编号',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `del` int unsigned NOT NULL COMMENT '0是默认，1是删除',
  `state` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '状态，lock是锁定不可用，active是可用',
  `link_type` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '链接产品层级：FIRST 免费青铜、SECOND黄金、THIRD钻石',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_code` (`code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

![1674222144995](短链平台项目.assets/1674222144995.png)

#### 16.11.4application.properties

```
server.port=8003
spring.application.name=dcloud-link

#服务注册发现
spring.cloud.nacos.discovery.server-addr=101.200.159.132:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos

#分库分表配置
spring.shardingsphere.datasource.names=ds0,ds1,dsa
spring.shardingsphere.props.sql.show=true

#ds0配置
spring.shardingsphere.datasource.ds0.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds0.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link_0?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds0.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds0.maxPoolSize=50
spring.shardingsphere.datasource.ds0.minPoolSize=50
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.datasource.ds0.password=Liu19971009



#ds1配置
spring.shardingsphere.datasource.ds1.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds1.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link_1?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds1.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds1.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds1.maxPoolSize=50
spring.shardingsphere.datasource.ds1.minPoolSize=50
spring.shardingsphere.datasource.ds1.username=root
spring.shardingsphere.datasource.ds1.password=Liu19971009


#dsa配置
spring.shardingsphere.datasource.dsa.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.dsa.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.dsa.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.dsa.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link_a?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.dsa.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.dsa.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.dsa.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.dsa.maxPoolSize=50
spring.shardingsphere.datasource.dsa.minPoolSize=50
spring.shardingsphere.datasource.dsa.username=root
spring.shardingsphere.datasource.dsa.password=Liu19971009



#----------短链组，策略：水平分库，水平分表(1张表)--------------
# 先进行水平分库， 水平分库策略，行表达式分片
#配置短链分组的id生成策略
#雪花算法
spring.shardingsphere.sharding.tables.link_group.key-generator.column=id
spring.shardingsphere.sharding.tables.link_group.key-generator.props.worker.id=${workId}
spring.shardingsphere.sharding.tables.link_group.key-generator.type=SNOWFLAKE

spring.shardingsphere.sharding.tables.link_group.database-strategy.inline.sharding-column=account_no
spring.shardingsphere.sharding.tables.link_group.database-strategy.inline.algorithm-expression=ds$->{account_no % 2}


#----------短链，策略：分库+分表--------------
# 先进行水平分库，然后再水平分表
spring.shardingsphere.sharding.tables.short_link.database-strategy.standard.sharding-column=code
spring.shardingsphere.sharding.tables.short_link.database-strategy.standard.precise-algorithm-class-name=net.xdclass.strategy.CustomDBPreciseShardingAlgorithm


# 水平分表策略，自定义策略。   真实库.逻辑表
spring.shardingsphere.sharding.tables.short_link.actual-data-nodes=ds0.short_link,ds1.short_link,dsa.short_link
spring.shardingsphere.sharding.tables.short_link.table-strategy.standard.sharding-column=code
spring.shardingsphere.sharding.tables.short_link.table-strategy.standard.precise-algorithm-class-name=net.xdclass.strategy.CustomTablePreciseShardingAlgorithm
#id生成策略
spring.shardingsphere.sharding.tables.short_link.key-generator.column=id
spring.shardingsphere.sharding.tables.short_link.key-generator.type=SNOWFLAKE
spring.shardingsphere.sharding.tables.short_link.key-generator.props.worker.id=${workerId}
```

#### 16.11.5精准分片算法-水平分库

- common/enums/BizCodeEnum

```
...
    /**
     * 数据库路由信息
     */
    DB_ROUTE_NOT_FOUND(800101,"数据库找不到");
...
```

- link/strategy/CustomDBPreciseShardingAlgorithm

```
package net.xdclass.strategy;

import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import org.apache.shardingsphere.api.sharding.standard.PreciseShardingAlgorithm;
import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;

import java.util.Collection;

/**
 * @Description
 * @Author 刘森飚
 **/

public class CustomDBPreciseShardingAlgorithm implements PreciseShardingAlgorithm<String> {

    /**
     * @param availableTargetNames 数据源集合
     *                             在分库时值为所有分片库的集合 databaseNames
     *                             分表时为对应分片库中所有分片表的集合 tablesNames
     * @param shardingValue        分片属性，包括
     *                             logicTableName 为逻辑表，
     *                             columnName 分片健（字段），
     *                             value 为从 SQL 中解析出的分片健的值
     * @return
     */

    @Override
    public String doSharding(Collection<String> availableTargetNames, PreciseShardingValue<String> shardingValue) {

        //获取短链码第一位，即库位
        String codePrefix = shardingValue.getValue().substring(0, 1);

        for (String targetName : availableTargetNames) {
            //获取库名的最后一位，真实配置的ds
            //ds0,ds1,dsa -> 0,1,a
            String targetNameSuffix = targetName.substring(targetName.length() - 1);

            //如果一致则返回
            if (codePrefix.equals(targetNameSuffix)) {
                return targetName;
            }
        }

        //抛异常
        throw new BizException(BizCodeEnum.DB_ROUTE_NOT_FOUND);

    }
}
```

#### 16.11.6精准分片算法-水平分表

- link/strategy/CustomTablePreciseShardingAlgorithm

```
package net.xdclass.strategy;

import org.apache.shardingsphere.api.sharding.standard.PreciseShardingAlgorithm;
import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;

import java.util.Collection;

/**
 * @Description
 * @Author 刘森飚
 **/

public class CustomTablePreciseShardingAlgorithm implements PreciseShardingAlgorithm<String> {

    /**
     * @param availableTargetNames 数据源集合
     *                             在分库时值为所有分片库的集合 databaseNames
     *                             分表时为对应分片库中所有分片表的集合 tablesNames
     * @param shardingValue        分片属性，包括
     *                             logicTableName 为逻辑表，
     *                             columnName 分片健（字段），
     *                             value 为从 SQL 中解析出的分片健的值
     * @return
     */
    @Override
    public String doSharding(Collection<String> availableTargetNames, PreciseShardingValue<String> shardingValue) {

        //获取逻辑表
        String targetName = availableTargetNames.iterator().next();

        //短链码  A23Ad1
        String value = shardingValue.getValue();

        //获取短链码最后一位
        String codeSuffix =  value.substring(value.length()-1);

        //拼接Actual table
        return targetName+"_"+codeSuffix;
    }
}
```

#### 16.11.7生成库表位实战

##### 16.11.7.1分库位

```
package net.xdclass.strategy;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * @Description
 * @Author：刘森飚
 **/

public class ShardingDBConfig {

    /**
     * 存储数据库位置编号
     */
    private static final List<String> dbPrefixList = new ArrayList<>();

    private static Random random = new Random();

    //配置启用那些库的前缀
    static {
        dbPrefixList.add("0");
        dbPrefixList.add("1");
        dbPrefixList.add("a");
    }


    /**
     * 获取随机的前缀
     * @return
     */
    public static String getRandomDBPrefix(){
        int index = random.nextInt(dbPrefixList.size());
        return dbPrefixList.get(index);
    }
}
```

##### 16.11.7.2分表位

```
package net.xdclass.strategy;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * @Description
 * @Author：刘森飚
 **/

public class ShardingTableConfig {

    /**
     * 存储数据表位置编号
     */
    private static final List<String> tableSuffixList = new ArrayList<>();

    private static Random random = new Random();

    //配置启用那些表的后缀
    static {
        tableSuffixList.add("0");
        tableSuffixList.add("a");
    }


    /**
     * 获取随机的后缀
     * @return
     */
    public static String getRandomTableSuffix(){
        int index = random.nextInt(tableSuffixList.size());
        return tableSuffixList.get(index);
    }
}
```

##### 16.11.7.3ShortLinkComponent

```
package net.xdclass.component;

import net.xdclass.strategy.ShardingDBConfig;
import net.xdclass.strategy.ShardingTableConfig;
import net.xdclass.util.CommonUtil;
import org.springframework.stereotype.Component;

/**
 * @Author 刘森飚
 * @Version 1.0
 **/

@Component
public class ShortLinkComponent {

    /**
     * 62个字符
     */
    private static final String CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";


    /**
     * 生成短链码
     * @param param
     * @return
     */
    public String createShortLinkCode(String param){

        long murmurhash = CommonUtil.murmurHash32(param);
        //进制转换
        String code = encodeToBase62(murmurhash);

        #在这一行添加代码
        String shortLinkCode = ShardingDBConfig.getRandomDBPrefix() + code + ShardingTableConfig.getRandomTableSuffix();


        return shortLinkCode;
    }

    /**
     * 10进制转62进制
     * @param num
     * @return
     */
    private String encodeToBase62(long num){

        // StringBuffer线程安全，StringBuilder线程不安全
        StringBuffer sb = new StringBuffer();
        do{
            int i = (int )(num%62);
            sb.append(CHARS.charAt(i));
            num = num/62;
        }while (num>0);

        String value = sb.reverse().toString();
        return value;

    }
}
```

##### 16.11.7.4单元测试

```
/**
 * 测试短链平台
 */
@Test
public void testCreateShortLink() {

    Random random = new Random();
    for (int i = 0; i < 10; i++) {
        int num1 = random.nextInt(10);
        int num2 = random.nextInt(10000000);
        int num3 = random.nextInt(10000000);
        String originalUrl = num1 + "xdclass" + num2 + ".net" + num3;
        String shortLinkCode = shortLinkComponent.createShortLinkCode(originalUrl);
        log.info("originalUrl:" + originalUrl + ", shortLinkCode=" + shortLinkCode);
    }
}
```

![1674225974851](短链平台项目.assets/1674225974851.png)

#### 16.11.8Manager层CRUD开发

- link/manager/ShortLinkManager

```
package net.xdclass.manager;

import net.xdclass.model.ShortLinkDO;

public interface ShortLinkManager {

    /**
     * 新增
     * @param shortLinkDO
     * @return
     */
    int addShortLink(ShortLinkDO shortLinkDO);

    /**
     * 根据短链码找短链
     * @param shortLinkCode
     * @return
     */
    ShortLinkDO findByShortLinkCode(String shortLinkCode);

    /**
     * 删除
     * @param shortLinkCode
     * @param accountNo
     * @return
     */
    int del(String shortLinkCode,Long accountNo);
}
```

- link/manager/ShortLinkManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.mapper.ShortLinkMapper;
import net.xdclass.model.ShortLinkDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class ShortLinkManagerImpl implements ShortLinkManager {

    @Autowired
    private ShortLinkMapper shortLinkMapper;

    @Override
    public int addShortLink(ShortLinkDO shortLinkDO) {
        return shortLinkMapper.insert(shortLinkDO);
    }

    @Override
    public ShortLinkDO findByShortLinkCode(String shortLinkCode) {
        ShortLinkDO shortLinkDO = shortLinkMapper.selectOne(new QueryWrapper<ShortLinkDO>()
                .eq("code", shortLinkCode));
        return shortLinkDO;
    }

    @Override
    public int del(String shortLinkCode, Long accountNo) {
        //逻辑删除
        ShortLinkDO shortLinkDO = new ShortLinkDO();
        shortLinkDO.setDel(1);
        int rows = shortLinkMapper.update(shortLinkDO,new QueryWrapper<ShortLinkDO>()
                .eq("code",shortLinkCode)
                .eq("account_no",accountNo));
        return rows;
    }
}
```

#### 16.11.9数据不均匀解决方案

- 问题

```
假如前期分三个库，⼀个库两个表，项⽬⽕爆，数据量激增，进⾏扩容。
增加了新的数据库表位，会导致旧的库表⽐新的库表数据量多，且容易出现超载情况。	
```

- 解决方案

```
Nginx加权负载均衡的应⽤
不同的库表位分配的概率不⼀样，类似的中间件应⽤场景有nginx
Nginx常⻅的负载均衡策略
节点轮询（默认）
weight 权重配置
简介：weight和访问⽐率成正⽐，数字越⼤，分配得到的流量越⾼
场景：服务器性能差异⼤的情况使⽤


upstream lbs {
 server 192.168.159.133:8080 weight=5;
 server 192.168.159.133:8081 weight=10;
}
```

### 16.12水平分库分表(钻石玩法）

#### 16.12.1需求

```
接收⼀个短链码
解析获取原始地址
302进行跳转
```

#### 16.12.2跳转接口开发

##### 16.12.2.1ShortLinkVO

```
package net.xdclass.vo;

import lombok.Data;
import lombok.EqualsAndHashCode;

import java.io.Serializable;
import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
public class ShortLinkVO implements Serializable {

    private Long id;

    /**
     * 组
     */
    private Long groupId;

    /**
     * 短链标题
     */
    private String title;

    /**
     * 原始url地址
     */
    private String originalUrl;

    /**
     * 短链域名
     */
    private String domain;

    /**
     * 短链压缩码
     */
    private String code;

    /**
     * 长链的md5码，方便查找
     */
    private String sign;

    /**
     * 过期时间，长久就是-1
     */
    private Date expired;

    /**
     * 账号唯一编号
     */
    private Long accountNo;

    /**
     * 创建时间
     */
    private Date gmtCreate;

    /**
     * 修改时间
     */
    private Date gmtModified;

    /**
     * 0是默认，1是删除
     */
    private Integer del;

    /**
     * 状态，lock是锁定不可用，active是可用
     */
    private String state;

    /**
     * 链接产品层级：FIRST 免费青铜、SECOND黄金、THIRD钻石
     */
    private String linkType;


}
```

##### 16.12.2.2LinkApiController

```
package net.xdclass.controller;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.CommonUtil;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */

@Controller
@Slf4j
public class LinkApiController {

    @Autowired
    private ShortLinkService shortLinkService;

    /**
     * 解析 301还是302，这边是返回http code是302
     * <p>
     * 知识点一，为什么要用 301 跳转而不是 302 呐？
     * <p>
     * 301 是永久重定向，302 是临时重定向。
     * <p>
     * 短地址一经生成就不会变化，所以用 301 是同时对服务器压力也会有一定减少
     * <p>
     * 但是如果使用了 301，无法统计到短地址被点击的次数。
     * <p>
     * 所以选择302虽然会增加服务器压力，但是有很多数据可以获取进行分析
     * @return
     */
    @GetMapping(path = "/{shortLinkCode}")
    public void dispatch(@PathVariable("shortLinkCode")String shortLinkCode,
                         HttpServletRequest request, HttpServletResponse response) {

        try {
            log.info("短链码:{}", shortLinkCode);
            //判断短链码是否违规
            if (isLetterDigit(shortLinkCode)) {
                //查找短链
                ShortLinkVO shortLinkVO = shortLinkService.parseShortLinkCode(shortLinkCode);
                //判断是否过期和可用
                if (isVisitable(shortLinkVO)) {
                    response.setHeader("Location", shortLinkVO.getOriginalUrl());
                    //302跳转
                    response.setStatus(HttpStatus.FOUND.value());
                } else {
                    response.setStatus(HttpStatus.NOT_FOUND.value());
                    return;
                }
            }
        }catch (Exception e) {
            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
        }
    }

    /**
     * 判断短链是否可用
     *
     * @param shortLinkVO
     * @return
     */
    private static boolean isVisitable(ShortLinkVO shortLinkVO) {
        if ((shortLinkVO != null && shortLinkVO.getExpired().getTime() > CommonUtil.getCurrentTimestamp())) {
            if (ShortLinkStateEnum.ACTIVE.name().equalsIgnoreCase(shortLinkVO.getState())) {
                return true;
            }
        } else if ((shortLinkVO != null && shortLinkVO.getExpired().getTime() == -1)) {
            if (ShortLinkStateEnum.ACTIVE.name().equalsIgnoreCase(shortLinkVO.getState())) {
                return true;
            }
        }
        return false;
    }


    /**
     * 仅包括数字和字母
     * @param str
     * @return
     */
    private static boolean isLetterDigit(String str) {
        String regex = "^[a-z0-9A-Z]+$";
        return str.matches(regex);
    }

}
```

##### 16.12.2.3ShortLinkService

```
package net.xdclass.service;

import net.xdclass.vo.ShortLinkVO;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface ShortLinkService {

    /**
     * 解析短链
     * @param shortLinkCode
     * @return
     */
    ShortLinkVO parseShortLinkCode(String shortLinkCode);
}
```

##### 16.12.2.4ShortLinkServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.model.ShortLinkDO;
import net.xdclass.service.ShortLinkService;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class ShortLinkServiceImpl implements ShortLinkService{

    @Autowired
    private ShortLinkManager shortLinkManager;

    /**
     * 解析短链
     * @param shortLinkCode
     * @return
     */
    @Override
    public ShortLinkVO parseShortLinkCode(String shortLinkCode) {
        ShortLinkDO shortLinkDO = shortLinkManager.findByShortLinkCode(shortLinkCode);
        if (shortLinkDO == null) {
            return null;
        }
        ShortLinkVO shortLinkVO = new ShortLinkVO();
        BeanUtils.copyProperties(shortLinkDO,shortLinkVO);
        return shortLinkVO;
    }
}
```

##### 16.12.2.5ShortLinkManager

```
package net.xdclass.manager;

import net.xdclass.model.ShortLinkDO;

public interface ShortLinkManager {
....

    /**
     * 根据短链码找短链
     * @param shortLinkCode
     * @return
     */
    ShortLinkDO findByShortLinkCode(String shortLinkCode);

....
}
```

##### 16.12.2.6ShortLinkManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.mapper.ShortLinkMapper;
import net.xdclass.model.ShortLinkDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class ShortLinkManagerImpl implements ShortLinkManager {

...
    @Override
    public ShortLinkDO findByShortLinkCode(String shortLinkCode) {
        ShortLinkDO shortLinkDO = shortLinkMapper.selectOne(new QueryWrapper<ShortLinkDO>()
                .eq("code", shortLinkCode).eq("del",0));
        return shortLinkDO;
    }
....
}
```

#### 16.12.3短链服务多维度查询问题

##### 16.12.3.1问题

```
电商订单案例⼀：
订单表 的partionKey是user_id，⽤户查看⾃⼰的订单列表⽅便。
但商家查看⾃⼰店铺的订单列表就麻烦，分布在不同数据节点。


短链访问案例
普通⽤户访问短链，根据短链码code可以解析到对应的库表。
但短链商家，查看⾃⼰全部的短链就麻烦了，分布再不同的库下⾯。
```

- 分库分表后的查询问题

```
有PartitionKey，没PartitionKey两个场景
不同维度查询是不⼀样的，怎么解决？
```

##### 16.12.3.2解决方案

```
字段解析配置
NOSQL冗余
本身库表冗余双写⽅案
部分字段冗余
全量内容冗余
```

###### 16.12.3.2.1解决方式⼀(字段解析配置）

```
建⼀个表，存储account_no对应的库表位，商家⽣成的【短链码】固定前缀或者后缀。
即【短链码】⾥⾯包括了商家的信息。
```

![1674313952419](短链平台项目.assets/1674313952419.png)

###### 16.12.3.2.2NOSQL方案

```
短链表的partionKey是短链码，⽤户访问短码⽅便解析。
但商家查看⾃⼰某个分组下全部短链列表就麻烦，分布在不同数据节点
短链码冗余存储在es上
⼀份业务架构流程
```

![1674314657446](短链平台项目.assets/1674314657446.png)

###### 16.12.3.2.3冗余双写方案

- 电商场景

```
b2b平台，⽐如淘宝、京东，买家和卖家都要能够看到⾃⼰的订单列表。
⽆论是按照买家id切分订单表，还是按照卖家id切分订单表都没法满⾜要求。


拆分买家库和卖家库
买家库，按照⽤户的id来分库分表
卖家库，按照卖家的id来分库分表

数据冗余
下订单的时候写两份数据
在买家库和卖家库各写⼀份数据冗余
```

![1674315783186](短链平台项目.assets/1674315783186.png)

###### 16.12.3.2.4冗余双写问题解决

- 冗余双写会代来什么问题？

```
存储空间更多（属于空间换时间，需要更多存储空间，减少库表数据量，提升性能）。
冗余双写怎么实现问题
分布事务问题
```

- 解决方案⼀

```
直接RPC调⽤+Seata分布式事务框架
优点：强⼀致性，代码逻辑简单，业务侵⼊性⼩
缺点：性能下降，seata本身存在⼀定的性能损耗
Seata⽀持AT、TCC、Saga 三种模式
AT：隔离性好和低改造成本, 但性能低
TCC：性能和隔离性，但改造成本⼤
Saga：性能和低改造成本，但隔离性不好
```

![1674316779658](短链平台项目.assets/1674316779658.png)

- 解决方案⼆(最终采用)

```
使⽤MQ,⽣产者确认消息发送成功后，不同的消费者订阅消息消费
  同时保证消息处理的幂等性
  保证Broker的⾼可⽤
  
优点
实现简单，改造成本⼩
性能⾼，没有全局锁

缺点
弱⼀致性，需要强⼀致性的场景不适⽤
消费者消费失败，需要额外写接口回滚⽣产者业务逻辑
```

![1674320269266](短链平台项目.assets/1674320269266.png)

#### 16.12.4冗余双写开发

##### 16.12.4.1数据库开发

- 分库分表策略

```
分库分表
8个库, 每个库128个表，总量就是 1024个表
本地开发 2库，每个库2个表

分⽚键：
分库PartitionKey：account_no
分表PartitionKey：group_id

普通用户使用short_link
商家使用group_code_mapping
```

- 在dcloud_link_0和dcloud_link_1这俩个数据库分别建立group_code_mapping_0和group_code_mapping_1两张表

```
CREATE TABLE `group_code_mapping_0` (
  `id` bigint unsigned NOT NULL,
  `group_id` bigint DEFAULT NULL COMMENT '组',
  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '短链标题',
  `original_url` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '原始url地址',
  `domain` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '短链域名',
  `code` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '短链压缩码',
  `sign` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '长链的md5码，方便查找',
  `expired` datetime DEFAULT NULL COMMENT '过期时间，长久就是-1',
  `account_no` bigint DEFAULT NULL COMMENT '账号唯一编号',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `del` int unsigned NOT NULL COMMENT '0是默认，1是删除',
  `state` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '状态，lock是锁定不可用，active是可用',
  `link_type` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '链接产品层级：FIRST 免费青铜、SECOND黄金、THIRD钻石',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_code` (`code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

![1674394713899](短链平台项目.assets/1674394713899.png)

- 短链域名表（前期不分库分表，默认ds0）

```
CREATE TABLE `domain` (
  `id` bigint unsigned NOT NULL,
  `account_no` bigint DEFAULT NULL COMMENT '用户自己绑定的域名',
  `domain_type` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '域名类型，自建custom, 官方offical',
  `value` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  `del` int(1) unsigned zerofill DEFAULT '0' COMMENT '0是默认，1是禁用',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

![1674394756079](短链平台项目.assets/1674394756079.png)

##### 16.12.4.2逆向工程生成类

```
package net.xdclass.db;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;


public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();
        // 是否支持AR模式
        config.setActiveRecord(true)
                // 作者
                .setAuthor("刘森飚")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("C:\\Users\\18053\\Desktop")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")

                //生成基本的resultMap
                .setBaseResultMap(true)

                //实体类结尾名称
                .setEntityName("%sDO")
                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://101.200.159.132:3306/dcloud_link_0?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai")
                .setUsername("root")
                .setPassword("Liu19971009");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("domain","group_code_mapping_0");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("=======  相关代码生成完毕  ========");
    }
}
```

##### 16.12.4.3B端Manager层开发

- 常用接口

```
新增
详情
删除
分页
更新状态
```

###### 16.12.4.3.1GroupCodeMappingVO

```
package net.xdclass.vo;

import lombok.Data;
import lombok.EqualsAndHashCode;

import java.io.Serializable;
import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
public class GroupCodeMappingVO implements Serializable {


    private Long id;

    /**
     * 组
     */
    private Long groupId;

    /**
     * 短链标题
     */
    private String title;

    /**
     * 原始url地址
     */
    private String originalUrl;

    /**
     * 短链域名
     */
    private String domain;

    /**
     * 短链压缩码
     */
    private String code;

    /**
     * 长链的md5码，方便查找
     */
    private String sign;

    /**
     * 过期时间，长久就是-1
     */
    private Date expired;

    /**
     * 账号唯一编号
     */
    private Long accountNo;

    /**
     * 创建时间
     */
    private Date gmtCreate;

    /**
     * 修改时间
     */
    private Date gmtModified;

    /**
     * 0是默认，1是删除
     */
    private Integer del;

    /**
     * 状态，lock是锁定不可用，active是可用
     */
    private String state;

    /**
     * 链接产品层级：FIRST 免费青铜、SECOND黄金、THIRD钻石
     */
    private String linkType;

}
```

###### 16.12.4.3.2GroupCodeMappingManager

```
package net.xdclass.manager;

import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.model.GroupCodeMappingDO;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-22
 */
public interface GroupCodeMappingManager {

    /**
     * 查找详情
     * @param mappingId
     * @param accountNo
     * @param groupId
     * @return
     */
    GroupCodeMappingDO findByGroupIdAndMappingId(Long mappingId, Long accountNo, Long groupId);


    /**
     * 新增
     * @param groupCodeMappingDO
     * @return
     */
    int add(GroupCodeMappingDO groupCodeMappingDO);


    /**
     * 根据短链码删除
     * @param shortLinkCode
     * @param accountNo
     * @param groupId
     * @return
     */
    int del(String shortLinkCode, Long accountNo, Long groupId);


    /**
     * 分页查找
     * @param page
     * @param size
     * @param accountNo
     * @param groupId
     * @return
     */
    Map<String,Object> pageShortLinkByGroupId(Integer page, Integer size, Long accountNo, Long groupId);


    /**
     * 更新短链码状态
     * @param accountNo
     * @param groupId
     * @param shortLinkCode
     * @param shortLinkStateEnum
     * @return
     */
    int updateGroupCodeMappingState(Long accountNo, Long groupId, String shortLinkCode, ShortLinkStateEnum shortLinkStateEnum);

}
```

###### 16.12.4.3.3GroupCodeMappingManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.manager.GroupCodeMappingManager;
import net.xdclass.mapper.GroupCodeMappingMapper;
import net.xdclass.model.GroupCodeMappingDO;
import net.xdclass.vo.GroupCodeMappingVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @Description
 * @Author:刘森飚
 **/

@Component
@Slf4j
public class GroupCodeMappingManagerImpl implements GroupCodeMappingManager {

    @Autowired
    private GroupCodeMappingMapper groupCodeMappingMapper;


    /**
     * 查找详情
     * @param mappingId
     * @param accountNo
     * @param groupId
     * @return
     */
    @Override
    public GroupCodeMappingDO findByGroupIdAndMappingId(Long mappingId, Long accountNo, Long groupId) {

        GroupCodeMappingDO groupCodeMappingDO = groupCodeMappingMapper.selectOne(
                new QueryWrapper<GroupCodeMappingDO>()
                .eq("id", mappingId)
                .eq("account_no", accountNo)
                .eq("group_id", groupId));

        return groupCodeMappingDO;
    }


    /**
     * 新增
     * @param groupCodeMappingDO
     * @return
     */
    @Override
    public int add(GroupCodeMappingDO groupCodeMappingDO) {
        return groupCodeMappingMapper.insert(groupCodeMappingDO);
    }


    /**
     * 根据短链码删除
     * @param shortLinkCode
     * @param accountNo
     * @param groupId
     * @return
     */
    @Override
    public int del(String shortLinkCode, Long accountNo, Long groupId) {

        int rows = groupCodeMappingMapper.update(null,
                new UpdateWrapper<GroupCodeMappingDO>()
                .eq("code", shortLinkCode)
                .eq("account_no", accountNo)
                .eq("group_id", groupId).set("del", 1));

        return rows;
    }


    /**
     * 分页查找
     * @param page
     * @param size
     * @param accountNo
     * @param groupId
     * @return
     */
    @Override
    public Map<String, Object> pageShortLinkByGroupId(Integer page, Integer size, Long accountNo, Long groupId) {

        Page<GroupCodeMappingDO> pageInfo = new Page<>(page, size);

        Page<GroupCodeMappingDO> groupCodeMappingDOPage = groupCodeMappingMapper.
                selectPage(pageInfo, new QueryWrapper<GroupCodeMappingDO>()
                        .eq("account_no", accountNo)
                .eq("group_id", groupId)
                .eq("del",0));

        Map<String, Object> pageMap = new HashMap<>(3);

        pageMap.put("total_record", groupCodeMappingDOPage.getTotal());
        pageMap.put("total_page", groupCodeMappingDOPage.getPages());
        pageMap.put("current_data", groupCodeMappingDOPage.getRecords()
                .stream().map(obj -> beanProcess(obj)).collect(Collectors.toList()));


        return pageMap;
    }


    /**
     * 更新短链码状态
     * @param accountNo
     * @param groupId
     * @param shortLinkCode
     * @param shortLinkStateEnum
     * @return
     */
    @Override
    public int updateGroupCodeMappingState(Long accountNo, Long groupId, String shortLinkCode, ShortLinkStateEnum shortLinkStateEnum) {

        int rows = groupCodeMappingMapper.update(null,
                new UpdateWrapper<GroupCodeMappingDO>()
                .eq("code", shortLinkCode)
                .eq("account_no", accountNo)
                .eq("group_id", groupId).eq("del",0)
                .set("state", shortLinkStateEnum.name()));

        return rows;
    }


    /**
     * 查找是否存在
     * @param shortLinkCode
     * @param groupId
     * @param accountNo
     * @return
     */
    @Override
    public GroupCodeMappingDO findByCodeAndGroupId(String shortLinkCode, Long groupId, long accountNo) {
        GroupCodeMappingDO groupCodeMappingDO = groupCodeMappingMapper.selectOne(new QueryWrapper<GroupCodeMappingDO>()
                .eq("code", shortLinkCode)
                .eq("account_no", accountNo)
                .eq("del",0)
                .eq("group_id", groupId));
        return groupCodeMappingDO;
    }


    private GroupCodeMappingVO beanProcess(GroupCodeMappingDO groupCodeMappingDO) {
        GroupCodeMappingVO groupCodeMappingVO = new GroupCodeMappingVO();
        BeanUtils.copyProperties(groupCodeMappingDO, groupCodeMappingVO);

        return groupCodeMappingVO;
    }
}
```

###### 16.12.4.3.4MybatisPlusPageConfig

- common/MybatisPlusPageConfig

```
package net.xdclass.config;

import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
public class MybatisPlusPageConfig {

    /**
     * 新版分页配置
     * @return
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;

    }
}
```

##### 16.12.4.4Domain短链域名开发

###### 16.12.4.4.1DomainTypeEnum

- common/enums/DomainTypeEnum

```
package net.xdclass.enums;

/**
 * @Description
 * @Author:刘森飚
 **/

public enum  DomainTypeEnum {

    /**
     * 自建
     */
    CUSTOM,

    /**
     * 官方
     */
    OFFICIAL;
}
```

###### 16.12.4.4.2DomainVO

```
package net.xdclass.vo;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.io.Serializable;
import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
public class DomainVO implements Serializable {


    private Long id;

    /**
     * 用户自己绑定的域名
     */
    private Long accountNo;

    /**
     * 域名类型，自建custom, 官方offical
     */
    private String domainType;

    private String value;

    /**
     * 0是默认，1是禁用
     */
    private Integer del;

    private Date gmtCreate;

    private Date gmtModified;

}
```

###### 16.12.4.4.3DomainController

```
package net.xdclass.controller;


import net.xdclass.service.DomainService;
import net.xdclass.util.JsonData;
import net.xdclass.vo.DomainVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author 刘森飚
 * @since 2023-01-22
 */
@RestController
@RequestMapping("/api/domain/v1")
public class DomainController {

    @Autowired
    private DomainService domainService;

    @GetMapping("list")
    public JsonData listAll() {
        List<DomainVO> domainVOS = domainService.listAll();
        return JsonData.buildSuccess(domainVOS);
    }
}
```

###### 16.12.4.4.4DomainService

```
package net.xdclass.service;

import net.xdclass.vo.DomainVO;

import java.util.List;

public interface DomainService {


    /**
     * 列举全部可用域名
     * @return
     */
    List<DomainVO> listAll();

}
```

###### 16.12.4.4.5DomainServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.DomainManager;
import net.xdclass.model.DomainDO;
import net.xdclass.service.DomainService;
import net.xdclass.vo.DomainVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */

@Service
@Slf4j
public class DomainServiceImpl implements DomainService {

    @Autowired
    private DomainManager domainManager;


    /**
     * 列举全部可用域名
     * @return
     */
    @Override
    public List<DomainVO> listAll() {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();

        List<DomainDO> customDomainList = domainManager.listCustomDomain(accountNo);
        List<DomainDO> officialDomainList = domainManager.listOfficialDomain();

        customDomainList.addAll(officialDomainList);

        return customDomainList.stream().map(obj-> beanProcess(obj)).collect(Collectors.toList());
    }


    private DomainVO beanProcess(DomainDO domainDO){

        DomainVO domainVO = new DomainVO();

        BeanUtils.copyProperties(domainDO,domainVO);

        return domainVO;

    }

}
```

###### 16.12.4.4.6DomainManager

```
package net.xdclass.manager;

import net.xdclass.enums.DomainTypeEnum;
import net.xdclass.model.DomainDO;

import java.util.List;

public interface DomainManager {


    /**
     * 查找详情
     * @param id
     * @param accountNO
     * @return
     */
    DomainDO findById(Long id, Long accountNO);


    /**
     * 查找详情
     * @param id
     * @param domainTypeEnum
     * @return
     */
    DomainDO findByDomainTypeAndID(Long id, DomainTypeEnum domainTypeEnum);


    /**
     * 新增
     * @param domainDO
     * @return
     */
    int addDomain(DomainDO domainDO);


    /**
     * 列举全部官方域名
     * @return
     */
    List<DomainDO> listOfficialDomain();


    /**
     * 列举全部自定义域名
     * @return
     */
    List<DomainDO> listCustomDomain(Long accountNo);
}
```

###### 16.12.4.4.7DomainManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.DomainTypeEnum;
import net.xdclass.manager.DomainManager;
import net.xdclass.mapper.DomainMapper;
import net.xdclass.model.DomainDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * @Description
 * @Author:刘森飚
 **/

@Component
@Slf4j
public class DomainManagerImpl implements DomainManager {

    @Autowired
    private DomainMapper domainMapper;


    /**
     * 查找详情
     * @param id
     * @param accountNO
     * @return
     */
    @Override
    public DomainDO findById(Long id, Long accountNO) {
        return domainMapper.selectOne(new QueryWrapper<DomainDO>()
                .eq("id", id)
                .eq("account_no", accountNO));
    }


    /**
     * 查找详情
     * @param id
     * @param domainTypeEnum
     * @return
     */
    @Override
    public DomainDO findByDomainTypeAndID(Long id, DomainTypeEnum domainTypeEnum) {
        return domainMapper.selectOne(new QueryWrapper<DomainDO>()
                .eq("id", id)
                .eq("domain_type", domainTypeEnum.name()));
    }


    /**
     * 新增
     * @param domainDO
     * @return
     */
    @Override
    public int addDomain(DomainDO domainDO) {
        return domainMapper.insert(domainDO);
    }


    /**
     * 列举全部官方域名
     * @return
     */
    @Override
    public List<DomainDO> listOfficialDomain() {
        return domainMapper.selectList(new QueryWrapper<DomainDO>()
                .eq("domain_type", DomainTypeEnum.OFFICIAL.name()));
    }



    /**
     * 列举全部自定义域名
     * @return
     */
    @Override
    public List<DomainDO> listCustomDomain(Long accountNo) {
        return domainMapper.selectList(new QueryWrapper<DomainDO>()
                .eq("domain_type", DomainTypeEnum.CUSTOM.name())
                .eq("account_no", accountNo));
    }
}
```

##### 16.12.4.5sharding-jdbc默认数据源配置

- 某些表并不需要进行分表分库，未配置分片规则的表将通过默认
- link/application.properties

```
...
#----------配置默认数据库，比如短链域名，不分库分表--------------
spring.shardingsphere.sharding.default-data-source-name=ds0
#默认id生成策略
spring.shardingsphere.sharding.default-key-generator.column=id
spring.shardingsphere.sharding.default-key-generator.type=SNOWFLAKE
spring.shardingsphere.sharding.default-key-generator.props.worker.id=${workerId}
...
```

##### 16.12.4.6RabbitMQ配置开发

- RabbitMQ实现

![1674485338755](短链平台项目.assets/1674485338755.png)

- 选择RabbitMQ理由

```
业务开发团队本身熟悉RabbitMQ（对内，省了学习成本、运维成本、现有基础设施）。
RabbitMQ⾃带延迟队列，更适合业务这块，⽐如定时任务、分布式事务处理。
Kafka比较适合在⼤数据领域流式计算。
```

###### 16.12.4.6.1RabbitMQ交换机知识点

- RabbitMQ交换机类型

```
⽣产者将消息发送到 Exchange，交换器将消息路由到⼀个或者多个队列中，交换机有多个类型，队列和交换机是多对多的关系。
交换机只负责转发消息，不具备存储消息的能⼒，如果没有队列和exchange绑定，或者没有符合的路由规则，则消息会被丢失。
RabbitMQ有四种交换机类型，分别是Direct exchange、Fanout exchange、Topic exchange、Headers exchange，最后的基本不⽤。
```

![1674571990141](短链平台项目.assets/1674571990141.png)

- 交换机类型

```
Direct Exchange 定向
将⼀个队列绑定到交换机上，要求该消息与⼀个特定的路由键完全匹配
例⼦：如果⼀个队列绑定到该交换机上要求路由键“aabb”，则只有被标记为“aabb”的消息才被转发，不会转发aabb.cc，也不会转发gg.aabb，只会转发aabb。
处理路由健

Fanout Exchange ⼴播
只需要简单的将队列绑定到交换机上，⼀个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像⼦⽹⼴播，每台⼦⽹内的主机都获得了⼀份复制的消息。
Fanout交换机转发消息是最快的，⽤于发布订阅，⼴播形式，中⽂是扇形。
不处理路由健。

Topic Exchange 通配符(最终采用)
主题交换机是⼀种发布/订阅的模式，结合了直连交换机与扇形交换机的特点。
将路由键和某模式进⾏匹配。此时队列需要绑定要⼀个模式上。
符号“#”匹配⼀个或多个词，符号“*”匹配不多不少⼀个词
例⼦：因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.*”只会匹配到“abc.def”。
```

###### 16.12.4.6.2交换机和队列绑定

```
  ⽤topic模式解决分布式事务-最终⼀致性
 
  交换机和队列绑定时⽤的binding使⽤通配符的路由健
  ⽣产者发送消息时需要使⽤具体的路由健
 
  BindingKey是Exchange和Queue绑定的规则描述
  RoutingKey，Exchange就据这个RoutingKey和当前Exchange所有绑定的BindingKey做匹配,符合规则则发送过去。
  真实情况下参数名都是RoutingKey，没有BindingKey这个参数。
  为了区别⽤户发送的和绑定的概念，才说RoutingKey和BindingKey。
  
  ⽬的：解决短链新增数据⼀致性问题
  新增短链-》发送topic消息-》新增短链、新增映射两个消费者进⾏监听。
```

![1674573745405](短链平台项目.assets/1674573745405.png)

```
package net.xdclass.config;

import lombok.Data;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Data
public class RabbitMQConfig {


    /**
     * 交换机
     */
    private String shortLinkEventExchange="short_link.event.exchange";

    /**
     * 创建交换机 Topic类型
     * 一般一个微服务一个交换机
     * @return
     */
    @Bean
    public Exchange shortLinkEventExchange(){

        return new TopicExchange(shortLinkEventExchange,true,false);
    }

    //新增短链相关配置====================================

    /**
     * 新增短链 队列
     */
    private String shortLinkAddLinkQueue="short_link.add.link.queue";

    /**
     * 新增短链映射 队列
     */
    private String shortLinkAddMappingQueue="short_link.add.mapping.queue";

    /**
     * 新增短链具体的routingKey,【发送消息使用】
     */
    private String shortLinkAddRoutingKey="short_link.add.link.mapping.routing.key";

    /**
     * topic类型的binding key，用于绑定队列和交换机，是用于 link 消费者
     */
    private String shortLinkAddLinkBindingKey="short_link.add.link.*.routing.key";

    /**
     * topic类型的binding key，用于绑定队列和交换机，是用于 mapping 消费者
     */
    private String shortLinkAddMappingBindingKey="short_link.add.*.mapping.routing.key";


    /**
     * 新增短链api队列和交换机的绑定关系建立
     */
    @Bean
    public Binding shortLinkAddApiBinding(){
        return new Binding(shortLinkAddLinkQueue,Binding.DestinationType.QUEUE, shortLinkEventExchange,shortLinkAddLinkBindingKey,null);
    }


    /**
     * 新增短链mapping队列和交换机的绑定关系建立
     */
    @Bean
    public Binding shortLinkAddMappingBinding(){
        return new Binding(shortLinkAddMappingQueue,Binding.DestinationType.QUEUE, shortLinkEventExchange,shortLinkAddMappingBindingKey,null);
    }


    /**
     * 新增短链api 普通队列，用于被监听
     */
    @Bean
    public Queue shortLinkAddLinkQueue(){

        return new Queue(shortLinkAddLinkQueue,true,false,false);

    }

    /**
     * 新增短链mapping 普通队列，用于被监听
     */
    @Bean
    public Queue shortLinkAddMappingQueue(){

        return new Queue(shortLinkAddMappingQueue,true,false,false);

    }
}
```

###### 16.12.4.6.3短链和mapping消费者配置

- 消息对象封装

```
package net.xdclass.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @Description
 * @Author 刘森飚
 **/


@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class EventMessage implements Serializable {

    /**
     * 消息队列的消息id
     */
    private String messageId;


    /**
     * 事件类型
     */
    private String eventMessageType;


    /**
     * 业务id
     */
    private String bizId;


    /**
     * 账号
     */
    private Long accountNo;


    /**
     * 消息体
     */
    private String content;

    /**
     * 备注
     */
    private String remark;

}
```

- BizCodeEnum

```
....
/**
 * MQ消费异常
 */
MQ_CONSUME_EXCEPTION(900101,"MQ消费异常");
....
```

- short_link消费者配置

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Component
@Slf4j
@RabbitListener(queues = "short_link.add.link.queue")
public class ShortLinkAddLinkMQListener {
    
    @RabbitHandler
    public void shortLinkHandler(EventMessage eventMessage, Message message, Channel channel) throws IOException {
        log.info("监听到消息ShortLinkAddLinkMQListener message消息内容:{}",message);
        long tag = message.getMessageProperties().getDeliveryTag();
        try{

            //TODO 处理业务逻辑

        }catch (Exception e){

            //处理业务异常，还有进行其他操作，比如记录失败原因
            log.error("消费失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
        //确认消息消费成功
        //channel.basicAck(tag,false);

    }
}
```

- mapping消费者配置

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */

@Component
@Slf4j
@RabbitListener(queues = "short_link.add.mapping.queue")
public class ShortLinkAddMappingMQListener {
    
    @RabbitHandler
    public void shortLinkHandler(EventMessage eventMessage, Message message, Channel channel) throws IOException {
        log.info("监听到消息ShortLinkAddMappingMQListener message消息内容:{}",message);
        long tag = message.getMessageProperties().getDeliveryTag();
        try{

            //TODO 处理业务逻辑

        }catch (Exception e){

            //处理业务异常，还有进行其他操作，比如记录失败原因
            log.error("消费失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
        //确认消息消费成功
        //channel.basicAck(tag,false);

    }
}
```

###### 16.12.4.6.4配置文件配置MQ

- application.properties

```
##----------rabbit配置--------------
spring.rabbitmq.host=101.200.159.132
spring.rabbitmq.port=5672
#需要手工创建虚拟主机
spring.rabbitmq.virtual-host=dev
spring.rabbitmq.username=admin
spring.rabbitmq.password=password
#消息确认方式，manual(手动ack) 和auto(自动ack)
spring.rabbitmq.listener.simple.acknowledge-mode=auto
```

![1674657135712](短链平台项目.assets/1674657135712.png)

- 重启项目

  ![1674660246397](短链平台项目.assets/1674660246397.png)

![1674660281705](短链平台项目.assets/1674660281705.png)

- 不会自动创建队列问题

```
加了@bean配置交换机和queue，启动项⽬却没⾃动化创建队列。
RabbitMQ懒加载模式， 需要配置消费者监听才会创建。
@RabbitListener(queues = "short_link.add.link.queue")
```

- 另外种⽅式（若Mq中⽆相应名称的队列,会⾃动创建Queue）

```
//@RabbitListener(queues = "short_link.add.mapping.queue")
@RabbitListener(queuesToDeclare = { @Queue("short_link.add.mapping.queue") })
```

- 链路测试-多节点启动

![1674660417670](短链平台项目.assets/1674660417670.png)

![1674660451984](短链平台项目.assets/1674660451984.png)

###### 16.12.4.6.5MQ消费者异常处理方案

- 消费者异常情况处理

```
业务代码自己重试
组件重试
```

- RabbitMQ配置重试

```
#开启重试，消费者代码不能添加try catch捕获不往外抛异常
spring.rabbitmq.listener.simple.retry.enabled=true
#最大重试次数
spring.rabbitmq.listener.simple.retry.max-attempts=4
# 重试消息的时间间隔，5秒
spring.rabbitmq.listener.simple.retry.initial-interval=5000
```

问题：多次重试失败怎么处理？

![1674663768495](短链平台项目.assets/1674663768495.png)

- 解决方式：RepublishMessageRecoverer

```
消息重试⼀定次数后，⽤特定的routingKey转发到指定的交
换机中，⽅便后续排查和告警
```

###### 16.12.4.6.6MQ消费者异常重试编码

- 消息消费确认使自动确认方式
- RabbitMQErrorConfig

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.retry.MessageRecoverer;
import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Slf4j
public class RabbitMQErrorConfig {

    @Autowired
    private RabbitTemplate rabbitTemplate;


    /**
     * 异常交换机
     */
    private String shortLinkErrorExchange = "short_link.error.exchange";

    /**
     * 异常队列
     */
    private String shortLinkErrorQueue = "short_link.error.queue";

    /**
     * 异常routing.key
     */
    private String shortLinkErrorRoutingKey = "short_link.error.routing.key";



    /**
     * 创建异常交换机
     * @return
     */
    @Bean
    public TopicExchange errorTopicExchange(){

        return new TopicExchange(shortLinkErrorExchange,true,false);
    }

    /**
     * 创建异常队列
     * @return
     */

    @Bean
    public Queue errorQueue(){
        return new Queue(shortLinkErrorQueue,true);
    }


    /**
     * 建立绑定关系
     * @return
     */
    @Bean
    public Binding bindingErrorQueueAndExchange(){

        return BindingBuilder.bind(errorQueue()).to(errorTopicExchange()).with(shortLinkErrorRoutingKey);
    }


    /**
     * 配置  RepublishMessageRecoverer
     *
     * 消费消息重试一定次数后，用特定的routingKey转发到指定的交换机中，方便后续排查和告警
     *
     * @return
     */
    @Bean
    public MessageRecoverer messageRecoverer(){

        return new RepublishMessageRecoverer(rabbitTemplate,shortLinkErrorExchange,shortLinkErrorRoutingKey);
    }
}
```

###### 16.12.4.6.7消费者异常告警通知

- ShortLinkErrorMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.io.IOException;
/**
 * @author 刘森飚
 * @since 2023-01-18
 */

@Component
@Slf4j
@RabbitListener(queuesToDeclare = { @Queue("short_link.error.queue") })
public class ShortLinkErrorMQListener {

    @RabbitHandler
    public void shortLinkHandler(EventMessage eventMessage, Message message, Channel channel) throws IOException {
        log.error("告警：监听到消息ShortLinkErrorMQListener eventMessage消息内容:{}",eventMessage);
        log.error("告警：Message:{}",message);
        log.error("告警成功，发送通知短信");

    }
}
```

![1674734180076](短链平台项目.assets/1674734180076.png)

##### 16.12.4.7创建短链接口

- common/enums/EventMessageType

###### 16.12.4.7.1EventMessageType

```
package net.xdclass.enums;

/**
 * @Description
 * @Author 刘森飚
 **/

public enum  EventMessageType {

    /**
     * 短链创建
     */
    SHORT_LINK_ADD;
}
```

###### 16.12.4.7.2ShortLinkAddRequest

```
package net.xdclass.controller.request;

import lombok.Data;

import java.util.Date;

/**
 * @Description
 * @Author:刘森飚
 **/


@Data
public class ShortLinkAddRequest {


    /**
     * 组
     */
    private Long groupId;

    /**
     * 短链标题
     */
    private String title;

    /**
     * 原生url
     */
    private String originalUrl;

    /**
     * 域名id
     */
    private Long domainId;

    /**
     * 域名类型
     */
    private String domainType;

    /**
     * 过期时间
     */
    private Date expired;

}
```

###### 16.12.4.7.3ShortLinkController

```
package net.xdclass.controller;


import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RestController;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/api/link/v1")
public class ShortLinkController {

    @Autowired
    private ShortLinkService shortLinkService;

    @PostMapping("add")
    public JsonData createShortLink(@RequestBody ShortLinkAddRequest request){

        JsonData jsonData = shortLinkService.createShortLink(request);

        return jsonData;
    }

}
```

###### 16.12.4.7.4ShortLinkService

```
package net.xdclass.service;

import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.util.JsonData;
import net.xdclass.vo.ShortLinkVO;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface ShortLinkService {

    /**
     * 创建短链
     * @param request
     * @return
     */
    JsonData createShortLink(ShortLinkAddRequest request);
}
```

###### 16.12.4.7.5ShortLinkServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.config.RabbitMQConfig;
import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.enums.EventMessageType;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.model.EventMessage;
import net.xdclass.model.ShortLinkDO;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.IDUtil;
import net.xdclass.util.JsonData;
import net.xdclass.util.JsonUtil;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class ShortLinkServiceImpl implements ShortLinkService{

    @Autowired
    private ShortLinkManager shortLinkManager;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private RabbitMQConfig rabbitMQConfig

    /**
     * 创建短链
     * @param request
     * @return
     */
    @Override
    public JsonData createShortLink(ShortLinkAddRequest request) {
        long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        EventMessage eventMessage = EventMessage.builder().accountNo(accountNo)
                .content(JsonUtil.obj2Json(request))
                .messageId(IDUtil.geneSnowFlakeID().toString())
                .eventMessageType(EventMessageType.SHORT_LINK_ADD.name())
                .build();
        rabbitTemplate.convertAndSend(rabbitMQConfig.getShortLinkEventExchange(),
                rabbitMQConfig.getShortLinkAddRoutingKey(),
                eventMessage);

        return JsonData.buildSuccess();
    }
}
```

![1674660307674](短链平台项目.assets/1674660307674.png)

![1674660346955](短链平台项目.assets/1674660346955.png)

##### 16.12.4.8消费者链路开发

###### 16.12.4.8.1冗余双写问题

- ⽣产者生成短链码，下⾯的情况

```
⽤户A⽣成短链码AABBCC，查询数据库不存在，发送MQ，插⼊数据库成功.
⽤户B⽣成短链码AABBCC，查询数据库不存在，发送MQ，插⼊数据库失败.
```

- 消费者生成短链码，下⾯的情况

```
⽤户A⽣成短链码AABBCC ，C端先插⼊，B端还没插⼊。
⽤户B也⽣成短链码AABBCC ，B端先插⼊，C端还没插⼊。
⽤户A⽣成短链码AABBCC ，B端插⼊。
⽤户B⽣成短链码AABBCC ，C端插⼊。
```

![1674736786816](短链平台项目.assets/1674736786816.png)

###### 16.12.4.8.2C端消费者开发

```
//判断短链域名是否合法
//判断组名是否合法
//生成长链摘要
//生成短链码
//加锁
//查询短链码是否存在
//构建短链对象
//保存数据库
```

- ShortLinkService

```
package net.xdclass.service;

import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.model.EventMessage;
import net.xdclass.util.JsonData;
import net.xdclass.vo.ShortLinkVO;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface ShortLinkService {

    /**
     * 处理短链新增消息
     * @param eventMessage
     * @return
     */
    boolean handlerAddShortLink(EventMessage eventMessage);
}
```

- ShortLinkServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.component.ShortLinkComponent;
import net.xdclass.config.RabbitMQConfig;
import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.enums.DomainTypeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.DomainManager;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.model.DomainDO;
import net.xdclass.model.EventMessage;
import net.xdclass.model.LinkGroupDO;
import net.xdclass.model.ShortLinkDO;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.IDUtil;
import net.xdclass.util.JsonData;
import net.xdclass.util.JsonUtil;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class ShortLinkServiceImpl implements ShortLinkService{

    @Autowired
    private ShortLinkManager shortLinkManager;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private RabbitMQConfig rabbitMQConfig;

    @Autowired
    private DomainManager domainManager;

    @Autowired
    private LinkGroupManager linkGroupManager;

    @Autowired
    private ShortLinkComponent shortLinkComponent;
    

    /**
     * 处理短链新增消息
     * @param eventMessage
     * @return
     */
    @Override
    public boolean handlerAddShortLink(EventMessage eventMessage) {
        long accountNo = eventMessage.getAccountNo();
        String messageType = eventMessage.getEventMessageType();
        ShortLinkAddRequest addRequest = JsonUtil.json2Obj(eventMessage.getContent(), ShortLinkAddRequest.class);

        //判断短链域名是否合法
        DomainDO domainDO = checkDomain(addRequest.getDomainType(), addRequest.getDomainId(), accountNo);
        // 判断组名是否合法
        LinkGroupDO linkGroupDO = checkLinkGroup(addRequest.getGroupId(), accountNo);
        // 生成长链摘要
        String originalUrlDigest = CommonUtil.MD5(addRequest.getOriginalUrl());
        // 生成短链
        String shortLinkCode = shortLinkComponent.createShortLinkCode(addRequest.getOriginalUrl());
        // 加锁
        // 查询短链码是否存在
        //构建短链对象
        ShortLinkDO shortLinkDO = ShortLinkDO.builder()
                .accountNo(accountNo)
                .code(shortLinkCode)
                .title(addRequest.getTitle())
                .originalUrl(addRequest.getOriginalUrl())
                .domain(domainDO.getValue())
                .groupId(linkGroupDO.getId())
                .expired(addRequest.getExpired())
                .sign(originalUrlDigest)
                .state(ShortLinkStateEnum.ACTIVE.name())
                .del(0)
                .build();
        //保存数据库
        shortLinkManager.addShortLink(shortLinkDO);

        return true;
    }


    /**
     * 校验域名
     * @param domainType
     * @param domainId
     * @param accountNo
     * @return
     */
    private DomainDO checkDomain(String domainType,Long domainId,Long accountNo) {

        DomainDO domainDO;
        if (DomainTypeEnum.CUSTOM.name().equalsIgnoreCase(domainType)) {
            domainDO = domainManager.findById(domainId, accountNo);
        }else {
            domainDO = domainManager.findByDomainTypeAndID(domainId, DomainTypeEnum.OFFICIAL);
        }
        Assert.notNull(domainDO,"短链域名不合法");

        return domainDO;
    }

    /**
     * 校验组名
     *
     * @param groupId
     * @param accountNo
     * @return
     */
    private LinkGroupDO checkLinkGroup(Long groupId, Long accountNo) {

        LinkGroupDO linkGroupDO = linkGroupManager.detail(groupId, accountNo);
        Assert.notNull(linkGroupDO, "组名不合法");
        return linkGroupDO;
    }
}
```

###### 16.12.4.8.3B端消费者开发

```
//⽣成⻓链摘要
//判断短链域名是否合法
//判断组名是否合法
//⽣成短链码
//加锁（加锁再查，不然查询后，加锁前有线程刚好新增）
//查询短链码是否存在
//构建短链mapping对象
//保存数据库
```

- ShortLinkServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.component.ShortLinkComponent;
import net.xdclass.config.RabbitMQConfig;
import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.enums.DomainTypeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.DomainManager;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.manager.impl.GroupCodeMappingManagerImpl;
import net.xdclass.model.*;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.IDUtil;
import net.xdclass.util.JsonData;
import net.xdclass.util.JsonUtil;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class ShortLinkServiceImpl implements ShortLinkService{

    @Autowired
    private ShortLinkManager shortLinkManager;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private RabbitMQConfig rabbitMQConfig;

    @Autowired
    private DomainManager domainManager;

    @Autowired
    private LinkGroupManager linkGroupManager;

    @Autowired
    private ShortLinkComponent shortLinkComponent;

    @Autowired
    private GroupCodeMappingManagerImpl groupCodeMappingManager;


    /**
     * 处理短链新增消息
     * @param eventMessage
     * @return
     */
    @Override
    public boolean handlerAddShortLink(EventMessage eventMessage) {
        long accountNo = eventMessage.getAccountNo();
        String messageType = eventMessage.getEventMessageType();
        ShortLinkAddRequest addRequest = JsonUtil.json2Obj(eventMessage.getContent(), ShortLinkAddRequest.class);

        //判断短链域名是否合法
        DomainDO domainDO = checkDomain(addRequest.getDomainType(), addRequest.getDomainId(), accountNo);
        // 判断组名是否合法
        LinkGroupDO linkGroupDO = checkLinkGroup(addRequest.getGroupId(), accountNo);
        // 生成长链摘要
        String originalUrlDigest = CommonUtil.MD5(addRequest.getOriginalUrl());
        // 生成短链码
        String shortLinkCode = shortLinkComponent.createShortLinkCode(addRequest.getOriginalUrl());
        // 加锁 TODO
        // 查询短链码是否存在
        ShortLinkDO ShortLinCodeDOInDB = shortLinkManager.findByShortLinkCode(shortLinkCode);
        if(ShortLinCodeDOInDB == null) {
            //构建短链对象
            if (EventMessageType.SHORT_LINK_ADD_LINK.name().equalsIgnoreCase(messageType)) {
                //C端处理
                ShortLinkDO shortLinkDO = ShortLinkDO.builder()
                        .accountNo(accountNo)
                        .code(shortLinkCode)
                        .title(addRequest.getTitle())
                        .originalUrl(addRequest.getOriginalUrl())
                        .domain(domainDO.getValue())
                        .groupId(linkGroupDO.getId())
                        .expired(addRequest.getExpired())
                        .sign(originalUrlDigest)
                        .state(ShortLinkStateEnum.ACTIVE.name())
                        .del(0)
                        .build();
                shortLinkManager.addShortLink(shortLinkDO);
                return true;
            }else if (EventMessageType.SHORT_LINK_ADD_MAPPING.name().equalsIgnoreCase(messageType)) {
                //B端处理
                GroupCodeMappingDO groupCodeMappingDO = GroupCodeMappingDO.builder()
                        .accountNo(accountNo)
                        .code(shortLinkCode)
                        .title(addRequest.getTitle())
                        .originalUrl(addRequest.getOriginalUrl())
                        .domain(domainDO.getValue())
                        .groupId(linkGroupDO.getId())
                        .expired(addRequest.getExpired())
                        .sign(originalUrlDigest)
                        .state(ShortLinkStateEnum.ACTIVE.name())
                        .del(0)
                        .build();
                //保存数据库
                groupCodeMappingManager.add(groupCodeMappingDO);
                return true;
            }
        }
        return false;
    }


    /**
     * 校验域名
     * @param domainType
     * @param domainId
     * @param accountNo
     * @return
     */
    private DomainDO checkDomain(String domainType,Long domainId,Long accountNo) {

        DomainDO domainDO;
        if (DomainTypeEnum.CUSTOM.name().equalsIgnoreCase(domainType)) {
            domainDO = domainManager.findById(domainId, accountNo);
        }else {
            domainDO = domainManager.findByDomainTypeAndID(domainId, DomainTypeEnum.OFFICIAL);
        }
        Assert.notNull(domainDO,"短链域名不合法");

        return domainDO;
    }

    /**
     * 校验组名
     *
     * @param groupId
     * @param accountNo
     * @return
     */
    private LinkGroupDO checkLinkGroup(Long groupId, Long accountNo) {

        LinkGroupDO linkGroupDO = linkGroupManager.detail(groupId, accountNo);
        Assert.notNull(linkGroupDO, "组名不合法");
        return linkGroupDO;
    }
}
```

###### 16.12.4.8.4短链码随机库表位问题

- 问题

```
MurmurHash对同个url产⽣后的值是⼀样的，但是随机拼接了库表位，最终⽣成的短链码就导致可能不⼀致的情况，怎么解决?
```

- 答案

```
MurmurHash后的短链码，拼接随机库表位需要固定。
采⽤hashCode取模⽣成对应的库表位。
```

- 编码


- ShardingDBConfig

```
package net.xdclass.strategy;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * @Description
 * @Author：刘森飚
 **/

public class ShardingDBConfig {

    /**
     * 存储数据库位置编号
     */
    private static final List<String> dbPrefixList = new ArrayList<>();

    //配置启用那些库的前缀
    static {
        dbPrefixList.add("0");
        dbPrefixList.add("1");
        dbPrefixList.add("a");
    }


    /**
     * 获取随机的前缀
     * @return
     */
    public static String getRandomDBPrefix(String code){

        //hashCode是固定的
        //在此处进行修改
        int hashCode = code.hashCode();
        int index = Math.abs(hashCode) % dbPrefixList.size();
        return dbPrefixList.get(index);
    }
}
```

- ShardingTableConfig

```
package net.xdclass.strategy;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * @Description
 * @Author：刘森飚
 **/

public class ShardingTableConfig {

    /**
     * 存储数据表位置编号
     */
    private static final List<String> tableSuffixList = new ArrayList<>();


    //配置启用那些表的后缀
    static {
        tableSuffixList.add("0");
        tableSuffixList.add("a");
    }


    /**
     * 获取随机的后缀
     * @return
     */
    public static String getRandomTableSuffix(String code){
        //hashCode是固定的
        //在此处进行修改
        int hashCode = code.hashCode();
        int index = Math.abs(hashCode) % tableSuffixList.size();
        return tableSuffixList.get(index);
    }
}
```

- ShortLinkComponent

```
package net.xdclass.component;

import net.xdclass.strategy.ShardingDBConfig;
import net.xdclass.strategy.ShardingTableConfig;
import net.xdclass.util.CommonUtil;
import org.springframework.stereotype.Component;

/**
 * @Author 刘森飚
 * @Version 1.0
 **/

@Component
public class ShortLinkComponent {

    /**
     * 62个字符
     */
    private static final String CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";


    /**
     * 生成短链码
     * @param param
     * @return
     */
    public String createShortLinkCode(String param){

        long murmurhash = CommonUtil.murmurHash32(param);
        //进制转换
        String code = encodeToBase62(murmurhash);
         //在此处进行修改
        String shortLinkCode = ShardingDBConfig.getRandomDBPrefix(code) + code + ShardingTableConfig.getRandomTableSuffix(code);


        return shortLinkCode;
    }

    /**
     * 10进制转62进制
     * @param num
     * @return
     */
    private String encodeToBase62(long num){

        // StringBuffer线程安全，StringBuilder线程不安全
        StringBuffer sb = new StringBuffer();
        do{
            int i = (int )(num%62);
            sb.append(CHARS.charAt(i));
            num = num/62;
        }while (num>0);

        String value = sb.reverse().toString();
        return value;

    }
}
```

###### 16.12.4.8.5同个URL生成不唯一短链码问题

- 问题

```
解决了随机库表问题后，⼀个URL怎么生成多个不⼀样的短链码？

URL重复生成短链问题
如果原始URL不做处理，则重复概率很高
⽅案：原始url 拼接随机串，访问前去除
```

- 答案

```
⽣产者发送消息携带⼀个时间戳或随机id

原始URL开头拼接特殊字段
原⽣ https://xdclass.net
拼接后 1469558440337604610 & https://liusenbiao.com
如果冲突，则编号递增1
访问前截取去除
```

- 编码
- CommonUtil

```
 /**
     * URL增加前缀
     * @param url
     * @return
     */
    public static String addUrlPrefix(String url){

        return IDUtil.geneSnowFlakeID()+"&"+url;

    }

    /**
     * 移除URL前缀
     * @param url
     * @return
     */
    public static String removeUrlPrefix(String url){
        String originalUrl = url.substring(url.indexOf("&")+1);
        return originalUrl;
    }

    /**
     * 如果短链码重复，则调用这个方法
     * url前缀的编号递增1
     * 如果还是用雪花算法，则容易C端和B端不一致，所以采用编号递增1的方式
     *
     * 123132432212&https://liusenbiao.com/download.html
     *
     * @param url
     * @return
     */
    public static String addUrlPrefixVersion(String url){

        //随机id
        String version = url.substring(0,url.indexOf("&"));

        //原始地址
        String originalUrl = url.substring(url.indexOf("&")+1);

        //新id
        Long newVersion = Long.parseLong(version)+1;

        String newUrl = newVersion + "&"+originalUrl;

        return newUrl;
    }
```

- ShortLinkServiceImpl

```
/**
 * 创建短链
 * @param request
 * @return
 */
@Override
public JsonData createShortLink(ShortLinkAddRequest request) {
    long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
    //在此处添加代码
    String newOriginalUrl = CommonUtil.addUrlPrefix(request.getOriginalUrl());
    request.setOriginalUrl(newOriginalUrl);
    EventMessage eventMessage = EventMessage.builder().accountNo(accountNo)
            .content(JsonUtil.obj2Json(request))
            .messageId(IDUtil.geneSnowFlakeID().toString())
            .eventMessageType(EventMessageType.SHORT_LINK_ADD.name())
            .build();
    rabbitTemplate.convertAndSend(rabbitMQConfig.getShortLinkEventExchange(),
            rabbitMQConfig.getShortLinkAddRoutingKey(),
            eventMessage);

    return JsonData.buildSuccess();
}
```

- LinkApiController

```
@GetMapping(path = "/{shortLinkCode}")
public void dispatch(@PathVariable("shortLinkCode")String shortLinkCode,
                     HttpServletRequest request, HttpServletResponse response) {

    try {
        log.info("短链码:{}", shortLinkCode);
        //判断短链码是否违规
        if (isLetterDigit(shortLinkCode)) {
            //查找短链
            ShortLinkVO shortLinkVO = shortLinkService.parseShortLinkCode(shortLinkCode);
            //判断是否过期和可用
            if (isVisitable(shortLinkVO)) {
            //在此处添加代码
                String originalUrl = CommonUtil.removeUrlPrefix(shortLinkVO.getOriginalUrl());
                response.setHeader("Location",originalUrl);
                //302跳转
                response.setStatus(HttpStatus.FOUND.value());
            } else {
                response.setStatus(HttpStatus.NOT_FOUND.value());
                return;
            }
        }
    }catch (Exception e) {
        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
    }
}
```

##### 16.12.4.9分布式锁

###### 16.12.4.9.1redis分布式锁

```
核心是保证多个指令原⼦性，加锁使⽤setnx setex 可以保证原⼦性，那解锁使⽤判断和设置等怎么保证原⼦性？
⽂档：http://www.redis.cn/commands/set.html。
多个命令的原⼦性：采⽤ lua脚本+redis, 由于【判断和删除】是lua脚本执⾏，所以要么全成功，要么全失败。
```

- 流程

```
* 先判断是否有，如没这个key，则设置key-value，配置过期时间，加锁成功。
* 如果有这个key,判断value是否是同个账号，是同个账号则返回加锁成功。
* 如果不是同个账号则加锁失败。
```

- 加⼊redis配置
- application.properties

```
#-------redis连接配置-------
spring.redis.client-type=jedis
spring.redis.host=101.200.159.132
spring.redis.password=Liu19971009
spring.redis.port=6379
spring.redis.jedis.pool.max-active=100
spring.redis.jedis.pool.max-idle=100
spring.redis.jedis.pool.min-idle=100
spring.redis.jedis.pool.max-wait=60000
```

- ShortLinkServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.component.ShortLinkComponent;
import net.xdclass.config.RabbitMQConfig;
import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.enums.DomainTypeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.DomainManager;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.manager.impl.GroupCodeMappingManagerImpl;
import net.xdclass.model.*;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.IDUtil;
import net.xdclass.util.JsonData;
import net.xdclass.util.JsonUtil;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;

import java.util.Arrays;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class ShortLinkServiceImpl implements ShortLinkService{

    @Autowired
    private ShortLinkManager shortLinkManager;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private RabbitMQConfig rabbitMQConfig;

    @Autowired
    private DomainManager domainManager;

    @Autowired
    private LinkGroupManager linkGroupManager;

    @Autowired
    private ShortLinkComponent shortLinkComponent;

    @Autowired
    private GroupCodeMappingManagerImpl groupCodeMappingManager;

    //此行添加代码
    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;

    /**
     * 处理短链新增消息
     * @param eventMessage
     * @return
     */
    @Override
    public boolean handlerAddShortLink(EventMessage eventMessage) {
        long accountNo = eventMessage.getAccountNo();
        String messageType = eventMessage.getEventMessageType();
        ShortLinkAddRequest addRequest = JsonUtil.json2Obj(eventMessage.getContent(), ShortLinkAddRequest.class);

        //判断短链域名是否合法
        DomainDO domainDO = checkDomain(addRequest.getDomainType(), addRequest.getDomainId(), accountNo);
        // 判断组名是否合法
        LinkGroupDO linkGroupDO = checkLinkGroup(addRequest.getGroupId(), accountNo);
        // 生成长链摘要
        String originalUrlDigest = CommonUtil.MD5(addRequest.getOriginalUrl());
        // 生成短链码
        String shortLinkCode = shortLinkComponent.createShortLinkCode(addRequest.getOriginalUrl());
        // 加锁
        //此行添加代码
        //key1是短链码，ARGV[1]是accountNo,ARGV[2]是过期时间
        String script = "if redis.call('EXISTS',KEYS[1])==0 then redis.call('set',KEYS[1],ARGV[1]); redis.call('expire',KEYS[1],ARGV[2]); return 1;" +
                " elseif redis.call('get',KEYS[1]) == ARGV[1] then return 2;" +
                " else return 0; end;";

        Long result = redisTemplate.execute(new
                DefaultRedisScript<>(script, Long.class), Arrays.asList(shortLinkCode), accountNo, 100);
                //C端处理
            if (EventMessageType.SHORT_LINK_ADD_LINK.name().equalsIgnoreCase(messageType)) {
                // 查询短链码是否存在
                ShortLinkDO ShortLinCodeDOInDB = shortLinkManager.findByShortLinkCode(shortLinkCode);
                ShortLinkDO shortLinkDO = ShortLinkDO.builder()
                        .accountNo(accountNo)
                        .code(shortLinkCode)
                        .title(addRequest.getTitle())
                        .originalUrl(addRequest.getOriginalUrl())
                        .domain(domainDO.getValue())
                        .groupId(linkGroupDO.getId())
                        .expired(addRequest.getExpired())
                        .sign(originalUrlDigest)
                        .state(ShortLinkStateEnum.ACTIVE.name())
                        .del(0)
                        .build();
                shortLinkManager.addShortLink(shortLinkDO);
                return true;
            }else if (EventMessageType.SHORT_LINK_ADD_MAPPING.name().equalsIgnoreCase(messageType)) {
                //B端处理
                GroupCodeMappingDO groupCodeMappingDOInDB = groupCodeMappingManager
                        .findByCodeAndGroupId(shortLinkCode, linkGroupDO.getId(), accountNo);
                GroupCodeMappingDO groupCodeMappingDO = GroupCodeMappingDO.builder()
                        .accountNo(accountNo)
                        .code(shortLinkCode)
                        .title(addRequest.getTitle())
                        .originalUrl(addRequest.getOriginalUrl())
                        .domain(domainDO.getValue())
                        .groupId(linkGroupDO.getId())
                        .expired(addRequest.getExpired())
                        .sign(originalUrlDigest)
                        .state(ShortLinkStateEnum.ACTIVE.name())
                        .del(0)
                        .build();
                //保存数据库
                groupCodeMappingManager.add(groupCodeMappingDO);
                return true;
            }
        return false;
    }


    /**
     * 校验域名
     * @param domainType
     * @param domainId
     * @param accountNo
     * @return
     */
    private DomainDO checkDomain(String domainType,Long domainId,Long accountNo) {

        DomainDO domainDO;
        if (DomainTypeEnum.CUSTOM.name().equalsIgnoreCase(domainType)) {
            domainDO = domainManager.findById(domainId, accountNo);
        }else {
            domainDO = domainManager.findByDomainTypeAndID(domainId, DomainTypeEnum.OFFICIAL);
        }
        Assert.notNull(domainDO,"短链域名不合法");

        return domainDO;
    }

    /**
     * 校验组名
     *
     * @param groupId
     * @param accountNo
     * @return
     */
    private LinkGroupDO checkLinkGroup(Long groupId, Long accountNo) {

        LinkGroupDO linkGroupDO = linkGroupManager.detail(groupId, accountNo);
        Assert.notNull(linkGroupDO, "组名不合法");
        return linkGroupDO;
    }
}
```

- GroupCodeMappingManager

```
package net.xdclass.manager;

import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.model.GroupCodeMappingDO;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-22
 */
public interface GroupCodeMappingManager {

    /**
     * 查找是否存在
     * @param shortLinkCode
     * @param groupId
     * @param accountNo
     * @return
     */
    GroupCodeMappingDO findByCodeAndGroupId(String shortLinkCode, Long groupId, long accountNo);
}
```

- GroupCodeMappingManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.manager.GroupCodeMappingManager;
import net.xdclass.mapper.GroupCodeMappingMapper;
import net.xdclass.model.GroupCodeMappingDO;
import net.xdclass.vo.GroupCodeMappingVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @Description
 * @Author:刘森飚
 **/

@Component
@Slf4j
public class GroupCodeMappingManagerImpl implements GroupCodeMappingManager {

    @Autowired
    private GroupCodeMappingMapper groupCodeMappingMapper;

    /**
     * 查找是否存在
     * @param shortLinkCode
     * @param groupId
     * @param accountNo
     * @return
     */
    @Override
    public GroupCodeMappingDO findByCodeAndGroupId(String shortLinkCode, Long groupId, long accountNo) {
        GroupCodeMappingDO groupCodeMappingDO = groupCodeMappingMapper.selectOne(new QueryWrapper<GroupCodeMappingDO>()
                .eq("code", shortLinkCode)
                .eq("account_no", accountNo)
                .eq("group_id", groupId));
        return groupCodeMappingDO;
    }
}
```

###### 16.12.4.9.2B端+C端分布式锁代码整合

- ShortLinkServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.component.ShortLinkComponent;
import net.xdclass.config.RabbitMQConfig;
import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.enums.DomainTypeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.DomainManager;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.manager.impl.GroupCodeMappingManagerImpl;
import net.xdclass.model.*;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.IDUtil;
import net.xdclass.util.JsonData;
import net.xdclass.util.JsonUtil;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class ShortLinkServiceImpl implements ShortLinkService{

    @Autowired
    private ShortLinkManager shortLinkManager;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private RabbitMQConfig rabbitMQConfig;

    @Autowired
    private DomainManager domainManager;

    @Autowired
    private LinkGroupManager linkGroupManager;

    @Autowired
    private ShortLinkComponent shortLinkComponent;

    @Autowired
    private GroupCodeMappingManagerImpl groupCodeMappingManager;

    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;


    /**
     * 处理短链新增消息
     * @param eventMessage
     * @return
     */
    @Override
    public boolean handlerAddShortLink(EventMessage eventMessage) {
        long accountNo = eventMessage.getAccountNo();
        String messageType = eventMessage.getEventMessageType();
        ShortLinkAddRequest addRequest = JsonUtil.json2Obj(eventMessage.getContent(), ShortLinkAddRequest.class);

        //判断短链域名是否合法
        DomainDO domainDO = checkDomain(addRequest.getDomainType(), addRequest.getDomainId(), accountNo);
        // 判断组名是否合法
        LinkGroupDO linkGroupDO = checkLinkGroup(addRequest.getGroupId(), accountNo);
        // 生成长链摘要
        String originalUrlDigest = CommonUtil.MD5(addRequest.getOriginalUrl());
        //短链码重复标记
        boolean duplicateCodeFlag = false;
        // 生成短链码
        String shortLinkCode = shortLinkComponent.createShortLinkCode(addRequest.getOriginalUrl());
        // 加锁
        //key1是短链码，ARGV[1]是accountNo,ARGV[2]是过期时间
        //可重入锁
        //return 0 表示加锁失败
        //return 1 表示没有人上锁，可以插入数据库
        //return 2 然后加入可重入锁(只要是同一个业务进程就行)
        String script = "if redis.call('EXISTS',KEYS[1])==0 then redis.call('set',KEYS[1],ARGV[1]); redis.call('expire',KEYS[1],ARGV[2]); return 1;" +
                " elseif redis.call('get',KEYS[1]) == ARGV[1] then return 2;" +
                " else return 0; end;";

        Long result = redisTemplate.execute(new
                DefaultRedisScript<>(script, Long.class), Arrays.asList(shortLinkCode), accountNo, 100);

        if (result > 0) {
            //加锁成功
            //C端处理
            if (EventMessageType.SHORT_LINK_ADD_LINK.name().equalsIgnoreCase(messageType)) {
                // 查询短链码是否存在
                ShortLinkDO shortLinkCodeDOInDB = shortLinkManager.findByShortLinkCode(shortLinkCode);
                if (shortLinkCodeDOInDB == null) {
                    ShortLinkDO shortLinkDO = ShortLinkDO.builder()
                            .accountNo(accountNo)
                            .code(shortLinkCode)
                            .title(addRequest.getTitle())
                            .originalUrl(addRequest.getOriginalUrl())
                            .domain(domainDO.getValue())
                            .groupId(linkGroupDO.getId())
                            .expired(addRequest.getExpired())
                            .sign(originalUrlDigest)
                            .state(ShortLinkStateEnum.ACTIVE.name())
                            .del(0)
                            .build();
                    shortLinkManager.addShortLink(shortLinkDO);
                    return true;
                }else {
                    log.error("C端短链码重复:{}",eventMessage);
                    duplicateCodeFlag = true;
                }
            }else if (EventMessageType.SHORT_LINK_ADD_MAPPING.name().equalsIgnoreCase(messageType)) {
                //B端处理
                GroupCodeMappingDO groupCodeMappingDOInDB = groupCodeMappingManager
                        .findByCodeAndGroupId(shortLinkCode, linkGroupDO.getId(), accountNo);
                if (groupCodeMappingDOInDB == null) {
                    GroupCodeMappingDO groupCodeMappingDO = GroupCodeMappingDO.builder()
                            .accountNo(accountNo)
                            .code(shortLinkCode)
                            .title(addRequest.getTitle())
                            .originalUrl(addRequest.getOriginalUrl())
                            .domain(domainDO.getValue())
                            .groupId(linkGroupDO.getId())
                            .expired(addRequest.getExpired())
                            .sign(originalUrlDigest)
                            .state(ShortLinkStateEnum.ACTIVE.name())
                            .del(0)
                            .build();
                    //保存数据库
                    groupCodeMappingManager.add(groupCodeMappingDO);
                    return true;
                }else {
                    log.error("B端短链码重复:{}",eventMessage);
                    duplicateCodeFlag = true;
                }
            }
        }else {
            //加锁失败，自旋100毫秒，再调用；
            // 失败的可能是短链码已经被占用，需要重新生成
            log.error("加锁失败:{}",eventMessage);
            try {
                TimeUnit.MILLISECONDS.sleep(100);
            } catch (InterruptedException e) {
            }
            duplicateCodeFlag = true;
        }
        if (duplicateCodeFlag) {
            String newOriginalUrl = CommonUtil.addUrlPrefixVersion(addRequest.getOriginalUrl());
            addRequest.setOriginalUrl(newOriginalUrl);
            eventMessage.setContent(JsonUtil.obj2Json(addRequest));
            log.warn("短链码报错失败，重新生成:{}", eventMessage);
            handlerAddShortLink(eventMessage);
        }
        return false;
    }


    /**
     * 校验域名
     * @param domainType
     * @param domainId
     * @param accountNo
     * @return
     */
    private DomainDO checkDomain(String domainType,Long domainId,Long accountNo) {

        DomainDO domainDO;
        if (DomainTypeEnum.CUSTOM.name().equalsIgnoreCase(domainType)) {
            domainDO = domainManager.findById(domainId, accountNo);
        }else {
            domainDO = domainManager.findByDomainTypeAndID(domainId, DomainTypeEnum.OFFICIAL);
        }
        Assert.notNull(domainDO,"短链域名不合法");

        return domainDO;
    }

    /**
     * 校验组名
     *
     * @param groupId
     * @param accountNo
     * @return
     */
    private LinkGroupDO checkLinkGroup(Long groupId, Long accountNo) {

        LinkGroupDO linkGroupDO = linkGroupManager.detail(groupId, accountNo);
        Assert.notNull(linkGroupDO, "组名不合法");
        return linkGroupDO;
    }
}
```

##### 16.12.4.10B端分库分表和链路测试

###### 16.12.4.10.1GroupCodeMapping表分库分表

- application.properties

```
server.port=8003
spring.application.name=dcloud-link

#服务注册发现
spring.cloud.nacos.discovery.server-addr=101.200.159.132:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos

#分库分表配置
spring.shardingsphere.datasource.names=ds0,ds1,dsa
spring.shardingsphere.props.sql.show=true

#ds0配置
spring.shardingsphere.datasource.ds0.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds0.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link_0?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds0.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds0.maxPoolSize=50
spring.shardingsphere.datasource.ds0.minPoolSize=50
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.datasource.ds0.password=Liu19971009



#ds1配置
spring.shardingsphere.datasource.ds1.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds1.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link_1?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds1.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds1.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds1.maxPoolSize=50
spring.shardingsphere.datasource.ds1.minPoolSize=50
spring.shardingsphere.datasource.ds1.username=root
spring.shardingsphere.datasource.ds1.password=Liu19971009


#dsa配置
spring.shardingsphere.datasource.dsa.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.dsa.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.dsa.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.dsa.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_link_a?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.dsa.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.dsa.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.dsa.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.dsa.maxPoolSize=50
spring.shardingsphere.datasource.dsa.minPoolSize=50
spring.shardingsphere.datasource.dsa.username=root
spring.shardingsphere.datasource.dsa.password=Liu19971009


#----------配置默认数据库，比如短链域名，不分库分表--------------
spring.shardingsphere.sharding.default-data-source-name=ds0
#默认id生成策略
spring.shardingsphere.sharding.default-key-generator.column=id
spring.shardingsphere.sharding.default-key-generator.type=SNOWFLAKE
spring.shardingsphere.sharding.default-key-generator.props.worker.id=${workerId}


#----------短链组，策略：水平分库，水平分表(1张表)--------------
# 先进行水平分库， 水平分库策略，行表达式分片
#配置短链分组的id生成策略
#雪花算法
spring.shardingsphere.sharding.tables.link_group.database-strategy.inline.sharding-column=account_no
spring.shardingsphere.sharding.tables.link_group.database-strategy.inline.algorithm-expression=ds$->{account_no % 2}


#----------短链，策略：分库+分表--------------
# 先进行水平分库，然后再水平分表
spring.shardingsphere.sharding.tables.short_link.database-strategy.standard.sharding-column=code
spring.shardingsphere.sharding.tables.short_link.database-strategy.standard.precise-algorithm-class-name=net.xdclass.strategy.CustomDBPreciseShardingAlgorithm


# 水平分表策略，自定义策略。   真实库.逻辑表
spring.shardingsphere.sharding.tables.short_link.actual-data-nodes=ds0.short_link,ds1.short_link,dsa.short_link
spring.shardingsphere.sharding.tables.short_link.table-strategy.standard.sharding-column=code
spring.shardingsphere.sharding.tables.short_link.table-strategy.standard.precise-algorithm-class-name=net.xdclass.strategy.CustomTablePreciseShardingAlgorithm



##---------- 组+短链码mapping表，策略：分库+分表--------------
# 先进行水平分库，然后再水平分表， 水平分库策略，行表达式分片
spring.shardingsphere.sharding.tables.group_code_mapping.database-strategy.inline.sharding-column=account_no
spring.shardingsphere.sharding.tables.group_code_mapping.database-strategy.inline.algorithm-expression=ds$->{account_no % 2}

# 分表策略+行表达式分片
spring.shardingsphere.sharding.tables.group_code_mapping.actual-data-nodes=ds$->{0..1}.group_code_mapping_$->{0..1}
spring.shardingsphere.sharding.tables.group_code_mapping.table-strategy.inline.sharding-column=group_id
spring.shardingsphere.sharding.tables.group_code_mapping.table-strategy.inline.algorithm-expression=group_code_mapping_$->{group_id % 2}



##----------rabbit配置--------------
spring.rabbitmq.host=101.200.159.132
spring.rabbitmq.port=5672
#需要手工创建虚拟主机
spring.rabbitmq.virtual-host=dev
spring.rabbitmq.username=admin
spring.rabbitmq.password=password
#消息确认方式，manual(手动ack) 和auto(自动ack)
spring.rabbitmq.listener.simple.acknowledge-mode=auto


#开启重试，消费者代码不能添加try catch捕获不往外抛异常
spring.rabbitmq.listener.simple.retry.enabled=true
#最大重试次数
spring.rabbitmq.listener.simple.retry.max-attempts=4
# 重试消息的时间间隔，5秒
spring.rabbitmq.listener.simple.retry.initial-interval=5000


#-------redis连接配置-------
spring.redis.client-type=jedis
spring.redis.host=101.200.159.132
spring.redis.password=Liu19971009
spring.redis.port=6379
spring.redis.jedis.pool.max-active=100
spring.redis.jedis.pool.max-idle=100
spring.redis.jedis.pool.min-idle=100
spring.redis.jedis.pool.max-wait=60000
```

###### 16.12.4.10.2冗余双写架构全链路测试

- 数据库检查
- 创建短链

```
{
    "groupId":1615987573979656194,
    "title":"全链路测试标题",
    "originalUrl":"liusenbiao.net?asdf=2a1",
    "domainId":1,
    "domainType":"OFFICIAL",
    "expired":-1
    
}
```

![1674825572823](短链平台项目.assets/1674825572823.png)

- 冗余双写架构测试成功

![1674825630048](短链平台项目.assets/1674825630048.png)

![1674825685482](短链平台项目.assets/1674825685482.png)

###### 16.12.4.10.3分页查找短链开发

- ShortLinkPageRequest

```
package net.xdclass.controller.request;

import lombok.Data;

import java.util.Date;

/**
 * @Description
 * @Author:刘森飚
 **/

@Data
public class ShortLinkPageRequest {


    /**
     * 组
     */
    private Long groupId;

    /**
     * 第几页
     */
    private int page;

    /**
     * 每页多少条
     */
    private int size;

}
```

- ShortLinkController

```
package net.xdclass.controller;


import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.controller.request.ShortLinkPageRequest;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/api/link/v1")
public class ShortLinkController {

    @Autowired
    private ShortLinkService shortLinkService;

    /**
     * 分页查找短链
     */

    @RequestMapping("page")
    public JsonData pageByGroupId(@RequestBody ShortLinkPageRequest request) {
        Map<String, Object> result = shortLinkService.pageByGroupId(request);
        return JsonData.buildSuccess(result);

    }
}
```

- ShortLinkService

```
package net.xdclass.service;

import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.controller.request.ShortLinkPageRequest;
import net.xdclass.model.EventMessage;
import net.xdclass.util.JsonData;
import net.xdclass.vo.ShortLinkVO;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface ShortLinkService {

    /**
     * 分页查找短链
     * @param request
     * @return
     */
    Map<String, Object> pageByGroupId(ShortLinkPageRequest request);
}
```

- ShortLinkServiceImpl

```
/**
 * 分页查找短链
 * @param request
 * @return
 */
@Override
public Map<String, Object> pageByGroupId(ShortLinkPageRequest request) {
    Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
    Map<String, Object> result = groupCodeMappingManager.pageShortLinkByGroupId(request.getPage(),
            request.getSize(), accountNo, request.getGroupId());
    return result;

}
```

- GroupCodeMappingManager

```
package net.xdclass.manager;

import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.model.GroupCodeMappingDO;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-22
 */
public interface GroupCodeMappingManager {

    /**
     * 分页查找
     * @param page
     * @param size
     * @param accountNo
     * @param groupId
     * @return
     */
    Map<String,Object> pageShortLinkByGroupId(Integer page, Integer size, Long accountNo, Long groupId);
}
```

- GroupCodeMappingManagerImpl

```
/**
 * 分页查找
 * @param page
 * @param size
 * @param accountNo
 * @param groupId
 * @return
 */
@Override
public Map<String, Object> pageShortLinkByGroupId(Integer page, Integer size, Long accountNo, Long groupId) {

    Page<GroupCodeMappingDO> pageInfo = new Page<>(page, size);

    Page<GroupCodeMappingDO> groupCodeMappingDOPage = groupCodeMappingMapper.
            selectPage(pageInfo, new QueryWrapper<GroupCodeMappingDO>()
                    .eq("account_no", accountNo)
            .eq("group_id", groupId));

    Map<String, Object> pageMap = new HashMap<>(3);

    pageMap.put("total_record", groupCodeMappingDOPage.getTotal());
    pageMap.put("total_page", groupCodeMappingDOPage.getPages());
    pageMap.put("current_data", groupCodeMappingDOPage.getRecords()
            .stream().map(obj -> beanProcess(obj)).collect(Collectors.toList()));


    return pageMap;
}


private GroupCodeMappingVO beanProcess(GroupCodeMappingDO groupCodeMappingDO) {
        GroupCodeMappingVO groupCodeMappingVO = new GroupCodeMappingVO();
        BeanUtils.copyProperties(groupCodeMappingDO, groupCodeMappingVO);

        return groupCodeMappingVO;
    }
```

![1674829246018](短链平台项目.assets/1674829246018.png)

##### 16.12.4.11冗余双写-删除更新接口开发

- 删除短链MQ架构图

![1674920281641](短链平台项目.assets/1674920281641.png)

- 更新短链MQ架构图

![1674920326743](短链平台项目.assets/1674920326743.png)

###### 16.12.4.11.1ShortLinkDelRequest

```
package net.xdclass.controller.request;

import lombok.Data;

/**
 * @Description
 * @Author:刘森飚
 **/

@Data
public class ShortLinkDelRequest {


    /**
     * 组
     */
    private Long groupId;

    /**
     * 映射id
     */
    private Long mappingId;


    /**
     * 短链码
     */
    private String code;

}
```

###### 16.12.4.11.2ShortLinkUpdateRequest

```
package net.xdclass.controller.request;

import lombok.Data;

/**
 * @Description
 * @Author:刘森飚
 **/

@Data
public class ShortLinkUpdateRequest {


    /**
     * 组
     */
    private Long groupId;

    /**
     * 映射id
     */
    private Long mappingId;

    /**
     * 短链码
     */
    private String code;


    /**
     * 标题
     */
    private String title;

    /**
     * 域名id
     */
    private Long domainId;

    /**
     * 域名类型
     */
    private String domainType;

}
```

###### 16.12.4.11.3EventMessageType

```
package net.xdclass.enums;

/**
 * @Description
 * @Author:刘森飚
 **/

public enum  EventMessageType {

    /**
     * 短链创建
     */
    SHORT_LINK_ADD,


    /**
     * 短链创建 C端
     */
    SHORT_LINK_ADD_LINK,

    /**
     * 短链创建 B端
     */
    SHORT_LINK_ADD_MAPPING,


    /**
     * 短链删除
     */
    SHORT_LINK_DEL,

    /**
     * 短链删除 C端
     */
    SHORT_LINK_DEL_LINK,

    /**
     * 短链删除 B端
     */
    SHORT_LINK_DEL_MAPPING,

    /**
     * 短链更新
     */
    SHORT_LINK_UPDATE,

    /**
     * 短链更新 C端
     */
    SHORT_LINK_UPDATE_LINK,

    /**
     * 短链更新 B端
     */
    SHORT_LINK_UPDATE_MAPPING,

}
```

###### 16.12.4.11.4RabbitMQConfig

```
package net.xdclass.config;

import lombok.Data;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Data
public class RabbitMQConfig {


    /**
     * 交换机
     */
    private String shortLinkEventExchange="short_link.event.exchange";

    /**
     * 创建交换机 Topic类型
     * 一般一个微服务一个交换机
     * @return
     */
    @Bean
    public Exchange shortLinkEventExchange(){

        return new TopicExchange(shortLinkEventExchange,true,false);
    }

    //新增短链相关配置====================================

    /**
     * 新增短链 队列
     */
    private String shortLinkAddLinkQueue="short_link.add.link.queue";

    /**
     * 新增短链映射 队列
     */
    private String shortLinkAddMappingQueue="short_link.add.mapping.queue";

    /**
     * 新增短链具体的routingKey,【发送消息使用】
     */
    private String shortLinkAddRoutingKey="short_link.add.link.mapping.routing.key";

    /**
     * topic类型的binding key，用于绑定队列和交换机，是用于 link 消费者
     */
    private String shortLinkAddLinkBindingKey="short_link.add.link.*.routing.key";

    /**
     * topic类型的binding key，用于绑定队列和交换机，是用于 mapping 消费者
     */
    private String shortLinkAddMappingBindingKey="short_link.add.*.mapping.routing.key";


    /**
     * 新增短链api队列和交换机的绑定关系建立
     */
    @Bean
    public Binding shortLinkAddApiBinding(){
        return new Binding(shortLinkAddLinkQueue,
                Binding.DestinationType.QUEUE,
                shortLinkEventExchange,shortLinkAddLinkBindingKey,
                null);
    }


    /**
     * 新增短链mapping队列和交换机的绑定关系建立
     */
    @Bean
    public Binding shortLinkAddMappingBinding(){
        return new Binding(shortLinkAddMappingQueue,
                Binding.DestinationType.QUEUE,
                shortLinkEventExchange,
                shortLinkAddMappingBindingKey,
                null);
    }


    /**
     * 新增短链api 普通队列，用于被监听
     */
    @Bean
    public Queue shortLinkAddLinkQueue(){

        return new Queue(shortLinkAddLinkQueue,true,false,false);

    }

    /**
     * 新增短链mapping 普通队列，用于被监听
     */
    @Bean
    public Queue shortLinkAddMappingQueue(){

        return new Queue(shortLinkAddMappingQueue,true,false,false);
    }



    //删除短链相关配置====================================
    /**
     * 删除短链 队列
     */
    private String shortLinkDelLinkQueue="short_link.del.link.queue";

    /**
     * 删除短链映射 队列
     */
    private String shortLinkDelMappingQueue="short_link.del.mapping.queue";

    /**
     * 删除短链具体的routingKey,【发送消息使用】
     */
    private String shortLinkDelRoutingKey="short_link.del.link.mapping.routing.key";

    /**
     * topic类型的binding key，用于绑定队列和交换机，是用于 link 消费者
     */
    private String shortLinkDelLinkBindingKey="short_link.del.link.*.routing.key";

    /**
     * topic类型的binding key，用于绑定队列和交换机，是用于 mapping 消费者
     */
    private String shortLinkDelMappingBindingKey="short_link.del.*.mapping.routing.key";


    /**
     * 删除操作  短链api队列 和交换机的绑定关系建立
     */
    @Bean
    public Binding shortLinkDelApiBinding(){
        return new Binding(shortLinkDelLinkQueue,Binding.DestinationType.QUEUE, shortLinkEventExchange,shortLinkDelLinkBindingKey,null);
    }


    /**
     * 删除操作 短链mapping队列和交换机的绑定关系建立
     */
    @Bean
    public Binding shortLinkDelMappingBinding(){
        return new Binding(shortLinkDelMappingQueue,Binding.DestinationType.QUEUE, shortLinkEventExchange,shortLinkDelMappingBindingKey,null);
    }


    /**
     * 删除操作 短链api 普通队列，用于被监听
     */
    @Bean
    public Queue shortLinkDelLinkQueue(){

        return new Queue(shortLinkDelLinkQueue,true,false,false);

    }

    /**
     * 删除操作 短链mapping 普通队列，用于被监听
     */
    @Bean
    public Queue shortLinkDelMappingQueue(){

        return new Queue(shortLinkDelMappingQueue,true,false,false);

    }



    //更新短链相关配置====================================

    /**
     * 更新短链 队列
     */
    private String shortLinkUpdateLinkQueue="short_link.update.link.queue";

    /**
     * 更新短链映射 队列
     */
    private String shortLinkUpdateMappingQueue="short_link.update.mapping.queue";

    /**
     * 更新 短链具体的routingKey,【发送消息使用】
     */
    private String shortLinkUpdateRoutingKey="short_link.update.link.mapping.routing.key";

    /**
     * topic类型的binding key，用于绑定队列和交换机，是用于 link 消费者
     */
    private String shortLinkUpdateLinkBindingKey="short_link.update.link.*.routing.key";

    /**
     * topic类型的binding key，用于绑定队列和交换机，是用于 mapping 消费者
     */
    private String shortLinkUpdateMappingBindingKey="short_link.update.*.mapping.routing.key";


    /**
     * 更新操作  短链api队列 和交换机的绑定关系建立
     */
    @Bean
    public Binding shortLinkUpdateApiBinding(){
        return new Binding(shortLinkUpdateLinkQueue,Binding.DestinationType.QUEUE, shortLinkEventExchange,shortLinkUpdateLinkBindingKey,null);
    }


    /**
     * 更新操作 短链mapping队列和交换机的绑定关系建立
     */
    @Bean
    public Binding shortLinkUpdateMappingBinding(){
        return new Binding(shortLinkUpdateMappingQueue,Binding.DestinationType.QUEUE, shortLinkEventExchange,shortLinkUpdateMappingBindingKey,null);
    }


    /**
     * 更新操作 短链api 普通队列，用于被监听
     */
    @Bean
    public Queue shortLinkUpdateLinkQueue(){

        return new Queue(shortLinkUpdateLinkQueue,true,false,false);

    }

    /**
     * 更新操作 短链mapping 普通队列，用于被监听
     */
    @Bean
    public Queue shortLinkUpdateMappingQueue(){

        return new Queue(shortLinkUpdateMappingQueue,true,false,false);

    }
}
```

###### 16.12.4.11.5ShortLinkDelLinkMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.ShortLinkService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * @author 刘森飚
 * @since 2023-01-29
 */

@Component
@Slf4j
@RabbitListener(queuesToDeclare = { @Queue("short_link.del.link.queue") })
public class ShortLinkDelLinkMQListener {

    @Autowired
    private ShortLinkService shortLinkService;

    @RabbitHandler
    public void shortLinkHandler(EventMessage eventMessage, Message message, Channel channel) throws IOException {
        log.info("监听到消息ShortLinkDelLinkMQListener message消息内容:{}",message);
        try{
            eventMessage.setEventMessageType(EventMessageType.SHORT_LINK_DEL_LINK.name());
            shortLinkService.handlerDelShortLink(eventMessage);
        }catch (Exception e){
            //处理业务异常，还有进行其他操作，比如记录失败原因
            log.error("消费失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);

    }
}
```

###### 16.12.4.11.6ShortLinkDelMappingMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.ShortLinkService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * @author 刘森飚
 * @since 2023-01-29
 */

@Component
@Slf4j
@RabbitListener(queuesToDeclare = { @Queue("short_link.del.mapping.queue") })
public class ShortLinkDelMappingMQListener {

    @Autowired
    private ShortLinkService shortLinkService;

    @RabbitHandler
    public void shortLinkHandler(EventMessage eventMessage, Message message, Channel channel) throws IOException {
        log.info("监听到消息ShortLinkDelMappingMQListener message消息内容:{}",message);
        try{
            eventMessage.setEventMessageType(EventMessageType.SHORT_LINK_DEL_MAPPING.name());
            shortLinkService.handlerDelShortLink(eventMessage);
        }catch (Exception e){
            //处理业务异常，还有进行其他操作，比如记录失败原因
            log.error("消费失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
    }
}
```

###### 16.12.4.11.7ShortLinkUpdateLinkMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.ShortLinkService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * @author 刘森飚
 * @since 2023-01-29
 */

@Component
@Slf4j
@RabbitListener(queuesToDeclare = { @Queue("short_link.update.link.queue") })
public class ShortLinkUpdateLinkMQListener {

    @Autowired
    private ShortLinkService shortLinkService;

    @RabbitHandler
    public void shortLinkHandler(EventMessage eventMessage, Message message, Channel channel) throws IOException {
        log.info("监听到消息ShortLinkUpdateLinkMQListener message消息内容:{}",message);
        try{
            eventMessage.setEventMessageType(EventMessageType.SHORT_LINK_UPDATE_LINK.name());
            shortLinkService.handlerUpdateShortLink(eventMessage);
        }catch (Exception e){
            //处理业务异常，还有进行其他操作，比如记录失败原因
            log.error("消费失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
    }
}
```

###### 16.12.4.11.8ShortLinkUpdateMappingMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.ShortLinkService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * @author 刘森飚
 * @since 2023-01-29
 */
@Component
@Slf4j
@RabbitListener(queuesToDeclare = { @Queue("short_link.update.mapping.queue") })
public class ShortLinkUpdateMappingMQListener {


    @Autowired
    private ShortLinkService shortLinkService;

    @RabbitHandler
    public void shortLinkHandler(EventMessage eventMessage, Message message, Channel channel) throws IOException {
        log.info("监听到消息ShortLinkUpdateMappingMQListener message消息内容:{}",message);
        try{
            eventMessage.setEventMessageType(EventMessageType.SHORT_LINK_UPDATE_MAPPING.name());
            shortLinkService.handlerUpdateShortLink(eventMessage);
        }catch (Exception e){

            //处理业务异常，还有进行其他操作，比如记录失败原因
            log.error("消费失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
    }
}
```

###### 16.12.4.11.9ShortLinkController

```
package net.xdclass.controller;


import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.controller.request.ShortLinkDelRequest;
import net.xdclass.controller.request.ShortLinkPageRequest;
import net.xdclass.controller.request.ShortLinkUpdateRequest;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/api/link/v1")
public class ShortLinkController {

    @Autowired
    private ShortLinkService shortLinkService;

    /**
     * 删除短链
     * @param request
     * @return
     */
    @PostMapping("del")
    public JsonData del(@RequestBody ShortLinkDelRequest request){
        JsonData jsonData = shortLinkService.del(request);
        return jsonData;
    }



    /**
     * 更新短链
     * @param request
     * @return
     */
    @PostMapping("update")
    public JsonData update(@RequestBody ShortLinkUpdateRequest request){
        JsonData jsonData = shortLinkService.update(request);
        return jsonData;
    }
}
```

###### 16.12.4.11.9.10ShortLinkService

```
package net.xdclass.service;

import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.controller.request.ShortLinkDelRequest;
import net.xdclass.controller.request.ShortLinkPageRequest;
import net.xdclass.controller.request.ShortLinkUpdateRequest;
import net.xdclass.model.EventMessage;
import net.xdclass.util.JsonData;
import net.xdclass.vo.ShortLinkVO;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
public interface ShortLinkService {
    /**
     * 删除短链
     * @param request
     * @return
     */
    JsonData del(ShortLinkDelRequest request);

    /**
     * 更新短链
     * @param request
     * @return
     */
    JsonData update(ShortLinkUpdateRequest request);
    
    /**
     * 处理短链更新消息
     * @param eventMessage
     * @return
     */
    boolean handlerUpdateShortLink(EventMessage eventMessage);

    /**
     * 处理短链删除消息
     * @param eventMessage
     * @return
     */
    boolean handlerDelShortLink(EventMessage eventMessage);
}
```

###### 16.12.4.11.9.11ShortLinkServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.component.ShortLinkComponent;
import net.xdclass.config.RabbitMQConfig;
import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.controller.request.ShortLinkDelRequest;
import net.xdclass.controller.request.ShortLinkPageRequest;
import net.xdclass.controller.request.ShortLinkUpdateRequest;
import net.xdclass.enums.DomainTypeEnum;
import net.xdclass.enums.EventMessageType;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.DomainManager;
import net.xdclass.manager.LinkGroupManager;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.manager.impl.GroupCodeMappingManagerImpl;
import net.xdclass.model.*;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.IDUtil;
import net.xdclass.util.JsonData;
import net.xdclass.util.JsonUtil;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;

import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@Service
@Slf4j
public class ShortLinkServiceImpl implements ShortLinkService{

    @Autowired
    private ShortLinkManager shortLinkManager;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private RabbitMQConfig rabbitMQConfig;

    @Autowired
    private DomainManager domainManager;

    @Autowired
    private LinkGroupManager linkGroupManager;

    @Autowired
    private ShortLinkComponent shortLinkComponent;

    @Autowired
    private GroupCodeMappingManagerImpl groupCodeMappingManager;

    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;

    /**
     * 短链删除
     * @param request
     * @return
     */
    @Override
    public JsonData del(ShortLinkDelRequest request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        EventMessage eventMessage = EventMessage.builder().accountNo(accountNo)
                .content(JsonUtil.obj2Json(request))
                .messageId(IDUtil.geneSnowFlakeID().toString())
                .eventMessageType(EventMessageType.SHORT_LINK_DEL.name())
                .build();
        rabbitTemplate.convertAndSend(rabbitMQConfig.getShortLinkEventExchange(),
                rabbitMQConfig.getShortLinkDelRoutingKey(),
                eventMessage);
        return JsonData.buildSuccess();
    }


    /**
     * 短链更新
     * @param request
     * @return
     */
    @Override
    public JsonData update(ShortLinkUpdateRequest request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        EventMessage eventMessage = EventMessage.builder().accountNo(accountNo)
                .content(JsonUtil.obj2Json(request))
                .messageId(IDUtil.geneSnowFlakeID().toString())
                .eventMessageType(EventMessageType.SHORT_LINK_UPDATE.name())
                .build();
        rabbitTemplate.convertAndSend(rabbitMQConfig.getShortLinkEventExchange(),
                rabbitMQConfig.getShortLinkUpdateRoutingKey(),
                eventMessage);
        return JsonData.buildSuccess();

    }
    
    
     /**
     * 处理短链更新消息
     * @param eventMessage
     * @return
     */
    @Override
    public boolean handlerUpdateShortLink(EventMessage eventMessage) {
        long accountNo = eventMessage.getAccountNo();
        String messageType = eventMessage.getEventMessageType();
        ShortLinkUpdateRequest request = JsonUtil.json2Obj(eventMessage.getContent(), ShortLinkUpdateRequest.class);
        //校验短链域名
        DomainDO domainDO = checkDomain(request.getDomainType(), request.getDomainId(), accountNo);
        if(EventMessageType.SHORT_LINK_UPDATE_LINK.name().equalsIgnoreCase(messageType)){
            //C端处理
            ShortLinkDO shortLinkDO = ShortLinkDO.builder()
                    .code(request.getCode())
                    .title(request.getTitle())
                    .domain(domainDO.getValue())
                    .accountNo(accountNo)
                    .build();
            int rows = shortLinkManager.update(shortLinkDO);
            log.debug("更新C端短链，rows={}",rows);
            return true;
        } else if(EventMessageType.SHORT_LINK_UPDATE_MAPPING.name().equalsIgnoreCase(messageType)){
            //B端处理
            GroupCodeMappingDO groupCodeMappingDO = GroupCodeMappingDO.builder()
                    .id(request.getMappingId())
                    .groupId(request.getGroupId())
                    .accountNo(accountNo)
                    .title(request.getTitle())
                    .domain(domainDO.getValue())
                    .build();

            int rows = groupCodeMappingManager.update(groupCodeMappingDO);
            log.debug("更新B端短链，rows={}",rows);
            return true;
        }
        return false;
    }



    /**
     * 处理短链删除消息
     * @param eventMessage
     * @return
     */
    @Override
    public boolean handlerDelShortLink(EventMessage eventMessage) {
        Long accountNo = eventMessage.getAccountNo();
        String messageType = eventMessage.getEventMessageType();
        ShortLinkDelRequest request = JsonUtil.json2Obj(eventMessage.getContent(), ShortLinkDelRequest.class);
        if(EventMessageType.SHORT_LINK_DEL_LINK.name().equalsIgnoreCase(messageType)){
        //C端解析
            ShortLinkDO shortLinkDO = ShortLinkDO.builder().code(request.getCode()).accountNo(accountNo).build();
            int rows = shortLinkManager.del(shortLinkDO);
            log.debug("删除C端短链:{}",rows);
            return true;
        }else if(EventMessageType.SHORT_LINK_DEL_MAPPING.name().equalsIgnoreCase(messageType)){
            //B端处理
            GroupCodeMappingDO groupCodeMappingDO = GroupCodeMappingDO.builder()
                    .id(request.getMappingId()).accountNo(accountNo)
                    .groupId(request.getGroupId()).build();
            int rows = groupCodeMappingManager.del(groupCodeMappingDO);
            log.debug("删除B端短链:{}",rows);
            return true;
        }
        return false;
    }
}
```
###### 16.12.4.11.9.12ShortLinkManager

```
package net.xdclass.manager;

import net.xdclass.model.ShortLinkDO;

public interface ShortLinkManager {

    /**
     * 冗余双写C端-删除操作
     * @param shortLinkDO
     * @return
     */
    int del(ShortLinkDO shortLinkDO);

    /**
     * 冗余双写C端-更新操作
     * @param shortLinkDO
     * @return
     */
    int update(ShortLinkDO shortLinkDO);
}
```

###### 16.12.4.11.9.13ShortLinkManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.ShortLinkManager;
import net.xdclass.mapper.ShortLinkMapper;
import net.xdclass.model.ShortLinkDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class ShortLinkManagerImpl implements ShortLinkManager {

    @Autowired
    private ShortLinkMapper shortLinkMapper;

    /**
     * 冗余双写C端-删除操作
     * @param shortLinkDO
     * @return
     */
    @Override
    public int del(ShortLinkDO shortLinkDO) {
        //逻辑删除
        int rows = shortLinkMapper.update(null,
                new UpdateWrapper<ShortLinkDO>()
                        .eq("code", shortLinkDO.getCode())
                        .eq("account_no", shortLinkDO.getAccountNo())
                        .set("del",1));
        return rows;
    }


    /**
     * 冗余双写C端-更新操作
     * @param shortLinkDO
     * @return
     */
    @Override
    public int update(ShortLinkDO shortLinkDO) {
        int rows = shortLinkMapper.update(null, new UpdateWrapper<ShortLinkDO>()
                .eq("code", shortLinkDO.getCode())
                .eq("del", 0)
                .eq("account_no",shortLinkDO.getAccountNo())
                .set("title", shortLinkDO.getTitle())
                .set("domain", shortLinkDO.getDomain()));

        return rows;
    }

}
```
###### 16.12.4.11.9.14GroupCodeMappingManager

```
package net.xdclass.manager;

import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.model.GroupCodeMappingDO;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-22
 */
public interface GroupCodeMappingManager {

    /**
     * 冗余双写B端-删除操作
     * @param groupCodeMappingDO
     * @return
     */
    int del(GroupCodeMappingDO groupCodeMappingDO);


    /**
     * 冗余双写B端-更新操作
     * @param groupCodeMappingDO
     * @return
     */
    int update(GroupCodeMappingDO groupCodeMappingDO);
}
```

###### 16.12.4.11.9.15GroupCodeMappingManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.ShortLinkStateEnum;
import net.xdclass.manager.GroupCodeMappingManager;
import net.xdclass.mapper.GroupCodeMappingMapper;
import net.xdclass.model.GroupCodeMappingDO;
import net.xdclass.vo.GroupCodeMappingVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @Description
 * @Author:刘森飚
 **/

@Component
@Slf4j
public class GroupCodeMappingManagerImpl implements GroupCodeMappingManager {

    @Autowired
    private GroupCodeMappingMapper groupCodeMappingMapper;


    /**
     * 查找详情
     * @param mappingId
     * @param accountNo
     * @param groupId
     * @return
     */
    @Override
    public GroupCodeMappingDO findByGroupIdAndMappingId(Long mappingId, Long accountNo, Long groupId) {

        GroupCodeMappingDO groupCodeMappingDO = groupCodeMappingMapper.selectOne(
                new QueryWrapper<GroupCodeMappingDO>()
                .eq("id", mappingId)
                .eq("account_no", accountNo)
                .eq("group_id", groupId));

        return groupCodeMappingDO;
    }


    /**
     * 新增
     * @param groupCodeMappingDO
     * @return
     */
    @Override
    public int add(GroupCodeMappingDO groupCodeMappingDO) {
        return groupCodeMappingMapper.insert(groupCodeMappingDO);
    }


    /**
     * 冗余双写B端-删除操作
     * @param groupCodeMappingDO
     * @return
     */
    @Override
    public int del(GroupCodeMappingDO groupCodeMappingDO) {

        int rows = groupCodeMappingMapper.update(null, new UpdateWrapper<GroupCodeMappingDO>()
                .eq("id", groupCodeMappingDO.getId())
                .eq("account_no", groupCodeMappingDO.getAccountNo())
                .eq("group_id", groupCodeMappingDO.getGroupId())
                .set("del", 1)
        );
        return rows;
    }


    /**
     * 分页查找
     * @param page
     * @param size
     * @param accountNo
     * @param groupId
     * @return
     */
    @Override
    public Map<String, Object> pageShortLinkByGroupId(Integer page, Integer size, Long accountNo, Long groupId) {

        Page<GroupCodeMappingDO> pageInfo = new Page<>(page, size);

        Page<GroupCodeMappingDO> groupCodeMappingDOPage = groupCodeMappingMapper.
                selectPage(pageInfo, new QueryWrapper<GroupCodeMappingDO>()
                        .eq("account_no", accountNo)
                .eq("group_id", groupId)
                .eq("del",0));

        Map<String, Object> pageMap = new HashMap<>(3);

        pageMap.put("total_record", groupCodeMappingDOPage.getTotal());
        pageMap.put("total_page", groupCodeMappingDOPage.getPages());
        pageMap.put("current_data", groupCodeMappingDOPage.getRecords()
                .stream().map(obj -> beanProcess(obj)).collect(Collectors.toList()));

        return pageMap;
    }


    /**
     * 更新短链码状态
     * @param accountNo
     * @param groupId
     * @param shortLinkCode
     * @param shortLinkStateEnum
     * @return
     */
    @Override
    public int updateGroupCodeMappingState(Long accountNo, Long groupId, String shortLinkCode, ShortLinkStateEnum shortLinkStateEnum) {

        int rows = groupCodeMappingMapper.update(null,
                new UpdateWrapper<GroupCodeMappingDO>()
                .eq("code", shortLinkCode)
                .eq("account_no", accountNo)
                .eq("group_id", groupId).eq("del",0)
                .set("state", shortLinkStateEnum.name()));

        return rows;
    }


    /**
     * 查找是否存在
     * @param shortLinkCode
     * @param groupId
     * @param accountNo
     * @return
     */
    @Override
    public GroupCodeMappingDO findByCodeAndGroupId(String shortLinkCode, Long groupId, long accountNo) {
        GroupCodeMappingDO groupCodeMappingDO = groupCodeMappingMapper.selectOne(new QueryWrapper<GroupCodeMappingDO>()
                .eq("code", shortLinkCode)
                .eq("account_no", accountNo)
                .eq("del",0)
                .eq("group_id", groupId));
        return groupCodeMappingDO;
    }



    /**
     * 冗余双写-更新操作
     * @param groupCodeMappingDO
     * @return
     */
    @Override
    public int update(GroupCodeMappingDO groupCodeMappingDO) {
        int rows = groupCodeMappingMapper.update(null, new UpdateWrapper<GroupCodeMappingDO>()
                .eq("id", groupCodeMappingDO.getId())
                .eq("account_no", groupCodeMappingDO.getAccountNo())
                .eq("group_id", groupCodeMappingDO.getGroupId())
                .eq("del", 0)
                .set("title", groupCodeMappingDO.getTitle())
                .set("domain", groupCodeMappingDO.getDomain())
        );
        return rows;
    }


    private GroupCodeMappingVO beanProcess(GroupCodeMappingDO groupCodeMappingDO) {
        GroupCodeMappingVO groupCodeMappingVO = new GroupCodeMappingVO();
        BeanUtils.copyProperties(groupCodeMappingDO, groupCodeMappingVO);

        return groupCodeMappingVO;
    }
}
```
## 17.流量包商品服务

### 17.1业务需求

![1675008773552](短链平台项目.assets/1675008773552.png)

- 流量包商品模型

```
每个套餐都是⼀个虚拟商品，没库存限制
免费版是新用户注册即可获得
不同的商品每天限制的创建的条数不⼀样
⽤户可以叠加使⽤多个流量包
```

- 业务难点

```
流量包购买⽀付(P2)
流量包管理
免费流量包管理（P1）
付费流量包管理（P1）
短链业务-流量包业务联动(P1)
```

### 17.2数据库表和实体类生成

![1675010961238](短链平台项目.assets/1675010961238.png)

- dcloud_shop.sql

```
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for product
-- ----------------------------
DROP TABLE IF EXISTS `product`;
CREATE TABLE `product` (
  `id` bigint NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '商品标题',
  `detail` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '详情',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '图片',
  `level` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '产品层级：FIRST青铜、SECOND黄金、THIRD钻石',
  `old_amount` decimal(16,0) DEFAULT NULL COMMENT '原价',
  `amount` decimal(16,0) DEFAULT NULL COMMENT '现价',
  `plugin_type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '工具类型 short_link、qrcode',
  `day_times` int DEFAULT NULL COMMENT '日次数：短链类型',
  `total_times` int DEFAULT NULL COMMENT '总次数：活码才有',
  `valid_day` int DEFAULT NULL COMMENT '有效天数',
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- ----------------------------
-- Records of product
-- ----------------------------
BEGIN;
INSERT INTO `product` VALUES (1, '青铜会员-默认', '数据查看支持||日生成短链{{dayTimes}}次||限制跳转50次||默认域名', NULL, 'FIRST', 19, 0, 'SHORT_LINK', 2, NULL, 1, '2021-10-14 17:33:44', '2021-10-11 10:49:35');
INSERT INTO `product` VALUES (2, '黄金会员-月度', '数据查看支持||日生成短链{{dayTimes}}次||限制不限制||默认域名', NULL, 'SECOND', 99, 1, 'SHORT_LINK', 5, NULL, 30, '2021-10-19 14:36:28', '2021-10-11 10:57:47');
INSERT INTO `product` VALUES (3, '黑金会员-月度', '数据查看支持||日生成短链{{dayTimes}}次||限制不限制||自定义域名', NULL, 'THIRD', 199, 2, 'SHORT_LINK', 8, NULL, 30, '2021-10-19 14:36:30', '2021-10-11 11:01:13');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
```

- MybatisPlus实体类生成

```
package net.xdclass.db;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;


public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();
        // 是否支持AR模式
        config.setActiveRecord(true)
                // 作者
                .setAuthor("刘森飚")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("C:\\Users\\18053\\Desktop")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")


                //生成基本的resultMap
                .setBaseResultMap(true)

                //实体类结尾名称
                .setEntityName("%sDO")
                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://101.200.159.132:3306/dcloud_shop?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai")
                .setUsername("root")
                .setPassword("Liu19971009");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("product");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("=======  相关代码生成完毕  ========");
    }
}
```
### 17.3项目基本骨架创建

#### 17.3.1application.properties

```
server.port=8005
spring.application.name=dcloud-shop-service

#----------服务注册和发现--------------
spring.cloud.nacos.discovery.server-addr=101.200.159.132:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos



#-------分库分表数据源配置-------
spring.shardingsphere.datasource.names=ds0
spring.shardingsphere.datasource.ds0.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds0.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_shop?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds0.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds0.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds0.maxPoolSize=50
spring.shardingsphere.datasource.ds0.minPoolSize=50
spring.shardingsphere.datasource.ds0.password=xdclass.net168
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.props.sql.show=true
```

#### 17.3.2配置拦截器

- config/InterceptorConfig

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Slf4j
public class InterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(new LoginInterceptor())
                //添加拦截的路径
                .addPathPatterns("")

                //指明不拦截哪些访问路径
                .excludePathPatterns("api/product/*/**");
    }
}
```

#### 17.3.3商品列表和详情接口开发

##### 17.3.3.1ProductVO

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import groovy.util.logging.Slf4j;
import net.xdclass.manager.ProductManager;
import net.xdclass.mapper.ProductMapper;
import net.xdclass.model.ProductDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * @Description
 * @Author 刘森飚
 **/
@Component
@Slf4j
public class ProductManagerImpl implements ProductManager {

    @Autowired
    private ProductMapper productMapper;


    /**
     * 查看商品列表
     * @return
     */
    @Override
    public List<ProductDO> list() {
        return productMapper.selectList(null);
    }


    /**
     * 查看商品详情
     * @param productId
     * @return
     */
    @Override
    public ProductDO findDetailById(long productId) {
        return productMapper.selectOne(new QueryWrapper<ProductDO>()
                .eq("id",productId));
    }
}
```

##### 17.3.3.2ProductController

```
package net.xdclass.controller;

import net.xdclass.service.ProductService;
import net.xdclass.util.JsonData;
import net.xdclass.vo.ProductVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @Description
 * @Author 刘森飚
 **/
@RestController
@RequestMapping("/api/product/v1")
public class ProductController {

    @Autowired
    private ProductService productService;


    /**
     * 查看商品列表接口
     * @return
     */
    @GetMapping("list")
    public JsonData list(){

        List<ProductVO> list = productService.list();

        return JsonData.buildSuccess(list);

    }


    /**
     * 查看商品详情
     * @param productId
     * @return
     */
    @GetMapping("detail/{product_id}")
    public JsonData detail(@PathVariable("product_id") long productId){

        ProductVO productVO = productService.findDetailById(productId);
        return JsonData.buildSuccess(productVO);
    }
}
```

##### 17.3.3.3ProductService

```
package net.xdclass.service;


import net.xdclass.vo.ProductVO;

import java.util.List;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */
public interface ProductService{

    /**
     * 查看商品列表
     * @return
     */
    List<ProductVO> list();


    /**
     * 查看商品详情
     * @param productId
     * @return
     */
    ProductVO findDetailById(long productId);

}
```

##### 17.3.3.4ProductServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.ProductManager;
import net.xdclass.model.ProductDO;
import net.xdclass.service.ProductService;
import net.xdclass.vo.ProductVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */
@Service
@Slf4j
public class ProductServiceImpl implements ProductService{

    @Autowired
    private ProductManager productManager;


    /**
     * 查看商品列表
     * @return
     */
    @Override
    public List<ProductVO> list() {

        List<ProductDO> list = productManager.list();
        List<ProductVO> collect = list.stream().map( obj ->
                beanProcess(obj) ).collect(Collectors.toList());
        return collect;
    }


    /**
     * 查看商品详情
     * @param productId
     * @return
     */
    @Override
    public ProductVO findDetailById(long productId) {
        ProductDO productDO = productManager.findDetailById(productId);
        ProductVO productVO = beanProcess(productDO);
        return productVO;
    }


    private ProductVO beanProcess(ProductDO productDO) {
        ProductVO productVO = new ProductVO();
        BeanUtils.copyProperties(productDO, productVO);
        return productVO;
    }
}
```

##### 17.3.3.5ProductManager

```
package net.xdclass.manager;

import net.xdclass.model.ProductDO;

import java.util.List;

public interface ProductManager {

    /**
     * 查看商品列表
     * @return
     */
    List<ProductDO> list();


    /**
     * 查看商品详情
     * @param productId
     * @return
     */
    ProductDO findDetailById(long productId);
}
```

##### 17.3.3.6ProductManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import groovy.util.logging.Slf4j;
import net.xdclass.manager.ProductManager;
import net.xdclass.mapper.ProductMapper;
import net.xdclass.model.ProductDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * @Description
 * @Author 刘森飚
 **/
@Component
@Slf4j
public class ProductManagerImpl implements ProductManager {

    @Autowired
    private ProductMapper productMapper;


    /**
     * 查看商品列表
     * @return
     */
    @Override
    public List<ProductDO> list() {
        return productMapper.selectList(null);
    }


    /**
     * 查看商品详情
     * @param productId
     * @return
     */
    @Override
    public ProductDO findDetailById(long productId) {
        return productMapper.selectOne(new QueryWrapper<ProductDO>()
                .eq("id",productId));
    }
}
```

### 17.4流量包订单模块

#### 17.4.1业务需求

- 需求

```
⽀持叠加购买
效果：1个流量包⽀持1天创建50条，如果买了两个则⽀持1天创建100条

⽀持多渠道⽀付
⽀付宝、微信等
```

![1675091720598](短链平台项目.assets/1675091720598.png)

#### 17.4.2数据库表和实体类生成

- product_order.sql
- 数据库分别建两张表分别是product_order_0和product_order_1

```
CREATE TABLE `product_order_0` (
  `id` bigint NOT NULL,
  `product_id` bigint DEFAULT NULL COMMENT '订单类型',
  `product_title` varchar(64) DEFAULT NULL COMMENT '商品标题',
  `product_amount` decimal(16,2) DEFAULT NULL COMMENT '商品单价',
  `product_snapshot` varchar(2048) DEFAULT NULL COMMENT '商品快照',
  `buy_num` int DEFAULT NULL COMMENT '购买数量',
  `out_trade_no` varchar(64) DEFAULT NULL COMMENT '订单唯一标识',
  `state` varchar(11) DEFAULT NULL COMMENT 'NEW 未支付订单,PAY已经支付订单,CANCEL超时取消订单',
  `create_time` datetime DEFAULT NULL COMMENT '订单生成时间',
  `total_amount` decimal(16,2) DEFAULT NULL COMMENT '订单总金额',
  `pay_amount` decimal(16,2) DEFAULT NULL COMMENT '订单实际支付价格',
  `pay_type` varchar(64) DEFAULT NULL COMMENT '支付类型，微信-银行-支付宝',
  `nickname` varchar(64) DEFAULT NULL COMMENT '账号昵称',
  `account_no` bigint DEFAULT NULL COMMENT '用户id',
  `del` int DEFAULT '0' COMMENT '0表示未删除，1表示已经删除',
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `bill_type` varchar(32) DEFAULT NULL COMMENT '发票类型：0->不开发票；1->电子发票；2->纸质发票',
  `bill_header` varchar(200) DEFAULT NULL COMMENT '发票抬头',
  `bill_content` varchar(200) DEFAULT NULL COMMENT '发票内容',
  `bill_receiver_phone` varchar(32) DEFAULT NULL COMMENT '发票收票人电话',
  `bill_receiver_email` varchar(200) DEFAULT NULL COMMENT '发票收票人邮箱',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_query` (`out_trade_no`,`account_no`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

```

![1675097149656](短链平台项目.assets/1675097149656.png)

- 数据库实体类生成

```
package net.xdclass.db;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;


public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();
        // 是否支持AR模式
        config.setActiveRecord(true)
                // 作者
                .setAuthor("刘森飚")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("C:\\Users\\18053\\Desktop")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")


                //生成基本的resultMap
                .setBaseResultMap(true)

                //实体类结尾名称
                .setEntityName("%sDO")
                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://101.200.159.132:3306/dcloud_shop?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai")
                .setUsername("root")
                .setPassword("Liu19971009");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("product_order");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("=======  相关代码生成完毕  ========");
    }
}
```

#### 17.4.3数据库表分库分表配置

##### 17.4.3.1application.properties

```
server.port=8005
spring.application.name=dcloud-shop-service

#----------服务注册和发现--------------
spring.cloud.nacos.discovery.server-addr=101.200.159.132:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos



#-------分库分表数据源配置-------
spring.shardingsphere.datasource.names=ds0
spring.shardingsphere.datasource.ds0.connectionTimeoutMilliseconds=30000
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver
spring.shardingsphere.datasource.ds0.idleTimeoutMilliseconds=60000
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://101.200.159.132:3306/dcloud_shop?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
spring.shardingsphere.datasource.ds0.maintenanceIntervalMilliseconds=30000
spring.shardingsphere.datasource.ds0.maxLifetimeMilliseconds=1800000
spring.shardingsphere.datasource.ds0.maxPoolSize=50
spring.shardingsphere.datasource.ds0.minPoolSize=50
spring.shardingsphere.datasource.ds0.password=xdclass.net168
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.props.sql.show=true



#----------配置默认数据库，比如短链域名，不分库分表--------------
spring.shardingsphere.sharding.default-data-source-name=ds0
#默认id生成策略
spring.shardingsphere.sharding.default-key-generator.column=id
spring.shardingsphere.sharding.default-key-generator.type=SNOWFLAKE
spring.shardingsphere.sharding.default-key-generator.props.worker.id=${workerId}


# 指定product_order表的数据分布情况，配置数据节点,行表达式标识符使用 ${...}
# 或 $->{...}，但前者与 Spring 本身的文件占位符冲突，所以在 Spring 环境中建议使用 $->{...}
spring.shardingsphere.sharding.tables.product_order.actual-data-nodes=ds0.product_order_$->{0..1}
#水平分表策略+行表达式分片
spring.shardingsphere.sharding.tables.product_order.table-strategy.inline.algorithm-expression=product_order_$->{ account_no % 2 }
spring.shardingsphere.sharding.tables.product_order.table-strategy.inline.sharding-column=account_no
```
#### 17.4.4Manager层CRUD接口开发

##### 17.4.4.1ProductOrderManager

```
package net.xdclass.manager;

import net.xdclass.model.ProductOrderDO;

import java.util.Map;

public interface ProductOrderManager {


    /***
     * 新增
     * @param productOrderDO
     * @return
     */
    int add(ProductOrderDO productOrderDO);


    /**
     * 通过订单号和账号查询
     * @param outTradeNo
     * @param accountNo
     * @return
     */
    ProductOrderDO findByOutTradeNoAndAccountNo(String outTradeNo, Long accountNo);


    /**
     * 更新订单状态
     * @param outTradeNo
     * @param accountNo
     * @param newState
     * @param oldState
     * @return
     */
    int updateOrderPayState(String outTradeNo, Long accountNo, String newState, String oldState);


    /**
     * 分页查看订单列表
     * @param page
     * @param size
     * @param accountNo
     * @param state
     * @return
     */
    Map<String,Object> page(int page, int size, Long accountNo, String state);
    
    
     /**
     * 删除
     * @param productOrderId
     * @param accountNo
     * @return
     */
    int del(Long productOrderId,Long accountNo);

}
```
##### 17.4.4.2ProductOrderManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import net.xdclass.manager.ProductOrderManager;
import net.xdclass.mapper.ProductOrderMapper;
import net.xdclass.model.ProductOrderDO;
import net.xdclass.vo.ProductOrderVO;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @Description
 * @Author 刘森飚
 **/

@Component
public class ProductOrderManagerImpl implements ProductOrderManager {

    @Autowired
    private ProductOrderMapper productOrderMapper;


    /***
     * 新增
     * @param productOrderDO
     * @return
     */
    @Override
    public int add(ProductOrderDO productOrderDO) {
        return productOrderMapper.insert(productOrderDO);
    }


    /**
     * 通过订单号和账号查询
     * @param outTradeNo
     * @param accountNo
     * @return
     */
    @Override
    public ProductOrderDO findByOutTradeNoAndAccountNo(String outTradeNo, Long accountNo) {
        ProductOrderDO productOrderDO = productOrderMapper.selectOne(new QueryWrapper<ProductOrderDO>()
                .eq("out_trade_no", outTradeNo)
                .eq("account_no", accountNo));
        return productOrderDO;
    }



    /**
     * 更新订单状态
     * @param outTradeNo
     * @param accountNo
     * @param newState
     * @param oldState
     * @return
     */
    @Override
    public int updateOrderPayState(String outTradeNo, Long accountNo, String newState, String oldState) {

        int rows = productOrderMapper.update(null, new UpdateWrapper<ProductOrderDO>()
                .eq("out_trade_no", outTradeNo)
                .eq("account_no", accountNo)
                .eq("state", oldState)
                .set("state", newState));

        return rows;
    }



    /**
     * 分页查看订单列表
     * @param page
     * @param size
     * @param accountNo
     * @param state
     * @return
     */
    @Override
    public Map<String, Object> page(int page, int size, Long accountNo, String state) {
        Page<ProductOrderDO> pageInfo = new Page<>(page, size);
        IPage<ProductOrderDO> orderDOIPage;
        if (StringUtils.isBlank(state)) {
            orderDOIPage = productOrderMapper.selectPage(pageInfo,
                    new QueryWrapper<ProductOrderDO>()
                            .eq("account_no", accountNo));
        } else {
            orderDOIPage = productOrderMapper.selectPage(pageInfo, new QueryWrapper<ProductOrderDO>()
                    .eq("account_no", accountNo)
                    .eq("state", state));
        }
        List<ProductOrderDO> orderDOIPageRecords = orderDOIPage.getRecords();
        List<ProductOrderVO> productOrderVOList = orderDOIPageRecords.stream().map(obj -> {
            ProductOrderVO productOrderVO = new ProductOrderVO();
            BeanUtils.copyProperties(obj, productOrderVO);
            return productOrderVO;
        }).collect(Collectors.toList());

        Map<String,Object> pageMap = new HashMap<>(3);
        pageMap.put("total_record",orderDOIPage.getTotal());
        pageMap.put("total_page",orderDOIPage.getPages());
        pageMap.put("current_data",productOrderVOList);
        return pageMap;
    }
    
    
     /**
     * 删除(逻辑删除)
     * @param productOrderId
     * @param accountNo
     * @return
     */
    @Override
    public int del(Long productOrderId, Long accountNo) {
        int rows = productOrderMapper.update(null, new UpdateWrapper<ProductOrderDO>()
                .eq("id", productOrderId)
                .eq("account_no", accountNo)
                .set("del", 1));
        return rows;
    }
}
```
#### 17.4.5下单分页和订单状态接口开发

**需要开发三个接口**

- 分页接口开发
- 订单状态查询接口（扫码⽀付-订单状态检查）
- 下单接口(支付宝支付返回HTML，微信⽀付返回JSON)
- 流程

```
防重提交（重点）
获取最新的流量包价格
订单验价
如果有优惠券或者其他抵扣
验证前端显示和后台计算价格
创建订单对象保存数据库
发送延迟消息-用于自动关单（重点）
创建⽀付信息-对接三方支付（重点）
回调更新订单状态（重点）
⽀付成功创建流量包（重点）
```

##### 17.4.5.1ConfirmOrderRequest

```
package net.xdclass.controller.request;

import lombok.Data;

import java.math.BigDecimal;
import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */

@Data
public class ConfirmOrderRequest {

    /**
     * 商品id
     */
    private Long productId;


    /**
     * 购买数量
     */
    private Integer buyNum;;


    /**
     * 终端类型
     */
    private String clientType;


    /**
     * 支付类型，微信-银行-支付宝
     */
    private String payType;


    /**
     * 订单总金额
     */
    private BigDecimal totalAmount;

    /**
     * 订单实际支付价格
     */
    private BigDecimal payAmount;


    /**
     * 防重令牌
     */
    private String token;


    /**
     * 发票类型：0->不开发票；1->电子发票；2->纸质发票
     */
    private String billType;

    /**
     * 发票抬头
     */
    private String billHeader;

    /**
     * 发票内容
     */
    private String billContent;

    /**
     * 发票收票人电话
     */
    private String billReceiverPhone;

    /**
     * 发票收票人邮箱
     */
    private String billReceiverEmail;
}
```

##### 17.4.5.2ClientTypeEnum

```
package net.xdclass.enums;


/**
 * @author 刘森飚
 * @since 2023-01-30
 */

public enum ClientTypeEnum {

    /**
     * app支付
     */
    APP,

    /**
     * PC网页
     */
    PC,

    /**
     * 移动端H5
     */
    H5;
}
```

##### 17.4.5.3ProductOrderPayTypeEnum

```
package net.xdclass.enums;


/**
 * @author 刘森飚
 * @since 2023-01-30
 */

public enum ProductOrderPayTypeEnum {

    /**
     * 微信支付
     */
    WECHAT_APY,

    /**
     * 支付宝支付
     */
    ALI_PAY,

    /**
     * 银行卡支付
     */
    BANK;
}
```

##### 17.4.5.4CommonUtil

```
/**
 * 响应HTML数据给前端
 *
 * @param response
 * @param JsonData jsonData
 */
public static void sendHtmlMessage(HttpServletResponse response, JsonData jsonData) {
    response.setContentType("text/html; charset=utf-8");
    try (PrintWriter writer = response.getWriter()) {
        writer.write(jsonData.getData().toString());
        writer.flush();
    } catch (IOException e) {
        log.warn("响应json数据给前端异常:{}", e);
    }
}
```

##### 17.4.5.5BillTypeEnum

```
package net.xdclass.enums;


/**
 * @author 刘森飚
 * @since 2023-01-30
 */

public enum BillTypeEnum {

    /**
     * 不用发票
     */
    NO_BILL,

    /**
     * 纸质发票
     */
    PAPER_BILL,

    /**
     * 电子发票
     */
    ELE_BILL;
}
```

##### 17.4.5.6ProductOrderStateEnum

```
package net.xdclass.enums;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */

public enum ProductOrderStateEnum {

    /**
     * 未支付
     */
    NEW,

    /**
     * 已经支付
     */
    PAY,

    /**
     * 超时取消
     */
    CANCEL;
}
```

##### 17.4.5.7TimeConstant

```
package net.xdclass.constant;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */

public class TimeConstant {

    /**
     * 默认30分钟超时未支付，单位毫秒
     */
    public static final long ORDER_PAY_TIMEOUT_MILLS =1000 * 60 * 30;

}
```

##### 17.4.5.8ProductOrderVO

```
package net.xdclass.vo;

import lombok.Data;
import lombok.EqualsAndHashCode;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */

@Data
@EqualsAndHashCode(callSuper = false)
public class ProductOrderVO implements Serializable {


    private Long id;

    /**
     * 订单类型
     */
    private Long productId;

    /**
     * 商品标题
     */
    private String productTitle;

    /**
     * 商品单价
     */
    private BigDecimal productAmount;

    /**
     * 商品快照
     */
    private String productSnapshot;

    /**
     * 购买数量
     */
    private Integer buyNum;

    /**
     * 订单唯一标识
     */
    private String outTradeNo;

    /**
     * NEW 未支付订单,PAY已经支付订单,CANCEL超时取消订单
     */
    private String state;

    /**
     * 订单生成时间
     */
    private Date createTime;

    /**
     * 订单总金额
     */
    private BigDecimal totalAmount;

    /**
     * 订单实际支付价格
     */
    private BigDecimal payAmount;

    /**
     * 支付类型，微信-银行-支付宝
     */
    private String payType;

    /**
     * 账号昵称
     */
    private String nickname;

    /**
     * 用户id
     */
    private Long accountNo;

    /**
     * 0表示未删除，1表示已经删除
     */
    private Integer del;

    /**
     * 更新时间
     */
    private Date gmtModified;

    /**
     * 创建时间
     */
    private Date gmtCreate;

    /**
     * 发票类型：0->不开发票；1->电子发票；2->纸质发票
     */
    private String billType;

    /**
     * 发票抬头
     */
    private String billHeader;

    /**
     * 发票内容
     */
    private String billContent;

    /**
     * 发票收票人电话
     */
    private String billReceiverPhone;

    /**
     * 发票收票人邮箱
     */
    private String billReceiverEmail;


}
```

##### 17.4.5.9PayInfoVO

```
package net.xdclass.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class PayInfoVO {

    /**
     * 订单号
     */
    private String outTradeNo;

    /**
     * 订单总金额 单位是分
     */
    private BigDecimal payFee;

    /**
     *支付类型，微信、支付宝
     */
    private String payType;

    /**
     * 端类型，App/h5/pc
     */
    private String clientType;

    /**
     * 标题
     */
    private String title;

    /**
     * 详情
     */
    private String description;

    /**
     * 订单支付超时，毫秒
     */
    private Long orderPayTimeoutMills;

    /**
     * 用户标识
     */
    private Long accountNo;
}
```

##### 17.4.5.10ProductOrderController

```
package net.xdclass.controller;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.controller.request.ConfirmOrderRequest;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.ClientTypeEnum;
import net.xdclass.enums.ProductOrderPayTypeEnum;
import net.xdclass.service.ProductOrderService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JsonData;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletResponse;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */


@RestController
@RequestMapping("/api/order/v1")
@Slf4j
public class ProductOrderController {


    @Autowired
    private ProductOrderService productOrderService;


    /**
     * 分页接口
     * @return
     */
    @GetMapping("page")
    public JsonData page(
            @RequestParam(value = "page", defaultValue = "1") int page,
            @RequestParam(value = "size", defaultValue = "10") int size,
            @RequestParam(value = "state", required = false) String state
    ) {
        Map<String, Object> pageResult = productOrderService.page(page, size, state);
        return JsonData.buildSuccess(pageResult);
    }


    /**
     * 查询订单状态
     * @param outTradeNo
     * @return
     */
    @GetMapping("query_state")
    public JsonData queryState(@RequestParam(value = "out_trade_no") String outTradeNo) {
        String state = productOrderService.queryProductOrderState(outTradeNo);
        return StringUtils.isBlank(state) ?
                JsonData.buildResult(BizCodeEnum.ORDER_CONFIRM_NOT_EXIST) : JsonData.buildSuccess(state);
    }


    /**
     * 下单接口
     * @param orderRequest
     * @param response
     */
    @PostMapping("confirm")
    public void confirmOrder(@RequestBody ConfirmOrderRequest orderRequest, HttpServletResponse response) {
        JsonData jsonData = productOrderService.confirmOrder(orderRequest);
        if (jsonData.getCode() == 0) {
            //支付成功
            //端类型
            String client = orderRequest.getClientType();
            //支付类型
            String payType = orderRequest.getPayType();
            //如果是支付宝支付，跳转网页，sdk除外
            if (payType.equalsIgnoreCase(ProductOrderPayTypeEnum.ALI_PAY.name())) {
                if (client.equalsIgnoreCase(ClientTypeEnum.PC.name())) {
                    CommonUtil.sendHtmlMessage(response, jsonData);
                } else if (client.equalsIgnoreCase(ClientTypeEnum.APP.name())) {

                } else if (client.equalsIgnoreCase(ClientTypeEnum.H5.name())) {

                }
            } else if (payType.equalsIgnoreCase(ProductOrderPayTypeEnum.WECHAT_APY.name())) {
                //微信支付
                CommonUtil.sendJsonMessage(response, jsonData);
            }
        } else {
            //支付失败
            log.error("创建订单失败{}", jsonData.toString());
            CommonUtil.sendJsonMessage(response, jsonData);
        }
    }
}
```

##### 17.4.5.11ProductOrderService

```
package net.xdclass.service;

import net.xdclass.controller.request.ConfirmOrderRequest;
import net.xdclass.util.JsonData;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */

public interface ProductOrderService {

    /**
     * 分页接口
     * @param page
     * @param size
     * @param state
     * @return
     */
    Map<String,Object> page(int page, int size, String state);

    /**
     * 查询订单状态
     * @param outTradeNo
     * @return
     */
    String queryProductOrderState(String outTradeNo);


    /**
     * 下单接口
     * @param orderRequest
     */
    JsonData confirmOrder(ConfirmOrderRequest orderRequest);
}
```

##### 17.4.5.12ProductOrderServiceImpl

```
package net.xdclass.service.impl;

import net.xdclass.controller.request.ConfirmOrderRequest;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.manager.ProductOrderManager;
import net.xdclass.model.ProductOrderDO;
import net.xdclass.service.ProductOrderService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */

@Service
public class ProductOrderServiceImpl implements ProductOrderService {

    @Autowired
    private ProductOrderManager productOrderManager;


    /**
     * 分页接口开发
     * @param page
     * @param size
     * @param state
     * @return
     */
    @Override
    public Map<String, Object> page(int page, int size, String state) {

        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();

        Map<String, Object> pageResult  = productOrderManager.page(page, size, accountNo, state);
        return pageResult;
    }


    /**
     * 查询订单状态
     * @param outTradeNo
     * @return
     */
    @Override
    public String queryProductOrderState(String outTradeNo) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();

        ProductOrderDO productOrderDO = productOrderManager.findByOutTradeNoAndAccountNo(outTradeNo, accountNo);
        if(productOrderDO == null){
            return "";
        }else {
            return productOrderDO.getState();
        }
    }


    /**
     *  重防复提交（TODO）
     *  获取最新的流量包价格
     *  订单验价
     *    如果有优惠券或者其他抵扣
     *    验证前端显示和后台计算价格
     * 创建订单对象保存数据库
     * 发送延迟消息-用于自动关单（TODO）
     * 创建支付信息-对接三方支付（TODO）
     * 回调更新订单状态（TODO）
     * 支付成功创建流量包（TODO）
     * @param orderRequest
     * @return
     */
    @Override
    public JsonData confirmOrder(ConfirmOrderRequest orderRequest) {
        //获取登录得用户
        LoginUser loginUser = LoginInterceptor.threadLocal.get();
        //生成订单号
        String orderOutTradeNo = CommonUtil.getStringNumRandom(32);
        //拿到最新得商品信息
        ProductDO productDO = productManager.findDetailById(orderRequest.getProductId());
        //验证价格
        this.checkPrice(productDO,orderRequest);
        //创建订单
        ProductOrderDO productOrderDO = this.saveProductOrder(orderRequest,loginUser,orderOutTradeNo,productDO);
        //创建支付对象
        PayInfoVO payInfoVO = PayInfoVO.builder()
                .accountNo(loginUser.getAccountNo())
                .outTradeNo(orderOutTradeNo)
                .clientType(orderRequest.getClientType())
                .payType(orderRequest.getPayType())
                .title(productDO.getTitle())
                .description("")
                .payFee(orderRequest.getPayAmount())
                .orderPayTimeoutMills(TimeConstant.ORDER_PAY_TIMEOUT_MILLS)
                .build();

        //发送延迟消息  TODO


        //调用支付信息 TODO
        return null;
    }


    /**
     * 后端验证价格
     * @param productDO
     * @param orderRequest
     */
    private void checkPrice(ProductDO productDO, ConfirmOrderRequest orderRequest) {
        //后端计算价格
        BigDecimal bizTotal = BigDecimal.valueOf(orderRequest.getBuyNum()).multiply(productDO.getAmount());
        //前端传递总价和后端计算总价格是否一致, 如果有优惠券，也在这里进行计算
        if( bizTotal.compareTo(orderRequest.getPayAmount()) != 0 ){
            log.error("验证价格失败{}",orderRequest);
            throw new BizException(BizCodeEnum.ORDER_CONFIRM_PRICE_FAIL);
        }
    }


    /**
     * 创建订单
     * @param orderRequest
     * @param loginUser
     * @param orderOutTradeNo
     * @param productDO
     * @return
     */
    private ProductOrderDO saveProductOrder(ConfirmOrderRequest orderRequest, LoginUser loginUser, String orderOutTradeNo, ProductDO productDO) {
        ProductOrderDO productOrderDO = new ProductOrderDO();
        //设置用户信息
        productOrderDO.setAccountNo(loginUser.getAccountNo());
        productOrderDO.setNickname(loginUser.getUsername());


        //设置商品信息
        productOrderDO.setProductId(productDO.getId());
        productOrderDO.setProductTitle(productDO.getTitle());
        productOrderDO.setProductSnapshot(JsonUtil.obj2Json(productDO));
        productOrderDO.setProductAmount(productDO.getAmount());

        //设置订单信息
        productOrderDO.setBuyNum(orderRequest.getBuyNum());
        productOrderDO.setOutTradeNo(orderOutTradeNo);
        productOrderDO.setCreateTime(new Date());
        productOrderDO.setDel(0);

        //发票信息
        productOrderDO.setBillType(BillTypeEnum.valueOf(orderRequest.getBillType()).name());
        productOrderDO.setBillHeader(orderRequest.getBillHeader());
        productOrderDO.setBillReceiverPhone(orderRequest.getBillReceiverPhone());
        productOrderDO.setBillReceiverEmail(orderRequest.getBillReceiverEmail());
        productOrderDO.setBillContent(orderRequest.getBillContent());


        //实际支付总价
        productOrderDO.setPayAmount(orderRequest.getPayAmount());
        //总价，没使用优惠券
        productOrderDO.setTotalAmount(orderRequest.getTotalAmount());
        //订单状态
        productOrderDO.setState(ProductOrderStateEnum.NEW.name());
        //支付类型
        productOrderDO.setPayType(ProductOrderPayTypeEnum.valueOf(orderRequest.getPayType()).name());

        //插入数据库
        productOrderManager.add(productOrderDO);
        return productOrderDO;
    }
}
```
#### 17.4.6多场景自定义注解-防重提交

##### 17.4.6.1自定义注解基础

- Annotation(注解)

```
从JDK 1.5开始, Java增加了对元数据(MetaData)的⽀持，也就是Annotation(注解)。
注解其实就是代码⾥的特殊标记，它⽤于替代配置⽂件。
常见的很多 @Override、@Deprecated等。
```

- 什么是元注解

```
注解的注解，⽐如当我们需要⾃定义注解时
会需要⼀些元注解（meta-annotation），如@Target和@Retention
```

- java内置4种元注解

```
@Target表示该注解用于什么地方
ElementType.CONSTRUCTOR ⽤在构造器
ElementType.FIELD ⽤于描述域-属性上
ElementType.METHOD ⽤在⽅法上
ElementType.TYPE ⽤在类或接口上
ElementType.PACKAGE ⽤于描述包

@Retention 表示在什么级别保存该注解信息
RetentionPolicy.SOURCE 保留到源码上
RetentionPolicy.CLASS 保留到字节码上
RetentionPolicy.RUNTIME 保留到虚拟机运⾏时（最多可通过反射获取）
@Documented 将此注解包含在 javadoc 中
@Inherited 是否允许⼦类继承⽗类中的注解

@interface
⽤来声明⼀个注解，可以通过default来声明参数的默认值
⾃定义注解时，⾃动继承了java.lang.annotation.Annotation接口
通过反射可以获取⾃定义注解
```

##### 17.4.6.2自定义注解开发防重提交

- 防重提交方式

```
token令牌方式
ip+类+方法方式
```

- 利用AOP

```
Aspect Oriented Program ⾯向切⾯编程， 在不改变原有逻辑上增加额外的功能
AOP思想把功能分两个部分，分离系统中的各种关注点
好处
减少代码侵⼊，解耦
可以统⼀处理横切逻辑
⽅便添加和删除横切逻辑
```

- 业务流程

![1675250467276](短链平台项目.assets/1675250467276.png)

###### 17.4.6.2.1RepeatSubmit

```
package net.xdclass.annotation;

import java.lang.annotation.*;

/**
 * 自定义防重提交
 * @author:刘森飚
 */
@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RepeatSubmit {


    /**
     * 防重提交，支持两种，一个是方法参数，一个是令牌
     */
    enum Type { PARAM, TOKEN }

    /**
     * 默认防重提交，是方法参数
     * @return
     */
    Type limitType() default Type.PARAM;


    /**
     * 加锁过期时间，默认是5秒
     * @return
     */
    long lockTime() default 5;

}
```

###### 17.4.6.2.2自定义注解开发-Token令牌方式

- 新增redis配置
- application.properties

```
#-------redis连接配置-------
spring.redis.client-type=jedis
spring.redis.host=101.200.159.132
spring.redis.password=Liu19971009
spring.redis.port=6379
spring.redis.jedis.pool.max-active=100
spring.redis.jedis.pool.max-idle=100
spring.redis.jedis.pool.min-idle=100
spring.redis.jedis.pool.max-wait=60000
```

- 编写接口获取令牌

```
package net.xdclass.controller;


import lombok.extern.slf4j.Slf4j;
import net.xdclass.constant.RedisKey;
import net.xdclass.controller.request.ConfirmOrderRequest;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.enums.ClientTypeEnum;
import net.xdclass.enums.ProductOrderPayTypeEnum;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.service.ProductOrderService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JsonData;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletResponse;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * @author 刘森飚
 * @since 2023-01-30
 */


@RestController
@RequestMapping("/api/order/v1")
@Slf4j
public class ProductOrderController {


    @Autowired
    private ProductOrderService productOrderService;

    @Autowired
    private StringRedisTemplate redisTemplate;



    /**
     * 下单前获取令牌用于防重提交
     * @return
     */
    @GetMapping("token")
    public JsonData getOrderToken(){
        long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        String token = CommonUtil.getStringNumRandom(32);
        String key = String.format(RedisKey.SUBMIT_ORDER_TOKEN_KEY,accountNo,token);
        //令牌有效时间是30分钟
        redisTemplate.opsForValue()
                .set(key, String.valueOf(Thread.currentThread().getId()),30, TimeUnit.MINUTES);
        return JsonData.buildSuccess(token);
    }
}
```

- RedisKey

```
package net.xdclass.constant;


/**
 * @author 刘森飚
 * @since 2023-01-30
 */

public class RedisKey {
    /**
     * 验证码缓存key，第一个是类型,第二个是唯一标识比如手机号或者邮箱
     */
    public static final String CHECK_CODE_KEY = "code:%s:%s";


    /**
     * 提交订单令牌的缓存key,第一个是账号，第二个是token
     */
    public static final String SUBMIT_ORDER_TOKEN_KEY = "order:submit:%s:%s";
}
```

- 定义切面类-开发解析器

```
package net.xdclass.aspect;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.annotation.RepeatSubmit;
import net.xdclass.constant.RedisKey;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.interceptor.LoginInterceptor;
import org.apache.commons.lang3.StringUtils;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;

/**
 * @author 刘森飚
 * descript:定义一个切面类
 * @since 2023-02-01
 */


@Aspect
@Component
@Slf4j
public class RepeatSubmitAspect {


    @Autowired
    private StringRedisTemplate redisTemplate;


    /**
     * 定义 @Pointcut注解表达式，
     * 方式一：@annotation：当执行的方法上拥有指定的注解时生效（我们采用这）
     * 方式二：execution：一般用于指定方法的执行
     */
    @Pointcut("@annotation(repeatSubmit)")
    public void pointCutNoRepeatSubmit(RepeatSubmit repeatSubmit) {

    }


    /**
     * 环绕通知, 围绕着方法执行
     *
     * @param joinPoint
     * @return
     * @throws Throwable
     * @Around 可以用来在调用一个具体方法前和调用后来完成一些具体的任务。
     * 方式一：单用 @Around("execution(* net.xdclass.controller.*.*(..))")可以
     * 方式二：用@Pointcut和@Around联合注解也可以（我们采用这个）
     *
     * 两种方式
     * 方式一：加锁 固定时间内不能重复提交
     * 方式二：先请求获取token，这边再删除token,删除成功则是第一次提交
     */
    @Around("pointCutNoRepeatSubmit(repeatSubmit)")
    public Object around(ProceedingJoinPoint joinPoint, RepeatSubmit repeatSubmit) throws Throwable {
        //拿到前端传来的请求
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder
                .getRequestAttributes()).getRequest();

        long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        //用于记录成功或者失败
        boolean res = false;
        //防重提交类型
        String type = repeatSubmit.limitType().name();
        if(type.equalsIgnoreCase(RepeatSubmit.Type.PARAM.name())){
            //方式一，参数形式防重提交 TODO
        }else {
            //方式二，令牌形式防重提交
            String requestToken = request.getHeader("request-token");
            if(StringUtils.isBlank(requestToken)){
                throw new BizException(BizCodeEnum.ORDER_CONFIRM_TOKEN_EQUAL_FAIL);
            }
            String key = String.format(RedisKey.SUBMIT_ORDER_TOKEN_KEY,accountNo,requestToken);
            /**
             * 提交表单的token key
             * 方式一：不用lua脚本获取再判断，之前是因为 key组成是 order:submit:accountNo,
             * value是对应的token，所以需要先获取值，再判断
             * 方式二：可以直接key是 order:submit:accountNo:token,然后直接删除成功则完成
             */
            res = redisTemplate.delete(key);
        }
        if(!res){
            //订单重复提交
            throw new BizException(BizCodeEnum.ORDER_CONFIRM_REPEAT);
        }
        log.info("环绕通知执行前");
        //订单没有重复提交，继续向下处理
        Object obj = joinPoint.proceed();
        log.info("环绕通知执行后");
        return obj;
    }
}
```

###### 17.4.6.2.3自定义注解开发-参数式

- RepeatSubmitAspect

```
package net.xdclass.aspect;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.annotation.RepeatSubmit;
import net.xdclass.constant.RedisKey;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.util.CommonUtil;
import org.apache.commons.lang3.StringUtils;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;

/**
 * @author 刘森飚
 * descript:定义一个切面类
 * @since 2023-02-01
 */


@Aspect
@Component
@Slf4j
public class RepeatSubmitAspect {


    @Autowired
    private StringRedisTemplate redisTemplate;


    /**
     * 定义 @Pointcut注解表达式，
     * 方式一：@annotation：当执行的方法上拥有指定的注解时生效（我们采用这）
     * 方式二：execution：一般用于指定方法的执行
     */
    @Pointcut("@annotation(repeatSubmit)")
    public void pointCutNoRepeatSubmit(RepeatSubmit repeatSubmit) {

    }


    /**
     * 环绕通知, 围绕着方法执行
     *
     * @param joinPoint
     * @throws Throwable
     * @Around 可以用来在调用一个具体方法前和调用后来完成一些具体的任务。
     * 方式一：单用 @Around("execution(* net.xdclass.controller.*.*(..))")可以
     * 方式二：用@Pointcut和@Around联合注解也可以（我们采用这个）
     *
     * 两种方式
     * 方式一：加锁 固定时间内不能重复提交
     * 方式二：先请求获取token，这边再删除token,删除成功则是第一次提交
     */
    @Around("pointCutNoRepeatSubmit(repeatSubmit)")
    public Object around(ProceedingJoinPoint joinPoint, RepeatSubmit repeatSubmit) throws Throwable {
        //拿到前端传来的请求
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder
                .getRequestAttributes()).getRequest();

        long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        //用于记录成功或者失败
        boolean res = false;
        //防重提交类型
        String type = repeatSubmit.limitType().name();
        if(type.equalsIgnoreCase(RepeatSubmit.Type.PARAM.name())){
            //方式一，参数形式防重提交
            //拿到加锁时间
            long lockTime = repeatSubmit.lockTime();
            //拿到ip地址
            String ipAddr = CommonUtil.getIpAddr(request);
            //拿到方法签名
            MethodSignature methodSignature = (MethodSignature)joinPoint.getSignature();
            //拿到方法名
            Method method = methodSignature.getMethod();
            //拿到类名
            String className = method.getDeclaringClass().getName();
            //拿到唯一key
            String key = String.format("%s-%s-%s-%s",ipAddr,className,method,accountNo);
            //加锁
            res  = redisTemplate.opsForValue().setIfAbsent(key, "1", lockTime, TimeUnit.SECONDS);

        }else {
            //方式二，令牌形式防重提交
            String requestToken = request.getHeader("request-token");
            if(StringUtils.isBlank(requestToken)){
                throw new BizException(BizCodeEnum.ORDER_CONFIRM_TOKEN_EQUAL_FAIL);
            }
            String key = String.format(RedisKey.SUBMIT_ORDER_TOKEN_KEY,accountNo,requestToken);
            /**
             * 提交表单的token key
             * 方式一：不用lua脚本获取再判断，之前是因为 key组成是 order:submit:accountNo,
             * value是对应的token，所以需要先获取值，再判断
             * 方式二：可以直接key是 order:submit:accountNo:token,然后直接删除成功则完成
             */
            res = redisTemplate.delete(key);
        }
        if(!res){
            //订单重复提交
            throw new BizException(BizCodeEnum.ORDER_CONFIRM_REPEAT);
        }
        log.info("环绕通知执行前");
        //订单没有重复提交，继续向下处理
        Object obj = joinPoint.proceed();
        log.info("环绕通知执行后");
        return obj;
    }
}
```

###### 17.4.6.2.4 Redission分布式锁

- Redission介绍

```
是⼀个在Redis的基础上实现的Java驻内存数据⽹格，⽀持多样Redis配置⽀持、丰富连接⽅式、分布式对象、分布式集
合、分布式锁、分布式服务、多种序列化⽅式、三⽅框架整合。
Redisson底层采⽤的是Netty框架
官⽅⽂档：https://github.com/redisson/redisson
```

- 配置加⼊


- common工程加入

```
<!--redisson分布式锁-->
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
</dependency>
```

- RedissionConfiguration

```
package net.xdclass.config;

import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/
@Configuration
public class RedissionConfiguration {


    @Value("${spring.redis.host}")
    private String redisHost;


    @Value("${spring.redis.port}")
    private String redisPort;


    @Value("${spring.redis.password}")
    private String redisPwd;



    /**
     * 配置分布式锁的redisson
     * @return
     */
    @Bean
    public RedissonClient redissonClient(){
        Config config = new Config();

        //单机方式
        config.useSingleServer().setPassword(redisPwd).setAddress("redis://"+redisHost+":"+redisPort);

        //集群
        //config.useClusterServers().addNodeAddress("redis://192.31.21.1:6379","redis://192.31.21.2:6379")

        RedissonClient redissonClient = Redisson.create(config);
        return redissonClient;
    }

    /**
     * 集群模式
     * 备注：可以用"rediss://"来启用SSL连接
     */
    /*@Bean
    public RedissonClient redissonClusterClient() {
        Config config = new Config();
        config.useClusterServers().setScanInterval(2000) // 集群状态扫描间隔时间，单位是毫秒
              .addNodeAddress("redis://127.0.0.1:7000")
              .addNodeAddress("redis://127.0.0.1:7002");
        RedissonClient redisson = Redisson.create(config);
        return redisson;
    }*/
}
```

- RepeatSubmitAspect

```
package net.xdclass.aspect;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.annotation.RepeatSubmit;
import net.xdclass.constant.RedisKey;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.util.CommonUtil;
import org.apache.commons.lang3.StringUtils;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;

/**
 * @author 刘森飚
 * descript:定义一个切面类
 * @since 2023-02-01
 */


@Aspect
@Component
@Slf4j
public class RepeatSubmitAspect {


    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private RedissonClient redissonClient;



    /**
     * 定义 @Pointcut注解表达式，
     * 方式一：@annotation：当执行的方法上拥有指定的注解时生效（我们采用这）
     * 方式二：execution：一般用于指定方法的执行
     */
    @Pointcut("@annotation(repeatSubmit)")
    public void pointCutNoRepeatSubmit(RepeatSubmit repeatSubmit) {

    }


    /**
     * 环绕通知, 围绕着方法执行
     *
     * @param joinPoint
     * @throws Throwable
     * @Around 可以用来在调用一个具体方法前和调用后来完成一些具体的任务。
     * 方式一：单用 @Around("execution(* net.xdclass.controller.*.*(..))")可以
     * 方式二：用@Pointcut和@Around联合注解也可以（我们采用这个）
     *
     * 两种方式
     * 方式一：加锁 固定时间内不能重复提交
     * 方式二：先请求获取token，这边再删除token,删除成功则是第一次提交
     */
    @Around("pointCutNoRepeatSubmit(repeatSubmit)")
    public Object around(ProceedingJoinPoint joinPoint, RepeatSubmit repeatSubmit) throws Throwable {
        //拿到前端传来的请求
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder
                .getRequestAttributes()).getRequest();

        long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        //用于记录成功或者失败
        boolean res = false;
        //防重提交类型
        String type = repeatSubmit.limitType().name();
        if(type.equalsIgnoreCase(RepeatSubmit.Type.PARAM.name())){
            //方式一，参数形式防重提交
            //拿到加锁时间
            long lockTime = repeatSubmit.lockTime();
            //拿到ip地址
            String ipAddr = CommonUtil.getIpAddr(request);
            //拿到方法签名
            MethodSignature methodSignature = (MethodSignature)joinPoint.getSignature();
            //拿到方法名
            Method method = methodSignature.getMethod();
            //拿到类名
            String className = method.getDeclaringClass().getName();
            //拿到唯一key
            String key = "order-server:repeat_submit:"
                    + CommonUtil.MD5(String.format("%s-%s-%s-%s",ipAddr,className,method,accountNo));
            //加锁
//            res  = redisTemplate.opsForValue().setIfAbsent(key, "1", lockTime, TimeUnit.SECONDS);
            RLock lock = redissonClient.getLock(key);
            // 尝试加锁，最多等待0秒，上锁以后5秒自动解锁 [lockTime默认为5s, 可以自定义]
            res = lock.tryLock(0,lockTime,TimeUnit.SECONDS);


        }else {
            //方式二，令牌形式防重提交
            String requestToken = request.getHeader("request-token");
            if(StringUtils.isBlank(requestToken)){
                throw new BizException(BizCodeEnum.ORDER_CONFIRM_TOKEN_EQUAL_FAIL);
            }
            String key = String.format(RedisKey.SUBMIT_ORDER_TOKEN_KEY,accountNo,requestToken);
            /**
             * 提交表单的token key
             * 方式一：不用lua脚本获取再判断，之前是因为 key组成是 order:submit:accountNo,
             * value是对应的token，所以需要先获取值，再判断
             * 方式二：可以直接key是 order:submit:accountNo:token,然后直接删除成功则完成
             */
            res = redisTemplate.delete(key);
        }
        if(!res){
            //订单重复提交
            log.error("请求重复提交");
            throw new BizException(BizCodeEnum.ORDER_CONFIRM_REPEAT);
        }
        log.info("环绕通知执行前");
        //订单没有重复提交，继续向下处理
        Object obj = joinPoint.proceed();
        log.info("环绕通知执行后");
        return obj;
    }
}
```
#### 17.4.7超时关闭订单开发

- 链路流程图

![1675324635391](短链平台项目.assets/1675324660120.png)

##### 17.4.7.1 RabbitMQ死信队列基础

- 什么是rabbitmq的死信队列

```
没有被及时消费的消息存放的队列
```

- 什么是rabbitmq的死信交换机

```
Dead Letter Exchange（死信交换机，缩写：DLX）当消息成为死信后，会被重新发送到另⼀个交换机，这个交换机就是DLX死信交换机。
```

![1675325129750](短链平台项目.assets/1675325129750.png)

- 消息有哪几种情况成为死信

```
消费者拒收消息（basic.reject/ basic.nack），并且没有重新⼊队requeue=false。
消息在队列中未被消费，且超过队列或者消息本身的过期时间TTL(time-to-live)。
队列的消息⻓度达到极限。
结果：消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列。
```

- 什么是延迟队列

```
⼀种带有延迟功能的消息队列，Producer 将消息发送到消息队列 服务端，但并不期望这条消息⽴⻢投递，⽽是推迟到在当前时间点之后的某⼀个时间投递到 Consumer 进⾏消费，该消息即定时消息。
```

##### 17.4.7.2RabbitMQ实现延迟消息配置

###### 17.4.7.2.1application.properties

```
##----------rabbit配置--------------
spring.rabbitmq.host=101.200.159.132
spring.rabbitmq.port=5672
#需要手工创建虚拟主机
spring.rabbitmq.virtual-host=dev
spring.rabbitmq.username=admin
spring.rabbitmq.password=password
#消息确认方式，manual(手动ack) 和auto(自动ack)
spring.rabbitmq.listener.simple.acknowledge-mode=auto
#开启重试，消费者代码不能添加try catch捕获不往外抛异常
spring.rabbitmq.listener.simple.retry.enabled=true
#最大重试次数
spring.rabbitmq.listener.simple.retry.max-attempts=4
# 重试消息的时间间隔，5秒
spring.rabbitmq.listener.simple.retry.initial-interval=5000
```

###### 17.4.7.2.2RabbitMQConfig

```
package net.xdclass.config;

import lombok.Data;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * @Description
 * @Author 刘森飚
 * @description:
 *  自定义消息队列配置，
 *  发送 关单消息-》延迟exchange-》order.close.delay.queue-》死信exchange-》order.close.queue
 **/

@Configuration
@Data
public class RabbitMQConfig {


    /**
     * 交换机
     */
    private String orderEventExchange="order.event.exchange";


    /**
     * 延迟队列，不能被消费者监听
     */
    private String orderCloseDelayQueue = "order.close.delay.queue";

    /**
     * 死信队列，延迟队列的消息过期后转发的队列，用于被消费者监听
     */
    private String orderCloseQueue = "order.close.queue";


    /**
     * 进入到延迟队列的routingKey
     */
    private String orderCloseDelayRoutingKey = "order.close.delay.routing.key";


    /**
     * 进入死信队列的routingKey，消息过期进入死信队列的key
     */
    private String orderCloseRoutingKey = "order.close.delay.key";


    /**
     * 过期时间，毫秒单位，临时改为1分钟过期
     */
    private Integer ttl = 1000 * 60;


    /**
     * 消息转换器
     * @return
     */
    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }


    /**
     * 创建交换机，topic类型，一般一个业务一个交换机
     * @return
     */
    @Bean
    public Exchange orderEventExchange(){
        return new TopicExchange(orderEventExchange,true,false);
    }


    /**
     * 延迟队列
     * 延迟队列结束后发送消息给死信队列
     * @return
     */
    @Bean
    public Queue orderCloseDelayQueue(){
        //相当于给这个队列配置了死信交换机
        Map<String,Object> args = new HashMap<>(3);
        args.put("x-dead-letter-exchange",orderEventExchange);
        args.put("x-dead-letter-routing-key",orderCloseRoutingKey);
        args.put("x-message-ttl",ttl);
        return new Queue(orderCloseDelayQueue,true,false,false,args);
    }


    /**
     * 死信队列，是一个普通队列，用于被监听
     * @return
     */
    @Bean
    public Queue orderCloseQueue(){
        return new Queue(orderCloseQueue,true,false,false);
    }


    /**
     * 第一个队列 即延迟队列和交换机建立绑定关系
     * @return
     */
    @Bean
    public Binding orderCloseDelayBinding(){
        return new Binding(orderCloseDelayQueue,
                Binding.DestinationType.QUEUE,orderEventExchange,orderCloseDelayRoutingKey,null);
    }


    /**
     * 死信队列和死信交换机简历绑定关系
     * @return
     */
    @Bean
    public Binding orderCloseBinding(){

        return new Binding(orderCloseQueue,
                Binding.DestinationType.QUEUE,orderEventExchange,orderCloseRoutingKey,null);
    }
}
```
###### 17.4.7.2.3ProductOrderServiceImpl

```
//发送延迟消息
EventMessage eventMessage = EventMessage.builder()
        .eventMessageType(EventMessageType.PRODUCT_ORDER_NEW.name())
        .accountNo(loginUser.getAccountNo())
        .bizId(orderOutTradeNo)
        .build();
rabbitTemplate.convertAndSend(rabbitMQConfig.getOrderEventExchange(),
        rabbitMQConfig.getOrderCloseDelayRoutingKey(),eventMessage);
```

![1675333023167](短链平台项目.assets/1675333023167.png)

##### 17.4.7.3超时关闭订单消费者骨架开发

###### 17.4.7.3.1RabbitMQErrorConfig

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.retry.MessageRecoverer;
import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author 刘森飚
 * @since 2023-02-02
 */

@Configuration
@Slf4j
public class RabbitMQErrorConfig {


    /**
     * 异常交换机
     */
    private String orderErrorExchange = "order.error.exchange";

    /**
     * 异常队列
     */
    private String orderErrorQueue = "order.error.queue";

    /**
     * 异常routing.key
     */
    private String orderErrorRoutingKey = "order.error.routing.key";


    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 创建异常交换机
     * @return
     */
    @Bean
    public TopicExchange errorTopicExchange(){

        return new TopicExchange(orderErrorExchange,true,false);
    }

    /**
     * 创建异常队列
     * @return
     */

    @Bean
    public Queue errorQueue(){
        return new Queue(orderErrorQueue,true);
    }


    /**
     * 建立绑定关系
     * @return
     */
    @Bean
    public Binding bindingErrorQueueAndExchange(){

        return BindingBuilder.bind(errorQueue()).to(errorTopicExchange()).with(orderErrorRoutingKey);
    }


    /**
     * 配置  RepublishMessageRecoverer
     *
     * 消费消息重试一定次数后，用特定的routingKey转发到指定的交换机中，方便后续排查和告警
     *
     * @return
     */
    @Bean
    public MessageRecoverer messageRecoverer(){

        return new RepublishMessageRecoverer(rabbitTemplate,orderErrorExchange,orderErrorRoutingKey);
    }
}
```

###### 17.4.7.3.2ProductOrderMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.ProductOrderService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-02
 */

@Component
@Slf4j
@RabbitListener(queuesToDeclare = {@Queue("order.close.queue")})
public class ProductOrderMQListener {

    @Autowired
    private ProductOrderService productOrderService;


    @RabbitHandler
    public void productOrderHandler(EventMessage eventMessage, Message message, Channel channel){
        log.info("死信队列监听到消息ProductOrderMQListener messsage消息内容:{}",message);
        try{
            productOrderService.closeProductOrder(eventMessage);
        }catch (Exception e){
            log.error("消费者失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
    }
}
```

###### 17.4.7.3.3ProductOrderServiceImpl

```
/**
 * 延迟消息的时间 需要比订单过期 时间长一点，这样就不存在查询的时候，用户还能支付成功
 * 查询订单是否存在，如果已经支付则正常结束
 * 如果订单未支付，主动调用第三方支付平台查询订单状态
 *     确认未支付，本地取消订单
 *     如果第三方平台已经支付，主动的把订单状态改成已支付，
 *     造成该原因的情况可能是支付通道回调有问题，然后触发支付后的动作，如何触发？RPC还是？
 * @param eventMessage
 */
@Override
public boolean closeProductOrder(EventMessage eventMessage) {
    String outTradeNo = eventMessage.getBizId();
    Long accountNo = eventMessage.getAccountNo();
    ProductOrderDO productOrderDO = productOrderManager.findByOutTradeNoAndAccountNo(outTradeNo, accountNo);
    if (productOrderDO == null) {
        //订单不存在
        log.warn("订单不存在");
        return true;
    }
    if (productOrderDO.getState().equalsIgnoreCase(ProductOrderStateEnum.PAY.name())) {
        //已经支付
        log.info("直接确认消息，订单已经支付:{}", eventMessage);
        return true;
    }
    //未支付，需要向第三方支付平台查询状态
    if (productOrderDO.getState().equalsIgnoreCase(ProductOrderStateEnum.NEW.name())) {
        //向第三方查询状态
        PayInfoVO payInfoVO = new PayInfoVO();
        payInfoVO.setPayType(productOrderDO.getPayType());
        payInfoVO.setOutTradeNo(outTradeNo);
        payInfoVO.setAccountNo(accountNo);

        //TODO 需要向第三方支付平台查询状态
        String payResult = "";
        if (StringUtils.isBlank(payResult)) {
            //如果为空，则未支付成功，本地取消订单
            productOrderManager.updateOrderPayState(outTradeNo, accountNo,
                    ProductOrderStateEnum.CANCEL.name(), ProductOrderStateEnum.NEW.name());
            log.info("未支付成功，本地取消订单:{}", eventMessage);
        } else {
            //支付成功，主动把订单状态更新成支付
            log.warn("支付成功，但是微信回调通知失败，需要排查问题:{}", eventMessage);
            productOrderManager.updateOrderPayState(outTradeNo, accountNo,
                    ProductOrderStateEnum.PAY.name(), ProductOrderStateEnum.NEW.name());
            //触发支付成功后的逻辑， TODO
        }
    }
    return true;
}
```
#### 17.4.8微信支付开发

- 微信支付

```
官⽅地址：https://pay.weixin.qq.com/wiki/doc/api/index.html
案例演示: https://pay.weixin.qq.com/guide/webbased_payment.shtml
```

##### 17.4.8.1微信开发流程

- 接⼊指引

```
接⼊前⽀付参数准备

项⽬开发指引
据⾃身开发语⾔，选择对应的开发库并构建项⽬，添加依赖。
创建加载商户私钥、加载平台证书、初始化httpClient的通用⽅法。
开发API进⾏测试
签名⽣成
签名验证
敏感信息加解密
merchantPrivateKey（私钥）
wechatpayCertificates（平台证书）
APIV3Key（使⽤）
```

![1675435188953](短链平台项目.assets/1675435188953.png)

##### 17.4.8.2微信支付开发

###### 17.4.8.2.1参数加入

- application.properties

```
##----------微信支付参数--------------
#商户号
pay.wechat.mch-id=1558950191
#公众号id 需要和商户号绑定
pay.wechat.wx-pay-appid=wx74862e0dfcf69954
#商户证书序列号,需要和证书对应
pay.wechat.mch-serial-no=34345964330B66427E0D3D28826C4993C77E631F
#API V3密钥
pay.wechat.api-v3-key=UDuLFDcmy5Eb6o0nTNZdu6ek4DDh4K8B

#商户私钥路径（微信服务端会根据证书序列号，找到证书获取公钥进行解密数据）
pay.wechat.private-key-path=classpath:/cert/apiclient_key.pem
#支付成功页面跳转
pay.wechat.success-return-url=http://liusenbiao.com
#支付成功，回调通知
pay.wechat.callback-url=http://r56q46.natappfree.cc/api/callback/order/v1/wechat
```

- resources\cert\apiclient_key.pem

```
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDnSAKI8sea8p+d
OBVPWlZmxqJfPbdhzZxdI5Kx1j5SJNZwXWtr43/giw38pwzSlBI+bubBcYlkFTI0
guigMZO/yueb1mZChaY/JG1vsT02Ubj0xkVvBwKNbYS48NEpZhK61Mia09R4n1iH
1vip9kt8J6Zrx+xIqwmuCNWigyivGrvY9AdevCNlNSVdHVOZUJiJ6UGtvVmgZb0u
RTwBzfkjnwTgEcsrZMmF15nFubFsyJLyF/zY4NhrISc8H/rbjgleqa8ybYL26iTS
gfPCXe4U9f8fNFF2bSA06GTiB2R93q2B0zHeUYrpgF4XOGlIAqH+Ea4Vn+aOj6I0
pduh03idAgMBAAECggEBAJ+4SB/hYd1szrPZhkXtwhtp87pIObtuLhzYMzdjGFjM
HdctfMDeNHKSNU+U4bMPFOZO2kcfLF2Ukb5X5WSzuDBMZNRnJOmtuJiEhJsM0JQR
reREhLDfK3EWAAFkNV4corSpu/vIbEP87zuoRsPBVnHgQ/rM7y1kCORKL5bycwcw
5BI4xhULKAu14LEcDL3+xDJo39w+WCFlxuP+6Bs7+vIeavs+AC3TJkA4kg2nyWd3
W07xPjHl64f17icqsFhuFZ+VuSf5CAgQGWDbC7BHqRkDStUDSiiUiFushouKCLdK
MpA0x4ogb2ZwfZDRhZHiLNAGe4QovYCcXWBydzuT0WECgYEA828Bo1JAHE5kdnsO
E9+enH/yMcOKTRnuYPiXsFXNvqofc5tZiXJmVE/+EKv7LFmtUA6qqKC7FDek8TpP
SkfXmSDAgfM6AdzT0YoHH23FRVewnFMEYumtogXsXJTyI5siBSJp16s9Rn/YwESt
JqjW5+9Ck1dkU+UJCZ4lOw4HeGkCgYEA8zho2BKQTh3P/xcFcoTcunVZpRayVkHM
g8Ef6RGGo4vM1oshQLvXyPqCmhAIf6j71I9WPqUwjmeGyaR7Hir0dbgTCm2fJPFW
lxAvgbCISxEPz10RYBcR2umMSlJLfZfhqv1CyfU4vfCTbdOimgsz2039E3oLTbzg
eDe/mdzu2BUCgYEAleKjf4wFLWiXMtxRrqrhXjrpRPrBDPgKbmqh+1DZfawB8YyV
dKublg4qwNkjrgsJS2G8cleE2M3qIR1l9LaHaSFhZqH79WmigkIaYJ+V9zwm4hm7
eaun3TsIbXjIHmRGbiLiSIiHEgFl0/x1IHiU2fnXZCFLBNzg06ssAVCCCQECgYA1
4BfxTONkOlxZgAr33BBcySPLWuS0EK0xvjTIVtaBIbWFDJqYEUPyQ/NsFwMa7B6k
bf/HrqW71ZjYz7Np8k/mR5kIJVIsR71Lhw1O6AC4yBW9dDsmEtYkrLkjuWj5cAxP
6PvDaqtf/4tYt5l8D+Ezwem+R7l7RcxfNNIfTf4mJQKBgE57dnRx+Ijx7VHjJvjl
X2jB/VSVGpK5OADykmmZ/wvHPlQcyzd+5kAIoJhSuY48CFeI1DOogR2p01LEFQEL
j4AI5FqOOQwRJvNmfoKcKwO36tSxSEGSM8POKOsa21PG/gvDpJjVFo2hn5QcMHWn
z5SjsgA/1YbXejubdLxT/3pl
-----END PRIVATE KEY-----
```

###### 17.4.8.2.2证书配置加入

- WechatPayConfig

```
package net.xdclass.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * @author 刘森飚
 * @since 2023-02-02
 */

@Data
@Configuration
@ConfigurationProperties(prefix = "pay.wechat")
public class WechatPayConfig {

    /**
     * 商户号
     */
    private String mchId;

    /**
     * 公众号id 需要和商户号绑定
     */
    private String wxPayAppid;
    /**
     * 商户证书序列号,需要和证书对应
     */
    private String mchSerialNo;
    /**
     * API V3密钥
     */
    private String apiV3Key;
    /**
     * 商户私钥路径（微信服务端会根据证书序列号，找到证书获取公钥进行解密数据）
     */
    private String privateKeyPath;
    /**
     * 支付成功页面跳转
     */
    private String successReturnUrl;

    /**
     * 支付成功，回调通知
     */
    private String callbackUrl;
}
```

###### 17.4.8.2.3Maven依赖加入

微信支付API v3的Apache HttpClient扩展，实现了请求签名的⽣成和应答签名的验证。

使用说明 https://github.com/wechatpay-apiv3/wechatpay-apache-httpclient

```
<!--微信支付扩展包-->
<dependency>
    <groupId>com.github.wechatpay-apiv3</groupId>
    <artifactId>wechatpay-apache-httpclient</artifactId>
    <version>0.3.0</version>
</dependency>
```

###### 17.4.8.2.4商户私钥证书代码读取

- java加载商户证书私钥

```
java加载商户证书私钥
如果下⾯链接打开慢就不⽤打开 https://github.com/wechatpay-apiv3/wechatpay-apache-httpclient
商户申请商户API证书时，会⽣成商户私钥，并保存在本地证书⽂件夹的⽂件apiclient_key.pem中。
商户开发者可以使⽤⽅法PemUtil.loadPrivateKey()加载证书
```

- PayBeanConfig

```
package net.xdclass.config;

import com.wechat.pay.contrib.apache.httpclient.WechatPayHttpClientBuilder;
import com.wechat.pay.contrib.apache.httpclient.auth.PrivateKeySigner;
import com.wechat.pay.contrib.apache.httpclient.auth.ScheduledUpdateCertificatesVerifier;
import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Credentials;
import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Validator;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.impl.client.CloseableHttpClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;
import java.util.stream.Collectors;

/**
 * @author 刘森飚
 * @since 2023-02-02
 */

@Configuration
@Slf4j
public class PayBeanConfig {

    @Autowired
    private WechatPayConfig payConfig;

    /**
     * 加载秘钥
     *
     * @return
     * @throws IOException
     */

    public PrivateKey getPrivateKey() throws IOException {
        InputStream inputStream = new ClassPathResource(payConfig.getPrivateKeyPath()
                .replace("classpath:", "")).getInputStream();

        String content = new BufferedReader(new InputStreamReader(inputStream))
                .lines().collect(Collectors.joining(System.lineSeparator()));
        try {
            String privateKey = content.replace("-----BEGIN PRIVATE KEY-----", "")
                    .replace("-----END PRIVATE KEY-----", "")
                    .replaceAll("\\s+", "");
            KeyFactory kf = KeyFactory.getInstance("RSA");
            PrivateKey finalPrivateKey = kf.generatePrivate(
                    new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKey)));
            return finalPrivateKey;
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("当前Java环境不支持RSA", e);
        } catch (InvalidKeySpecException e) {
            throw new RuntimeException("无效的密钥格式");
        }
    }


    /**
     * 定时获取微信签名验证器，自动获取微信平台证书（证书里面包括微信平台公钥）
     *
     * @return
     */
    @Bean
    public ScheduledUpdateCertificatesVerifier getCertificatesVerifier() throws IOException {

        // 使用定时更新的签名验证器，不需要传入证书
        ScheduledUpdateCertificatesVerifier verifier = null;
        verifier = new ScheduledUpdateCertificatesVerifier(
                new WechatPay2Credentials(payConfig.getMchId(),
                        new PrivateKeySigner(payConfig.getMchSerialNo(),
                                getPrivateKey())),
                payConfig.getApiV3Key().getBytes(StandardCharsets.UTF_8));

        return verifier;
    }


    /**
     * 获取http请求对象，会自动的处理签名和验签，
     * 并进行证书自动更新
     *
     * @return
     */
    @Bean("wechatPayClient")
    public CloseableHttpClient getWechatPayClient(ScheduledUpdateCertificatesVerifier verifier) throws IOException {
        WechatPayHttpClientBuilder builder = WechatPayHttpClientBuilder.create()
                .withMerchant(payConfig.getMchId(),payConfig.getMchSerialNo() , getPrivateKey())
                .withValidator(new WechatPay2Validator(verifier));

        // 通过WechatPayHttpClientBuilder构造的HttpClient，会自动的处理签名和验签，并进行证书自动更新
        CloseableHttpClient httpClient = builder.build();

        return httpClient;
    }
}
```

- WechatPayTest

```
package net.xdclass.biz;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.ShopApplication;
import net.xdclass.config.PayBeanConfig;
import net.xdclass.manager.ProductOrderManager;
import net.xdclass.model.ProductOrderDO;
import net.xdclass.util.CommonUtil;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-03
 */


@RunWith(SpringRunner.class)
@SpringBootTest(classes = ShopApplication.class)

@Slf4j
public class WechatPayTest {

    @Autowired
    private PayBeanConfig payBeanConfig;


    @Test
    public void testLoadPrivateKey() throws IOException {

        log.info(payBeanConfig.getPrivateKey().getAlgorithm());

    }
}
```

![1675438736724](短链平台项目.assets/1675438736724.png)

###### 17.4.8.2.5APIv3证书与密钥使用说明

- 应用和支付平台的交互图

![1675438910795](短链平台项目.assets/1675438910795.png)

- 微信签名和验签的交互图（商户证书和平台证书的使用说明）

![1675439454912](短链平台项目.assets/1675439454912.png)

- 平台证书获取

![1675439531081](短链平台项目.assets/1675439531081.png)

###### 17.4.8.2.6SDK二次封装HttpClient

- PayBeanConfig

```
/**
 * 定时获取微信签名验证器，自动获取微信平台证书（证书里面包括微信平台公钥）
 *
 * @return
 */
@Bean
public ScheduledUpdateCertificatesVerifier getCertificatesVerifier() throws IOException {

    // 使用定时更新的签名验证器，不需要传入证书
    ScheduledUpdateCertificatesVerifier verifier = null;
    verifier = new ScheduledUpdateCertificatesVerifier(
            new WechatPay2Credentials(payConfig.getMchId(),
                    new PrivateKeySigner(payConfig.getMchSerialNo(),
                            getPrivateKey())),
            payConfig.getApiV3Key().getBytes(StandardCharsets.UTF_8));

    return verifier;
}


/**
 * 获取http请求对象，会自动的处理签名和验签，
 * 并进行证书自动更新
 *
 * @return
 */
@Bean("wechatPayClient")
public CloseableHttpClient getWechatPayClient(ScheduledUpdateCertificatesVerifier verifier) throws IOException {
    WechatPayHttpClientBuilder builder = WechatPayHttpClientBuilder.create()
            .withMerchant(payConfig.getMchId(),payConfig.getMchSerialNo() , getPrivateKey())
            .withValidator(new WechatPay2Validator(verifier));

    // 通过WechatPayHttpClientBuilder构造的HttpClient，会自动的处理签名和验签，并进行证书自动更新
    CloseableHttpClient httpClient = builder.build();

    return httpClient;
}
```

- debug模式下平台证书获取成功

![1675441247565](短链平台项目.assets/1675441247565.png)

###### 17.4.8.2.7快速验证参数测试

- 接口文档

https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_1.shtml

- WechatPayApi

```
package net.xdclass.config;

/**
 * @author 刘森飚
 * @since 2023-02-04
 */


public class WechatPayApi {

    /**
     * 微信支付主机地址
     */
    public static final String HOST = "https://api.mch.weixin.qq.com";


    /**
     * Native下单
     */
    public static final String NATIVE_ORDER = HOST + "/v3/pay/transactions/native";

    
    /**
     * Native订单状态查询, 根据商户订单号查询
     */
    public static final String NATIVE_QUERY = HOST + "/v3/pay/transactions/out-trade-no/%s?mchid=%s";
    
    
    /**
     * 关闭订单接口
     */
    public static final String NATIVE_CLOSE_ORDER = HOST+ "/v3/pay/transactions/out-trade-no/%s/close";
     
    
    /**
     * 申请退款接口
     */
    public static final String NATIVE_REFUND_ORDER = HOST+ "/v3/refund/domestic/refunds";
}
```

- 通用测试代码（快速验证参数是否过期和失效）

```
package net.xdclass.biz;

import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.ShopApplication;
import net.xdclass.config.PayBeanConfig;
import net.xdclass.config.WechatPayApi;
import net.xdclass.config.WechatPayConfig;
import net.xdclass.manager.ProductOrderManager;
import net.xdclass.model.ProductOrderDO;
import net.xdclass.util.CommonUtil;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-03
 */


@RunWith(SpringRunner.class)
@SpringBootTest(classes = ShopApplication.class)

@Slf4j
public class WechatPayTest {

    @Autowired
    private PayBeanConfig payBeanConfig;


    @Autowired
    private WechatPayConfig payConfig;

    @Autowired
    private CloseableHttpClient wechatPayClient;


    /**
     * 快速验证统一下单接口
     *
     * @throws IOException
     */
    @Test
    public void testNativeOrder() throws IOException {

        String outTradeNo = CommonUtil.getStringNumRandom(32);

        /**
         * {
         *     "mchid": "1900006XXX",
         *     "out_trade_no": "native12177525012014070332333",
         *     "appid": "wxdace645e0bc2cXXX",
         *     "description": "Image形象店-深圳腾大-QQ公仔",
         *     "notify_url": "https://weixin.qq.com/",
         *     "amount": {
         *        "total": 1,
         *        "currency": "CNY"
         *        }
         * }
         */
        JSONObject payObj = new JSONObject();
        payObj.put("mchid", payConfig.getMchId());
        payObj.put("out_trade_no", outTradeNo);
        payObj.put("appid", payConfig.getWxPayAppid());
        payObj.put("description", "刘森飚下单啦！！！");
        payObj.put("notify_url", payConfig.getCallbackUrl());

        //订单总金额，单位为分。
        JSONObject amountObj = new JSONObject();
        amountObj.put("total", 100);
        amountObj.put("currency", "CNY");

        payObj.put("amount", amountObj);
        //附属参数，可以用在回调
        payObj.put("attach", "{\"accountNo\":" + 888 + "}");


        String body = payObj.toJSONString();

        log.info("请求参数:{}", body);

        StringEntity entity = new StringEntity(body, "utf-8");
        entity.setContentType("application/json");

        HttpPost httpPost = new HttpPost(WechatPayApi.NATIVE_ORDER);
        httpPost.setHeader("Accept", "application/json");
        httpPost.setEntity(entity);

        try (CloseableHttpResponse response = wechatPayClient.execute(httpPost)) {

            //响应码
            int statusCode = response.getStatusLine().getStatusCode();
            //响应体
            String responseStr = EntityUtils.toString(response.getEntity());

            log.info("下单响应码:{},响应体:{}", statusCode, responseStr);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

![1675518878278](短链平台项目.assets/1675518878278.png)

###### 17.4.8.2.8查询订单支付状态测试

```
/**
 * 根据商户号订单号查询订单支付状态
 * @throws IOException
 */
@Test
public void testNativeQuery() throws IOException {
    String outTradeNo = "gQZeW356sREDGQ1r8drDHBSHaoYX7irb";
    String url = String.format(WechatPayApi.NATIVE_QUERY,outTradeNo,payConfig.getMchId());
    HttpGet httpGet = new HttpGet(url);
    httpGet.setHeader("Accept","application/json");
    try(CloseableHttpResponse response = wechatPayClient.execute(httpGet)){
        //响应码
        int statusCode = response.getStatusLine().getStatusCode();
        //响应体
        String responseStr = EntityUtils.toString(response.getEntity());
        log.info("查询响应码:{},响应体:{}",statusCode,responseStr);
    }catch (Exception e){
        e.printStackTrace();
    }
}
```

![1675520185146](短链平台项目.assets/1675520185146.png)

###### 17.4.8.2.9关闭订单测试

```
/**
 * 关闭订单
 * @throws IOException
 */
@Test
public void testNativeCloseOrder() throws IOException {
    String outTradeNo = "gQZeW356sREDGQ1r8drDHBSHaoYX7irb";
    JSONObject payObj = new JSONObject();
    payObj.put("mchid",payConfig.getMchId());
    String body = payObj.toJSONString();
    log.info("请求参数:{}",body);
    //将请求参数设置到请求对象中
    StringEntity entity = new StringEntity(body,"utf-8");
    entity.setContentType("application/json");
    String url = String.format(WechatPayApi.NATIVE_CLOSE_ORDER,outTradeNo);
    HttpPost httpPost = new HttpPost(url);
    httpPost.setHeader("Accept","application/json");
    httpPost.setEntity(entity);
    try(CloseableHttpResponse response = wechatPayClient.execute(httpPost)){
        //响应码
        int statusCode = response.getStatusLine().getStatusCode();
        log.info("关闭订单响应码:{},无响应体",statusCode);
    }catch (Exception e){
        e.printStackTrace();
    }
}
```

![1675521610761](短链平台项目.assets/1675521610761.png)

###### 17.4.8.2.10申请订单退款测试

- 注意事项

```
注意：
1、交易时间超过一年的订单无法提交退款

2、微信支付退款支持单笔交易分多次退款（不超50次），多次退款需要提交原支付订单的商户订单号和设置不同的退款单号。申请退款总金额不能超过订单金额。 一笔退款失败后重新提交，请不要更换退款单号，请使用原商户退款单号

3、错误或无效请求频率限制：6qps，即每秒钟异常或错误的退款申请请求不超过6次

4、每个支付订单的部分退款次数不能超过50次

5、如果同一个用户有多笔退款，建议分不同批次进行退款，避免并发退款导致退款失败

6、申请退款接口的返回仅代表业务的受理情况，具体退款是否成功，需要通过退款查询接口获取结果

7、一个月之前的订单申请退款频率限制为：5000/min

8、同一笔订单多次退款的请求需相隔1分钟
```

- 状态机

![1675524650137](短链平台项目.assets/1675524650137.png)

- 编码实战

```
/**
 * 申请退款
 * @throws IOException
 */
@Test
public void testNativeRefundOrder() throws IOException {
    //统一下单订单号
    String outTradeNo = "XH5U0QvInSNK2GPPwAMl2pVRmkKYPYzi";
    //退款订单号
    String refundNo = CommonUtil.getStringNumRandom(32);
    // 请求body参数
    JSONObject refundObj = new JSONObject();
    //订单号
    refundObj.put("out_trade_no", outTradeNo);
    //退款单编号，商户系统内部的退款单号，商户系统内部唯一，
    // 只能是数字、大小写字母_-|*@ ，同一退款单号多次请求只退一笔
    refundObj.put("out_refund_no", refundNo);
    refundObj.put("reason", "商品已售完");
    refundObj.put("notify_url", payConfig.getCallbackUrl());
    JSONObject amountObj = new JSONObject();
    //退款金额
    amountObj.put("refund", 10);
    //实际支付的总金额
    amountObj.put("total", 100);
    amountObj.put("currency", "CNY");
    refundObj.put("amount", amountObj);
    String body = refundObj.toJSONString();

    log.info("请求参数:{}", body);
    StringEntity entity = new StringEntity(body, "utf-8");
    entity.setContentType("application/json");
    HttpPost httpPost = new HttpPost(WechatPayApi.NATIVE_REFUND_ORDER);
    httpPost.setHeader("Accept", "application/json");
    httpPost.setEntity(entity);
    try (CloseableHttpResponse response = wechatPayClient.execute(httpPost)) {
        //响应码
        int statusCode = response.getStatusLine().getStatusCode();
        //响应体
        String responseStr = EntityUtils.toString(response.getEntity());
        log.info("申请订单退款响应码:{},响应体:{}", statusCode, responseStr);

    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

![1675525280268](短链平台项目.assets/1675525280268.png)

![1675525288620](短链平台项目.assets/1675525288620.png)

###### 17.4.8.2.11订单退款状态查询测试

```
/**
 * 订单退款状态查询
 * @throws IOException
 */
@Test
public void testNativeRefundQuery() throws IOException {
    String refundNo = "92bmNIEHgO5MMBYzlSRosW8TzOy6Du4v";
    String url = String.format(WechatPayApi.NATIVE_REFUND_QUERY,refundNo);
    HttpGet httpGet = new HttpGet(url);
    httpGet.setHeader("Accept","application/json");
    try(CloseableHttpResponse response = wechatPayClient.execute(httpGet)){
        //响应码
        int statusCode = response.getStatusLine().getStatusCode();
        //响应体
        String responseStr = EntityUtils.toString(response.getEntity());
        log.info("查询订单退款 响应码:{},响应体:{}",statusCode,responseStr);
    }catch (Exception e){
        e.printStackTrace();
    }
}
```

###### 17.4.8.2.12策略模式+工厂模式对接微信支付

- 策略接口开发 PayStrategy

```
package net.xdclass.component;

import net.xdclass.vo.PayInfoVO;

public interface PayStrategy {

    /**
     * 统一下单接口
     * @param payInfoVO
     * @return
     */
    String unifiedOrder(PayInfoVO payInfoVO);


    /**
     * 退款接口
     * @param payInfoVO
     * @return
     */
    default String refund(PayInfoVO payInfoVO){ return ""; }


    /**
     * 查询支付状态
     * @param payInfoVO
     * @return
     */
    default String queryPayStatus(PayInfoVO payInfoVO){ return ""; }


    /**
     * 关闭订单
     * @param payInfoVO
     * @return
     */
    default String closeOrder(PayInfoVO payInfoVO){ return ""; }

}
```

- 策略上下文 PayStrategyContext开发

```
package net.xdclass.component;

import net.xdclass.vo.PayInfoVO;

/**
 * @author 刘森飚
 * @since 2023-02-05
 */

public class PayStrategyContext  {

    private PayStrategy payStrategy;

    public PayStrategyContext(PayStrategy payStrategy){
        this.payStrategy = payStrategy;
    }


    /**
     * 根据策略对象，执行不同的下单接口
     * @return
     */
    public String executeUnifiedOrder(PayInfoVO payInfoVO){

        return payStrategy.unifiedOrder(payInfoVO);
    }



    /**
     * 根据策略对象，执行不同的退款接口
     * @return
     */
    public String executeRefund(PayInfoVO payInfoVO){

        return payStrategy.refund(payInfoVO);
    }


    /**
     * 根据策略对象，执行不同的关闭接口
     * @return
     */
    public String executeCloseOrder(PayInfoVO payInfoVO){

        return payStrategy.closeOrder(payInfoVO);
    }


    /**
     * 根据策略对象，执行不同的查询订单状态接口
     * @return
     */
    public String executeQueryPayStatus(PayInfoVO payInfoVO){

        return payStrategy.queryPayStatus(payInfoVO);
    }
}
```

- 具体⽀付策略开发 AlipayStrategy、WechatPayStrategy
- WechatPayStrategy

```
package net.xdclass.component;

import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.config.WechatPayApi;
import net.xdclass.config.WechatPayConfig;
import net.xdclass.vo.PayInfoVO;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-02-05
 * 微信支付
 */

@Service
@Slf4j
public class WechatPayStrategy  implements  PayStrategy{


    @Autowired
    private WechatPayConfig payConfig;

    @Autowired
    private CloseableHttpClient wechatPayClient;


    @Override
    public String unifiedOrder(PayInfoVO payInfoVO) {
        //过期时间  RFC 3339格式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");
        //支付订单过期时间
        String timeExpire = sdf.format(new Date(System.currentTimeMillis() + payInfoVO.getOrderPayTimeoutMills()));
        JSONObject amountObj = new JSONObject();
        //数据库存储是double比如，100.99元，微信支付需要以分为单位
        int amount = payInfoVO.getPayFee().multiply(BigDecimal.valueOf(100)).intValue();
        amountObj.put("total", amount);
        amountObj.put("currency", "CNY");
        JSONObject payObj = new JSONObject();
        payObj.put("mchid", payConfig.getMchId());
        payObj.put("out_trade_no", payInfoVO.getOutTradeNo());
        payObj.put("appid", payConfig.getWxPayAppid());
        payObj.put("description", payInfoVO.getTitle());
        payObj.put("notify_url", payConfig.getCallbackUrl());
        payObj.put("time_expire", timeExpire);
        payObj.put("amount", amountObj);
        //回调携带
        payObj.put("attach", "{\"accountNo\":" + payInfoVO.getAccountNo() + "}");
        // 处理请求body参数
        String body = payObj.toJSONString();
        log.debug("请求参数:{}",body);
        StringEntity entity = new StringEntity(body,"utf-8");
        entity.setContentType("application/json");
        HttpPost httpPost = new HttpPost(WechatPayApi.NATIVE_ORDER);
        httpPost.setHeader("Accept","application/json");
        httpPost.setEntity(entity);
        String result = "";
        try(CloseableHttpResponse response = wechatPayClient.execute(httpPost)){
            //响应码
            int statusCode = response.getStatusLine().getStatusCode();
            //响应体
            String responseStr = EntityUtils.toString(response.getEntity());
            log.debug("下单响应码:{},响应体:{}",statusCode,responseStr);
            if(statusCode == HttpStatus.OK.value()){
                JSONObject jsonObject = JSONObject.parseObject(responseStr);
                if(jsonObject.containsKey("code_url")){
                    result = jsonObject.getString("code_url");
                }
            }else {
                log.error("下单响应失败:{},响应体:{}",statusCode,responseStr);
            }
        }catch (Exception e){
            log.error("微信支付响应异常:{}",e);
        }
        return result;
    }


    /**
     * 微信退款
     * @param payInfoVO
     * @return
     */
    @Override
    public String refund(PayInfoVO payInfoVO) {
        return null;
    }



    /**
     * 微信支付查询订单状态
     * @param payInfoVO
     * @return
     */
    @Override
    public String queryPayStatus(PayInfoVO payInfoVO) {
        String outTradeNo = payInfoVO.getOutTradeNo();
        String url = String.format(WechatPayApi.NATIVE_QUERY,outTradeNo,payConfig.getMchId());
        HttpGet httpGet = new HttpGet(url);
        httpGet.setHeader("Accept","application/json");
        String result = "";
        try(CloseableHttpResponse response = wechatPayClient.execute(httpGet)){
            //响应码
            int statusCode = response.getStatusLine().getStatusCode();
            //响应体
            String responseStr = EntityUtils.toString(response.getEntity());
            log.debug("查询响应码:{},响应体:{}",statusCode,responseStr);
            if(statusCode == HttpStatus.OK.value()){
                JSONObject jsonObject = JSONObject.parseObject(responseStr);
                if(jsonObject.containsKey("trade_state")){
                    result = jsonObject.getString("trade_state");
                }
            }else {
                log.error("查询支付状态响应失败:{},响应体:{}",statusCode,responseStr);
            }
        }catch (Exception e){
            log.error("微信支付响应异常:{}",e);
        }
        return result;
    }


    /**
     * 关闭订单
     * @param payInfoVO
     * @return
     */
    @Override
    public String closeOrder(PayInfoVO payInfoVO) {
        String outTradeNo = payInfoVO.getOutTradeNo();
        JSONObject payObj = new JSONObject();
        payObj.put("mchid",payConfig.getMchId());
        String body = payObj.toJSONString();
        log.debug("请求参数:{}",body);
        //将请求参数设置到请求对象中
        StringEntity entity = new StringEntity(body,"utf-8");
        entity.setContentType("application/json");
        String url = String.format(WechatPayApi.NATIVE_CLOSE_ORDER,outTradeNo);
        HttpPost httpPost = new HttpPost(url);
        httpPost.setHeader("Accept","application/json");
        httpPost.setEntity(entity);
        String result = "";
        try(CloseableHttpResponse response = wechatPayClient.execute(httpPost)){
            //响应码
            int statusCode = response.getStatusLine().getStatusCode();
            log.debug("关闭订单响应码:{},无响应体",statusCode);
            //响应码为204表示正常
            if(statusCode == HttpStatus.NO_CONTENT.value()){
                result = "CLOSE_SUCCESS";
            }
        }catch (Exception e){
            log.error("微信支付响应异常:{}",e);
        }
        return result;
    }
}
```

- 简单工厂类开发

```
package net.xdclass.component;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.ProductOrderPayTypeEnum;
import net.xdclass.vo.PayInfoVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-05
 */

@Component
@Slf4j
public class PayFactory {

    @Autowired
    private AliPayStrategy aliPayStrategy;

    @Autowired
    private WechatPayStrategy wechatPayStrategy;


    /**
     * 创建支付，简单工厂模式
     * @param payInfoVO
     * @return
     */
    public String pay(PayInfoVO payInfoVO){

        String payType = payInfoVO.getPayType();

        if (ProductOrderPayTypeEnum.ALI_PAY.name().equals(payType)) {
            //支付宝支付
            PayStrategyContext payStrategyContext = new PayStrategyContext(aliPayStrategy);
            return payStrategyContext.executeUnifiedOrder(payInfoVO);

        } else if(ProductOrderPayTypeEnum.WECHAT_PAY.name().equals(payType)){
            //微信支付
            PayStrategyContext payStrategyContext = new PayStrategyContext(wechatPayStrategy);
            return payStrategyContext.executeUnifiedOrder(payInfoVO);
        }
        return "";
    }


    /**
     * 关闭订单
     * @param payInfoVO
     * @return
     */
    public String closeOrder(PayInfoVO payInfoVO){

        String payType = payInfoVO.getPayType();

        if (ProductOrderPayTypeEnum.ALI_PAY.name().equals(payType)) {
            //支付宝支付
            PayStrategyContext payStrategyContext = new PayStrategyContext(aliPayStrategy);
            return payStrategyContext.executeCloseOrder(payInfoVO);

        } else if(ProductOrderPayTypeEnum.WECHAT_PAY.name().equals(payType)){

            //微信支付
            PayStrategyContext payStrategyContext = new PayStrategyContext(wechatPayStrategy);
            return payStrategyContext.executeCloseOrder(payInfoVO);
        }
        return "";
    }


    /**
     * 查询支付状态
     * @param payInfoVO
     * @return
     */
    public String queryPayStatus(PayInfoVO payInfoVO){

        String payType = payInfoVO.getPayType();

        if (ProductOrderPayTypeEnum.ALI_PAY.name().equals(payType)) {
            //支付宝支付
            PayStrategyContext payStrategyContext = new PayStrategyContext(aliPayStrategy);
            return payStrategyContext.executeQueryPayStatus(payInfoVO);

        } else if(ProductOrderPayTypeEnum.WECHAT_PAY.name().equals(payType)){

            //微信支付
            PayStrategyContext payStrategyContext = new PayStrategyContext(wechatPayStrategy);
            return payStrategyContext.executeQueryPayStatus(payInfoVO);
        }
        return "";
    }


    /**
     * 退款接口
     * @param payInfoVO
     * @return
     */
    public String refund(PayInfoVO payInfoVO){

        String payType = payInfoVO.getPayType();

        if (ProductOrderPayTypeEnum.ALI_PAY.name().equals(payType)) {
            //支付宝支付
            PayStrategyContext payStrategyContext = new PayStrategyContext(aliPayStrategy);
            return payStrategyContext.executeRefund(payInfoVO);

        } else if(ProductOrderPayTypeEnum.WECHAT_PAY.name().equals(payType)){
            //微信支付
            PayStrategyContext payStrategyContext = new PayStrategyContext(wechatPayStrategy);
            return payStrategyContext.executeRefund(payInfoVO);
        }

        return "";
    }
}
```

###### 17.4.8.2.13内网穿透映射

- 什么是内网穿透

```
⽀付成功需要配置回调通知应⽤服务器订单⽀付成功，需要配置对应的域名。
在本地电脑开发，微信、⽀付宝没法回调，所以需要配置个地址映射，就是外部服务器。
可以通过这个地址访问当前开发电脑的地址。
微信登录、授权、⽀付等都是需要域名映射⼯具配合。
```

- 工具

```
ngrock https://ngrok.com/
花⽣壳 https://hsk.oray.com/
⼩⽶球 http://ngrok.ciqiuwl.cn/
natapp(采⽤) https://natapp.cn/
```

![1675604582454](短链平台项目.assets/1675604582454.png)

![1675604623063](短链平台项目.assets/1675604623063.png)

![1675604660190](短链平台项目.assets/1675604660190.png)

- 启动

```
natapp -authtoken=8f708b1c800f7112
```

![1675605314295](短链平台项目.assets/1675605314295.png)

![1675605327130](短链平台项目.assets/1675605327130.png)

![1675605983382](短链平台项目.assets/1675605983382.png)

- 修改idea的配置文件

![1675606052076](短链平台项目.assets/1675606052076.png)

###### 17.4.8.2.14微信支付V3版本回调+验签

- 回调验签流程

```
https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_5.shtml
https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml



核心流程操作
获取报文
验证签名（确保是微信传输过来的）
 获取平台证书
 检查平台证书序列号
 构造验签名串
 获取应答签名
 验证签名
解密（AES对称解密出原始数据）
 加密报文格式
 解密
处理业务逻辑
响应请求

加密不能保证通知请求来⾃微信，微信会对发送给商户的通知进⾏签名，并将签名值放在通知的HTTP头Wechatpay-Signature，商户应当验证签名，以确认请求来⾃微信，而不是其他的第三方。
```

- 注意

```
同样的通知可能会多次发送给商户系统，商户系统必须能够正确处理重复的通知。
推荐的做法是，当商户系统收到通知进⾏处理时，先检查对应业务数据的状态，并判断该通知是否已经处理，如果未处理，则再进行处理；如果已处理，则直接返回结果成功。
在对业务数据进行状态检查和处理之前，要采⽤数据锁进行并发控制，以避免函数重⼊造成的数据混乱。
如果在所有通知频率后没有收到微信侧回调，商户应调⽤查询订单接确确认订单状态
确保回调URL是外部可正常访问的，且不能携带后缀参数。
```

- PayCallbackController

```
package net.xdclass.controller;

import com.alibaba.fastjson.JSONObject;
import com.wechat.pay.contrib.apache.httpclient.auth.ScheduledUpdateCertificatesVerifier;
import com.wechat.pay.contrib.apache.httpclient.util.AesUtil;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.config.WechatPayConfig;
import net.xdclass.service.ProductOrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @author 刘森飚
 * @since 2023-02-05
 */


@Controller
@RequestMapping("/api/callback/order/v1/")
@Slf4j
public class PayCallbackController {

    @Autowired
    private WechatPayConfig wechatPayConfig;

    @Autowired
    private ProductOrderService productOrderService;

    @Autowired
    private ScheduledUpdateCertificatesVerifier verifier;


    /**
     * 获取报文
     * 验证签名（确保是微信传输过来的）
     * 解密（AES对称解密出原始数据）
     * 处理业务逻辑
     * 响应请求
     * @param request
     * @param response
     * @return
     */
    @RequestMapping("wechat")
    @ResponseBody
    public Map<String, String> wehcatPayCallback(HttpServletRequest request, HttpServletResponse response) {
        //获取报文
        String body = getRequestBody(request);
        //随机串
        String nonceStr = request.getHeader("Wechatpay-Nonce");
        //微信传递过来的签名
        String signature = request.getHeader("Wechatpay-Signature");
        //证书序列号（微信平台）
        String serialNo = request.getHeader("Wechatpay-Serial");
        //时间戳
        String timestamp = request.getHeader("Wechatpay-Timestamp");
        //构造签名串
        //应答时间戳\n
        //应答随机串\n
        //应答报文主体\n
        String signStr = Stream.of(timestamp, nonceStr, body)
                .collect(Collectors.joining("\n", "", "\n"));
        Map<String, String> map = new HashMap<>(2);
        try {
            //验证签名是否通过
            boolean result = verifiedSign(serialNo, signStr, signature);
            if(result){
                //解密数据
                String plainBody = decryptBody(body);
                log.info("解密后的明文:{}",plainBody);
                Map<String, String> paramsMap = convertWechatPayMsgToMap(plainBody);
                //处理业务逻辑 TODO

                //响应微信
                map.put("code", "SUCCESS");
                map.put("message", "成功");
            }
        } catch (Exception e) {
            log.error("微信支付回调异常:{}", e);
        }
        return map;
    }


    /**
     * 验证签名
     * @param serialNo  微信平台-证书序列号
     * @param signStr   自己组装的签名串
     * @param signature 微信返回的签名
     * @return
     * @throws UnsupportedEncodingException
     */
    private boolean verifiedSign(String serialNo, String signStr, String signature) throws UnsupportedEncodingException {
        return verifier.verify(serialNo, signStr.getBytes("utf-8"), signature);
    }


    /**
     * 读取请求数据流
     * @param request
     * @return
     */
    private String getRequestBody(HttpServletRequest request) {
        StringBuffer sb = new StringBuffer();
        try (ServletInputStream inputStream = request.getInputStream();
             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        ) {
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line);
            }
        } catch (IOException e) {
            log.error("读取数据流异常:{}", e);
        }
        return sb.toString();
    }


    /**
     * 解密body的密文
     * "resource": {
     *         "original_type": "transaction",
     *         "algorithm": "AEAD_AES_256_GCM",
     *         "ciphertext": "",
     *         "associated_data": "",
     *         "nonce": ""
     *     }
     *
     * @param body
     * @return
     */
    private String decryptBody(String body) throws UnsupportedEncodingException, GeneralSecurityException {
        AesUtil aesUtil = new AesUtil(wechatPayConfig.getApiV3Key().getBytes("utf-8"));
        JSONObject object = JSONObject.parseObject(body);
        JSONObject resource = object.getJSONObject("resource");
        String ciphertext = resource.getString("ciphertext");
        String associatedData = resource.getString("associated_data");
        String nonce = resource.getString("nonce");
        return aesUtil.decryptToString
                (associatedData.getBytes("utf-8"),nonce.getBytes("utf-8"),ciphertext);
    }



    /**
     * 转换body为map
     * @param plainBody
     * @return
     */
    private Map<String,String> convertWechatPayMsgToMap(String plainBody){
        Map<String,String> paramsMap = new HashMap<>(2);
        JSONObject jsonObject = JSONObject.parseObject(plainBody);
        //商户订单号
        paramsMap.put("out_trade_no",jsonObject.getString("out_trade_no"));
        //交易状态
        paramsMap.put("trade_state",jsonObject.getString("trade_state"));
        //附加数据
        paramsMap.put("account_no",jsonObject.getJSONObject("attach").getString("accountNo"));
        return paramsMap;
    }
}
```

#### 17.4.9订单支付消息业务逻辑开发

##### 17.4.9.1订单更新和流量包权益更新

- 接收微信推送的支付成功消息后，我们需要做啥？

```
更新订单状态
调用账号服务发放流量包
```

- 队列冗余双写架构

![1675672791121](短链平台项目.assets/1675672791121.png)

###### 17.4.9.1.1RabbitMQConfig

```
//=============订单支付成功配置===================
/**
 * 更新订单 队列
 */
private String orderUpdateQueue = "order.update.queue";

/**
 * 订单发放流量包 队列
 */
private String orderTrafficQueue = "order.traffic.queue";


/**
 * 微信回调发送通知的routing key 【发送消息用】
 */
private String orderUpdateTrafficRoutingKey = "order.update.traffic.routing.key";


/**
 * topic类型的 用于绑定订单队列和交换机的
 */
private String orderUpdateBindingKey = "order.update.*.routing.key";


/**
 * topic类型的 用于绑定流量包发放队列和交换机
 */
private String orderTrafficBindingKey = "order.*.traffic.routing.key";


/**
 * 订单更新队列 和 交换机建立绑定关系
 * @return
 */
@Bean
public Binding orderUpdateBinding(){

    return new Binding(orderUpdateQueue,
            Binding.DestinationType.QUEUE,orderEventExchange,orderUpdateBindingKey,null);
}


/**
 * 发放流量包队列 和 交换机建立绑定关系
 * @return
 */
@Bean
public Binding orderTrafficBinding(){

    return new Binding(orderTrafficQueue,
            Binding.DestinationType.QUEUE,orderEventExchange,orderTrafficBindingKey,null);
}


/**
 * 更新订单队列， 普通队列，用于被监听消费
 * @return
 */
@Bean
public Queue orderUpdateQueue(){

    return new Queue(orderUpdateQueue,true,false,false);
}


/**
 * 发放流量包队列，普通队列，用于被监听消费
 * @return
 */
@Bean
public Queue orderTrafficQueue(){

    return new Queue(orderTrafficQueue,true,false,false);
}
```

###### 17.4.9.1.2PayCallbackController

```
package net.xdclass.controller;

import com.alibaba.fastjson.JSONObject;
import com.wechat.pay.contrib.apache.httpclient.auth.ScheduledUpdateCertificatesVerifier;
import com.wechat.pay.contrib.apache.httpclient.util.AesUtil;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.config.WechatPayConfig;
import net.xdclass.enums.ProductOrderPayTypeEnum;
import net.xdclass.service.ProductOrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @author 刘森飚
 * @since 2023-02-05
 */


@Controller
@RequestMapping("/api/callback/order/v1/")
@Slf4j
public class PayCallbackController {

    @Autowired
    private WechatPayConfig wechatPayConfig;

    @Autowired
    private ProductOrderService productOrderService;

    @Autowired
    private ScheduledUpdateCertificatesVerifier verifier;


    /**
     * 获取报文
     * 验证签名（确保是微信传输过来的）
     * 解密（AES对称解密出原始数据）
     * 处理业务逻辑
     * 响应请求
     * @param request
     * @param response
     * @return
     */
    @RequestMapping("wechat")
    @ResponseBody
    public Map<String, String> wechatPayCallback(HttpServletRequest request, HttpServletResponse response) {
        //获取报文
        String body = getRequestBody(request);
        //随机串
        String nonceStr = request.getHeader("Wechatpay-Nonce");
        //微信传递过来的签名
        String signature = request.getHeader("Wechatpay-Signature");
        //证书序列号（微信平台）
        String serialNo = request.getHeader("Wechatpay-Serial");
        //时间戳
        String timestamp = request.getHeader("Wechatpay-Timestamp");
        //构造签名串
        //应答时间戳\n
        //应答随机串\n
        //应答报文主体\n
        String signStr = Stream.of(timestamp, nonceStr, body)
                .collect(Collectors.joining("\n", "", "\n"));
        Map<String, String> map = new HashMap<>(2);
        try {
            //验证签名是否通过
            boolean result = verifiedSign(serialNo, signStr, signature);
            if(result){
                //解密数据
                String plainBody = decryptBody(body);
                log.info("解密后的明文:{}",plainBody);
                Map<String, String> paramsMap = convertWechatPayMsgToMap(plainBody);
                //处理业务逻辑
                //这行添加代码productOrderService.processOrderCallbackMsg(ProductOrderPayTypeEnum.WECHAT_PAY,paramsMap);
                //响应微信
                map.put("code", "SUCCESS");
                map.put("message", "成功");
            }
        } catch (Exception e) {
            log.error("微信支付回调异常:{}", e);
        }
        return map;
    }


    /**
     * 验证签名
     * @param serialNo  微信平台-证书序列号
     * @param signStr   自己组装的签名串
     * @param signature 微信返回的签名
     * @return
     * @throws UnsupportedEncodingException
     */
    private boolean verifiedSign(String serialNo, String signStr, String signature) throws UnsupportedEncodingException {
        return verifier.verify(serialNo, signStr.getBytes("utf-8"), signature);
    }


    /**
     * 读取请求数据流
     * @param request
     * @return
     */
    private String getRequestBody(HttpServletRequest request) {
        StringBuffer sb = new StringBuffer();
        try (ServletInputStream inputStream = request.getInputStream();
             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        ) {
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line);
            }
        } catch (IOException e) {
            log.error("读取数据流异常:{}", e);
        }
        return sb.toString();
    }


    /**
     * 解密body的密文
     * "resource": {
     *         "original_type": "transaction",
     *         "algorithm": "AEAD_AES_256_GCM",
     *         "ciphertext": "",
     *         "associated_data": "",
     *         "nonce": ""
     *     }
     *
     * @param body
     * @return
     */
    private String decryptBody(String body) throws UnsupportedEncodingException, GeneralSecurityException {
        AesUtil aesUtil = new AesUtil(wechatPayConfig.getApiV3Key().getBytes("utf-8"));
        JSONObject object = JSONObject.parseObject(body);
        JSONObject resource = object.getJSONObject("resource");
        String ciphertext = resource.getString("ciphertext");
        String associatedData = resource.getString("associated_data");
        String nonce = resource.getString("nonce");
        return aesUtil.decryptToString
                (associatedData.getBytes("utf-8"),nonce.getBytes("utf-8"),ciphertext);
    }



    /**
     * 转换body为map
     * @param plainBody
     * @return
     */
    private Map<String,String> convertWechatPayMsgToMap(String plainBody){
        Map<String,String> paramsMap = new HashMap<>(2);
        JSONObject jsonObject = JSONObject.parseObject(plainBody);
        //商户订单号
        paramsMap.put("out_trade_no",jsonObject.getString("out_trade_no"));
        //交易状态
        paramsMap.put("trade_state",jsonObject.getString("trade_state"));
        //附加数据
        paramsMap.put("account_no",jsonObject.getJSONObject("attach").getString("accountNo"));
        return paramsMap;
    }
}
```

###### 17.4.9.1.3ProductOrderServiceImpl

- 给用户新增发送流量包

```
由业务性能决定哪种⽅式,空间换时间，时间换空间 
方式⼀：商品信息/订单信息 可以由消费者那边 远程调⽤feign进行获取，多了⼀次开销
方式⼆：商品信息进行快照存储到订单，⽀付通知回调，组装消息体进行发送（空间换时间，推荐）
```

- 代码

```
 /**
     * 处理微信回调通知
     * @param wechatPay
     * @param paramsMap
     */
    @Override
    @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
    public JsonData processOrderCallbackMsg(ProductOrderPayTypeEnum payType, Map<String, String> paramsMap) {
//获取商户订单号
        String outTradeNo = paramsMap.get("out_trade_no");
        //交易状态
        String tradeState = paramsMap.get("trade_state");
        //获取accountNo用于分库分表
        Long accountNo = Long.valueOf(paramsMap.get("account_no"));
        //拿到订单信息
        ProductOrderDO productOrderDO = productOrderManager.findByOutTradeNoAndAccountNo(outTradeNo, accountNo);

        Map<String, Object> content = new HashMap<>(4);
        content.put("outTradeNo", outTradeNo);
        content.put("buyNum", productOrderDO.getBuyNum());
        content.put("accountNo", accountNo);
        //保存快照
        content.put("product", productOrderDO.getProductSnapshot());
        //构建消息
        EventMessage eventMessage = EventMessage.builder()
                .bizId(outTradeNo)
                .accountNo(accountNo)
                .messageId(outTradeNo)
                .content(JsonUtil.obj2Json(content))
                .eventMessageType(EventMessageType.ORDER_PAY.name())
                .build();

        if (payType.name().equalsIgnoreCase(ProductOrderPayTypeEnum.ALI_PAY.name())) {
            //支付宝支付 TODO

        } else if (payType.name().equalsIgnoreCase(ProductOrderPayTypeEnum.WECHAT_PAY.name())) {
            if ("SUCCESS".equalsIgnoreCase(tradeState)) {
                rabbitTemplate.convertAndSend(rabbitMQConfig.getOrderEventExchange(),
                        rabbitMQConfig.getOrderUpdateTrafficRoutingKey(), eventMessage);

                return JsonData.buildSuccess();
            }
        }
        return JsonData.buildResult(BizCodeEnum.PAY_ORDER_CALLBACK_NOT_SUCCESS);
    }
```

##### 17.4.9.2MQ重复发送问题

- 问题

```
微信⽀付成功,短时间重复发送问题
通知频率为
15s/15s/30s/3m/10m/20m/30m/30m/30m/60m/3h/3h/3h/6h/6h - 总计 24h4m
虽然给了文档，但是不按套路出牌，不⼀定准确按照时间间隔推送，需要保证幂等性处理
```

- 消息队列MQ面试核心

```
重复内容
投递
消费
任何消息队列产品不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你⾃⼰在业务端去重
kafka、rocketmq、rabbitmq等都是⼀样的
接⼝幂等性保障 ，消费端处理业务消息要保持幂等性
幂等性，通俗点说，就⼀个数据或者⼀个请求，给你重复来多次，你得确保对应的数据是不会改变的。
```

- 怎么保证MQ发送的幂等性

```
⽅案⼀：数据库
增加表记录，涉及到记录清除
多了⼀次数据库IO
⽅案⼆：Redis
set key value， 配置过期时间
```

- ProductOrderServiceImpl

```
else if (payType.name().equalsIgnoreCase(ProductOrderPayTypeEnum.WECHAT_PAY.name())) {
    if ("SUCCESS".equalsIgnoreCase(tradeState)) {
        //如果key不存在，则设置成功，返回true
        Boolean flag = redisTemplate.opsForValue()
                .setIfAbsent(outTradeNo, "OK", 3, TimeUnit.DAYS);
        if (flag) {
        rabbitTemplate.convertAndSend(rabbitMQConfig.getOrderEventExchange(),
                rabbitMQConfig.getOrderUpdateTrafficRoutingKey(), eventMessage);
        }
        return JsonData.buildSuccess();
    }
}
```

##### 17.4.9.3MQ消费者开发-订单支付状态更新

###### 17.4.9.3.1ProductOrderMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.ProductOrderService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-03
 */
@Component
@Slf4j
@RabbitListener(queuesToDeclare = {
        @Queue("order.close.queue"),
        @Queue("order.update.queue")
})
public class ProductOrderMQListener {

    @Autowired
    private ProductOrderService productOrderService;

    @RabbitHandler
    public void productOrderHandler(EventMessage eventMessage, Message message, Channel channel){
        log.info("监听到消息ProductOrderMQListener messsage消息内容:{}",message);
        try{
            productOrderService.handleProductOrderMessage(eventMessage);

        }catch (Exception e){
            log.error("消费者失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);

    }
}
```

###### 17.4.9.3.2ProductOrderServiceImpl

```
/**
 * 处理订单相关消息
 * @param eventMessage
 */
@Override
public void handleProductOrderMessage(EventMessage eventMessage) {
    String messageType = eventMessage.getEventMessageType();
    try{
        if(EventMessageType.PRODUCT_ORDER_NEW.name().equalsIgnoreCase(messageType)){
            //关闭订单
            this.closeProductOrder(eventMessage);
        } else if(EventMessageType.PRODUCT_ORDER_PAY.name().equalsIgnoreCase(messageType)){
            //订单已经支付，更新订单状态
            String outTradeNo = eventMessage.getBizId();
            Long accountNo = eventMessage.getAccountNo();
            int rows = productOrderManager.updateOrderPayState(outTradeNo,accountNo,
                    ProductOrderStateEnum.PAY.name(),ProductOrderStateEnum.NEW.name());
            log.info("订单更新成功:rows={},eventMessage={}",rows,eventMessage);
        }
    }catch (Exception e){
        log.error("订单消费者消费失败:{}",eventMessage);
        throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
    }
}
```

##### 17.4.9.4账号服务-RabbitMQ配置开发

###### 17.4.9.4.1account/application.properties

```
##----------rabbit配置--------------
spring.rabbitmq.host=101.200.159.132
spring.rabbitmq.port=5672
#需要手工创建虚拟主机
spring.rabbitmq.virtual-host=dev
spring.rabbitmq.username=admin
spring.rabbitmq.password=password
#消息确认方式，manual(手动ack) 和auto(自动ack)
spring.rabbitmq.listener.simple.acknowledge-mode=auto
#开启重试，消费者代码不能添加try catch捕获不往外抛异常
spring.rabbitmq.listener.simple.retry.enabled=true
#最大重试次数
spring.rabbitmq.listener.simple.retry.max-attempts=4
# 重试消息的时间间隔，5秒
spring.rabbitmq.listener.simple.retry.initial-interval=5000
```

###### 17.4.9.4.2RabbitMQErrorConfig

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.retry.MessageRecoverer;
import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Slf4j
public class RabbitMQErrorConfig {


    /**
     * 异常交换机
     */
    private String trafficErrorExchange = "traffic.error.exchange";

    /**
     * 异常队列
     */
    private String trafficErrorQueue = "traffic.error.queue";

    /**
     * 异常routing.key
     */
    private String trafficErrorRoutingKey = "traffic.error.routing.key";


    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 创建异常交换机
     * @return
     */
    @Bean
    public TopicExchange errorTopicExchange(){

        return new TopicExchange(trafficErrorExchange,true,false);
    }

    /**
     * 创建异常队列
     * @return
     */

    @Bean
    public Queue errorQueue(){
        return new Queue(trafficErrorQueue,true);
    }


    /**
     * 建立绑定关系
     * @return
     */
    @Bean
    public Binding bindingErrorQueueAndExchange(){

        return BindingBuilder.bind(errorQueue()).to(errorTopicExchange()).with(trafficErrorRoutingKey);
    }


    /**
     * 配置  RepublishMessageRecoverer
     *
     * 消费消息重试一定次数后，用特定的routingKey转发到指定的交换机中，方便后续排查和告警
     *
     * @return
     */
    @Bean
    public MessageRecoverer messageRecoverer(){

        return new RepublishMessageRecoverer(rabbitTemplate,trafficErrorExchange,trafficErrorRoutingKey);
    }
}
```

###### 17.4.9.4.3异常消息配置

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description
 * @Author 刘森飚
 **/


@Configuration
@Slf4j
public class RabbitMQConfig {

    /**
     * 消息转换器
     * 都转成json格式的
     * @return
     */
    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }
}
```

##### 17.4.9.5流量包模块Manager层开发

###### 17.4.9.5.1TrafficManager

```
package net.xdclass.manager;

import com.baomidou.mybatisplus.core.metadata.IPage;
import net.xdclass.model.TrafficDO;

/**
 * @author 刘森飚
 * @since 2023-02-06
 */

public interface TrafficManager {

    /**
     * 新增流量包
     * @param trafficDO
     * @return
     */
    int add(TrafficDO trafficDO);


    /**
     * 分页查询可用的流量包
     * @param page
     * @param size
     * @param accountNo
     * @return
     */
    IPage<TrafficDO> pageAvailable(int page, int size, Long accountNo);


    /**
     * 查找详情
     * @param trafficId
     * @param accountNo
     * @return
     */
    TrafficDO findByIdAndAccountNo(Long trafficId, Long accountNo);


    /**
     * 增加某个流量包天使用次数
     * @param currentTrafficId
     * @param accountNo
     * @param dayUsedTimes
     * @return
     */
    int addDayUsedTimes(long currentTrafficId, Long accountNo, int dayUsedTimes);
}
```

###### 17.4.9.5.2TrafficManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.TrafficManager;
import net.xdclass.mapper.TrafficMapper;
import net.xdclass.model.TrafficDO;
import net.xdclass.util.TimeUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-02-06
 */


@Component
@Slf4j
public class TrafficManagerImpl implements TrafficManager {


    @Autowired
    private TrafficMapper trafficMapper;


    /**
     * 新增流量包
     * @param trafficDO
     * @return
     */
    @Override
    public int add(TrafficDO trafficDO) {
        return trafficMapper.insert(trafficDO);
    }



    /**
     * 分页查询可用的流量包
     * @param page
     * @param size
     * @param accountNo
     * @return
     */
    @Override
    public IPage<TrafficDO> pageAvailable(int page, int size, Long accountNo) {
        Page<TrafficDO> pageInfo = new Page<>(page, size);
        String today = TimeUtil.format(new Date(), "yyyy-MM-dd");

        Page<TrafficDO> trafficDOPage = trafficMapper.selectPage(pageInfo, new QueryWrapper<TrafficDO>()
                .eq("account_no", accountNo)
                .ge("expired_date", today)
                .orderByDesc("gmt_create"));

        return trafficDOPage;
    }


    /**
     * 查找详情
     * @param trafficId
     * @param accountNo
     * @return
     */
    @Override
    public TrafficDO findByIdAndAccountNo(Long trafficId, Long accountNo) {
        TrafficDO trafficDO = trafficMapper.selectOne(new QueryWrapper<TrafficDO>()
                .eq("account_no", accountNo).eq("id", trafficId));
        return trafficDO;
    }



    /**
     * 给某个流量包增加天使用次数
     *
     * @param currentTrafficId
     * @param accountNo
     * @param dayUsedTimes
     * @return
     */
    @Override
    public int addDayUsedTimes(long currentTrafficId, Long accountNo, int dayUsedTimes) {
        return trafficMapper.update(null, new UpdateWrapper<TrafficDO>()
                .eq("account_no", accountNo)
                .eq("id", currentTrafficId)
                .set("day_used", dayUsedTimes));
    }
}
```

##### 17.4.9.6流量包权益发放

###### 17.4.9.6.1TrafficMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.TrafficService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-06
 */

@Component
@RabbitListener(queuesToDeclare = {
        @Queue("order.traffic.queue")
})
@Slf4j
public class TrafficMQListener {

    @Autowired
    private TrafficService trafficService;


    @RabbitHandler
    public void trafficHandler(EventMessage eventMessage, Message message, Channel channel){
        log.info("监听到消息trafficHandler:{}",eventMessage);
        try{
            trafficService.handleTrafficMessage(eventMessage);
        }catch (Exception e){
            log.error("消费者失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
    }
}
```

###### 17.4.9.6.2TrafficServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.EventMessageType;
import net.xdclass.manager.TrafficManager;
import net.xdclass.model.EventMessage;
import net.xdclass.model.TrafficDO;
import net.xdclass.service.TrafficService;
import net.xdclass.util.JsonUtil;
import net.xdclass.vo.ProductVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-06
 */


@Service
@Slf4j
public class TrafficServiceImpl implements TrafficService {

    @Autowired
    private TrafficManager trafficManager;


    /**
     * 处理流量消息
     * @param eventMessage
     */
    @Override
    @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
    public void handleTrafficMessage(EventMessage eventMessage) {
        String messageType = eventMessage.getEventMessageType();
        if(EventMessageType.PRODUCT_ORDER_PAY.name().equalsIgnoreCase(messageType)){
            //订单已经支付，新增流量
            String content = eventMessage.getContent();
            Map<String, Object> orderInfoMap = JsonUtil.json2Obj(content,Map.class);
            //还原订单商品信息
            Long accountNo = (Long)orderInfoMap.get("accountNo");
            String outTradeNo = (String)orderInfoMap.get("outTradeNo");
            Integer buyNum = (Integer)orderInfoMap.get("buyNum");
            String productStr = (String) orderInfoMap.get("product");
            ProductVO productVO = JsonUtil.json2Obj(productStr, ProductVO.class);
           log.info("商品信息:{}",productVO);
            //流量包有效期
            LocalDateTime expiredDateTime = LocalDateTime.now().plusDays(productVO.getValidDay());
            Date date = Date.from(expiredDateTime.atZone(ZoneId.systemDefault()).toInstant());
            //构建流量包对象
            TrafficDO trafficDO = TrafficDO.builder()
                    .accountNo(accountNo)
                    .dayLimit(productVO.getDayTimes() * buyNum)
                    .dayUsed(0)
                    .totalLimit(productVO.getTotalTimes())
                    .pluginType(productVO.getPluginType())
                    .level(productVO.getLevel())
                    .productId(productVO.getId())
                    .outTradeNo(outTradeNo)
                    .expiredDate(date).build();

            int rows = trafficManager.add(trafficDO);
            log.info("消费消息新增流量包:rows={},trafficDO={}",rows,trafficDO);
        }
    }
}
```

##### 17.4.9.7支付发放流量包全链路测试

- 下单

```
{
 "productId":2,
 "buyNum":1,
 "clientType":"PC",
 "payType":"WECHAT_PAY",
 "totalAmount":1,
 "payAmount":1,
 "billType":"NO_BILL",
 "billHeader":"",
 "billContent":"",
 "billReceiverPhone":"",
 "billReceiverEmail":""
}
```

![1675701640508](短链平台项目.assets/1675701640508.png)

- 支付

![1675701663179](短链平台项目.assets/1675701663179.png)

![1675766523110](短链平台项目.assets/1675766523110.png)

- 订单更新

![1675701708600](短链平台项目.assets/1675701708600.png)

- 流量包记录新增

![1675701756559](短链平台项目.assets/1675701756559.png)

- 控制台打印

![1675701800788](短链平台项目.assets/1675701800788.png)

#### 17.4.10流量包管理逻辑开发

##### 17.4.10.1流量包分页详情接口开发

###### 17.4.10.1.1TrafficController

```
package net.xdclass.controller;

import net.xdclass.controller.request.TrafficPageRequest;
import net.xdclass.controller.request.UseTrafficRequest;
import net.xdclass.service.TrafficService;
import net.xdclass.util.JsonData;
import net.xdclass.vo.TrafficVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-07
 */

@RestController
@RequestMapping("/api/traffic/v1")
public class TrafficController {

    @Autowired
    private TrafficService trafficService;


    /**
     * 分页查询流量包列表，查看可用的流量包
     * @param request
     * @return
     */
    @RequestMapping("page")
    public JsonData pageAvailable(@RequestBody TrafficPageRequest request){
        Map<String,Object> pageMap = trafficService.pageAvailable(request);
        return JsonData.buildSuccess(pageMap);
    }



    /**
     * 查找某个流量包详情
     * @param trafficId
     * @return
     */
    @GetMapping("/detail/{trafficId}")
    public JsonData detail(@PathVariable("trafficId") long trafficId){
        TrafficVO trafficVO = trafficService.detail(trafficId);
        return JsonData.buildSuccess(trafficVO);
    }
}
```

###### 17.4.10.1.2TrafficManagerImpl

```
/**
 * 分页查看可用的流量包
 * @param request
 * @return
 */
@Override
public Map<String, Object> pageAvailable(TrafficPageRequest request) {
    int size = request.getSize();
    int page = request.getPage();
    LoginUser loginUser = LoginInterceptor.threadLocal.get();
    IPage<TrafficDO> trafficDOIPage = trafficManager.pageAvailable(page, size, loginUser.getAccountNo());
    //获取流量包列表
    List<TrafficDO> records = trafficDOIPage.getRecords();
    List<TrafficVO> trafficVOList = records.stream().map(obj -> beanProcess(obj)).collect(Collectors.toList());
    Map<String, Object> pageMap = new HashMap<>(3);
    pageMap.put("total_record", trafficDOIPage.getTotal());
    pageMap.put("total_page",trafficDOIPage.getPages());
    pageMap.put("current_data",trafficVOList);
    return pageMap;
}


/**
 *  查询流量包详情
 * @param trafficId
 * @return
 */
@Override
public TrafficVO detail(long trafficId) {
    LoginUser loginUser = LoginInterceptor.threadLocal.get();
    TrafficDO trafficDO = trafficManager.findByIdAndAccountNo(trafficId, loginUser.getAccountNo());
    return beanProcess(trafficDO);
}


/**
 * 将Do类转换成Vo类
 * @param trafficDO
 * @return
 */
private TrafficVO beanProcess(TrafficDO trafficDO) {
    TrafficVO trafficVO = new TrafficVO();
    BeanUtils.copyProperties(trafficDO,trafficVO);
    return trafficVO;
}
```

##### 17.4.10.2新用户注册-免费流量包发放

###### 17.4.10.2.1解决方案

- 需求

```
业务为了拉新，⿎励新⽤户注册，赠送⼀个免费流量包，每天允许有⼀定次免费创建短链的次数。
```

- 方式⼀

```
注册的时候直接调⽤操作数据库
调用商品服务，查询流量包详情
数据库新增⼀条用户流量包记录


缺点
接口性能不⾏
拓展性不强，比如新用户除了免费流量包，还需要做其他处理
优点
编码简单
```

- 方式⼆

```
注册成功发送MQ消息，响应⽤户
消费端处理发放免费流量包


缺点
存在分布式事务问题
账号注册不成功，accountNo多1记录个也不影响，可以忽略
优点
接口性能⾼
拓展性强，类似注册发送⼀个⼴播事件，其他业务做监听处理即可
```

###### 17.4.10.2.2MQ消费者重复消费

- MQ消费端幂等性保障

```
分库分表情况下-同个accountNo路由到同个库表
付费流量包
采⽤订单号做唯⼀索引（accountNo + outTradeNo）
免费流量包
采用特定标识做唯⼀索引（ accountNo + free_init ）
```

- 库表设计增加了唯⼀索引

```
UNIQUE KEY `uk_trade_no` (`out_trade_no`,`account_no`) USING BTREE,
```

###### 17.4.10.2.3MQ生产者发送免费流量包

- RabbitMQConfig

```
package net.xdclass.config;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author 刘森飚
 * @since 2023-02-07
 */

@Configuration
@Slf4j
@Data
public class RabbitMQConfig {

    /**
     * 消息转换器
     * @return
     */
    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }


    //================流量包处理：用户初始化福利==========================
    /**
     * 交换机
     */
    private String trafficEventExchange = "traffic.event.exchange";


    /**
     * 用户注册 免费流量包新增 队列
     */
    private String trafficFreeInitQueue = "traffic.free_init.queue";

    /**
     * 用户注册 免费流量包新增 队列路由key
     *
     */
    private String trafficFreeInitRoutingKey = "traffic.free_init.routing.key";



    /**
     * 创建交换机 Topic类型
     * 一般一个微服务一个交换机
     * @return
     */
    @Bean
    public Exchange trafficEventExchange(){
        return new TopicExchange(trafficEventExchange,true,false);
    }


    /**
     * 队列的绑定关系建立:新用户注册免费流量包
     * @return
     */
    @Bean
    public Binding trafficFreeInitBinding(){

        return new Binding(trafficFreeInitQueue,Binding.DestinationType.QUEUE,
                trafficEventExchange,trafficFreeInitRoutingKey,null);
    }


    /**
     * 免费流量包队列
     */
    @Bean
    public Queue trafficFreeInitQueue(){

        return new Queue(trafficFreeInitQueue,true,false,false);
    }
}
```
- AccountServiceImpl

```
    /**
     * 用户初始化福利，流量包
     * @param accountDO
     */
    private void userRegisterInitTask(AccountDO accountDO) {
        EventMessage eventMessage = EventMessage.builder()
                .messageId(IDUtil.geneSnowFlakeID().toString())
                .accountNo(accountDO.getAccountNo())
                .eventMessageType(EventMessageType.TRAFFIC_FREE_INIT.name())
                .bizId(FREE_TRAFFIC_PRODUCT_ID.toString())
                .build();

        //发送发放流量包消息
        rabbitTemplate.convertAndSend(rabbitMQConfig.getTrafficEventExchange(),
                rabbitMQConfig.getTrafficFreeInitRoutingKey(),eventMessage);
    }
}
```

###### 17.4.10.2.4MQ消费者开发+Feign调用

- ProductFeignService

```
package net.xdclass.feign;

import net.xdclass.util.JsonData;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

/**
 * @author 刘森飚
 * @since 2023-02-07
 */

@FeignClient(name = "dcloud-shop-service")
public interface ProductFeignService {

    /**
     * 获取流量包商品详情
     * @param productId
     * @return
     */
    @GetMapping("/api/product/v1/detail/{product_id}")
    JsonData detail(@PathVariable("product_id") long productId);

}
```

- TrafficMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.TrafficService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-06
 */

@Component
@RabbitListener(queuesToDeclare = {
        @Queue("order.traffic.queue"),
        @Queue("traffic.free_init.queue")
})
@Slf4j
public class TrafficMQListener {

    @Autowired
    private TrafficService trafficService;


    @RabbitHandler
    public void trafficHandler(EventMessage eventMessage, Message message, Channel channel){
        log.info("监听到消息trafficHandler:{}",eventMessage);
        try{
            trafficService.handleTrafficMessage(eventMessage);
        }catch (Exception e){
            log.error("消费者失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
    }
}
```

- TrafficServiceImpl

```
/**
 * 处理流量消息
 * @param eventMessage
 */
@Override
@Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
public void handleTrafficMessage(EventMessage eventMessage) {
    Long accountNo = eventMessage.getAccountNo();
    String messageType = eventMessage.getEventMessageType();
    if(EventMessageType.PRODUCT_ORDER_PAY.name().equalsIgnoreCase(messageType)){
        //付费流量包
        //订单已经支付，新增流量
        String content = eventMessage.getContent();
        Map<String, Object> orderInfoMap = JsonUtil.json2Obj(content,Map.class);
        //还原订单商品信息
        String outTradeNo = (String)orderInfoMap.get("outTradeNo");
        Integer buyNum = (Integer)orderInfoMap.get("buyNum");
        String productStr = (String) orderInfoMap.get("product");
        ProductVO productVO = JsonUtil.json2Obj(productStr, ProductVO.class);
        log.info("商品信息:{}",productVO);
        //流量包有效期
        LocalDateTime expiredDateTime = LocalDateTime.now().plusDays(productVO.getValidDay());
        Date date = Date.from(expiredDateTime.atZone(ZoneId.systemDefault()).toInstant());
        //构建流量包对象
        TrafficDO trafficDO = TrafficDO.builder()
                .accountNo(accountNo)
                .dayLimit(productVO.getDayTimes() * buyNum)
                .dayUsed(0)
                .totalLimit(productVO.getTotalTimes())
                .pluginType(productVO.getPluginType())
                .level(productVO.getLevel())
                .productId(productVO.getId())
                .outTradeNo(outTradeNo)
                .expiredDate(date).build();

        int rows = trafficManager.add(trafficDO);
        log.info("消费消息新增流量包:rows={},trafficDO={}",rows,trafficDO);
    }else if(EventMessageType.TRAFFIC_FREE_INIT.name().equalsIgnoreCase(messageType)){
        //发放免费流量包
        Long productId = Long.valueOf(eventMessage.getBizId());
        JsonData jsonData = productFeignService.detail(productId);
        //这个方法是把json转成vo类
        ProductVO productVO = jsonData.getData(new TypeReference<ProductVO>(){});
        //构建流量包对象
        TrafficDO trafficDO = TrafficDO.builder()
                .accountNo(accountNo)
                .dayLimit(productVO.getDayTimes())
                .dayUsed(0)
                .totalLimit(productVO.getTotalTimes())
                .pluginType(productVO.getPluginType())
                .level(productVO.getLevel())
                .productId(productVO.getId())
                .outTradeNo("free_init")
                .expiredDate(new Date())
                .build();
        trafficManager.add(trafficDO);
    }
}
```

#### 17.4.11分布式定时调度XXL-Job

##### 17.4.11.1XXL-job的介绍

- XXL-JOB

```
⼤众点评的员工徐雪⾥在15年发布的分布式任务调度平台，是轻量级的分布式任务调度框架，目标是开发迅速、
简单、清理、易扩展; ⽼版本是依赖quartz的定时任务触发，在v2.1.0版本开始 移除quartz依赖。

地址：https://www.xuxueli.com/xxl-job/
```

- Elastic-job

```
当当开发的分布式任务调度系统，功能强⼤，采⽤的是zookeeper实现分布式协调，具有⾼可⽤与分⽚。
2020年6⽉，ElasticJob的四个⼦项⽬已经正式迁⼊Apache仓库
由 2 个相互独⽴的⼦项⽬ ElasticJob-Lite 和 ElasticJob-Cloud 组成
ElasticJob-Lite 定位为轻量级⽆中心化解决⽅案，使⽤jar的形式提供分布式任务的协调服务；
ElasticJob-Cloud 使⽤ Mesos 的解决⽅案，额外提供资源治理、应⽤分发以及进程隔离等服务

地址：https://shardingsphere.apache.org/elasticjob/index_zh.html
```

- 常规对比图

![1675787527976](短链平台项目.assets/1675787527976.png)

- 如何选择哪⼀个分布式任务调度平台

```
XXL-Job和Elastic-Job都具有⼴泛的用户基础和完善的技术⽂档，都可以满⾜定时任务的基本功能需求
xxl-job侧重在业务实现简单和管理方便，容易学习，失败与路由策略丰富, 推荐使用在用户基数相对量少，服务器的数量在⼀定的范围内的场景下使用。
elastic-job关注的点在数据，添加了弹性扩容和数据分片的思路，更⽅便利用分布式服务器的资源, 但是学习难度量大，推荐在数据量庞大，服务器数量多的时候使用。
```

##### 17.4.11.2XXL-Job架构和概念

- xxl-job的设计思想

```
将调度⾏为抽象形成“调度中⼼”公共平台，⽽平台⾃身并不承担业务逻辑，“调度中⼼”负责发起调度请求。
将任务抽象成分散的JobHandler，交由“执⾏器”统⼀管理
“执⾏器”负责接收调度请求并执⾏对应的JobHandler中业务逻辑。
因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性
```

- 架构系统组成

```
调度中心
负责管理调度的信息，按照调度的配置来发出调度请求⽀持可视化、简单的动态管理调度信息，包括新建、删
除、更新等，这些操作都会实时⽣效，同时也⽀持监控调度结果以及执行⽇志。

执行器
负责接收请求并且执⾏任务的逻辑。任务模块专注于任务的执行操作等等，使得开发和维护更加的简单与⾼效
```

![1675842774050](短链平台项目.assets/1675842774050.png)

- XXL-Job具有哪些特性

```
执⾏器HA（分布式）：任务分布式的执⾏，任务执⾏器⽀持集群部署，可保证任务执⾏HA。
触发策略：有Cron触发、固定间隔触发、固定延时触发、API事件触发、⼈⼯触发、⽗⼦任务触发。
路由策略：执⾏器在集群部署的时候提供了丰富的路由策略，如：第⼀个、最后⼀个、轮询、随机、⼀致性HASH、最不经常使⽤LFU、最久未使⽤LRU、故障转移等等。
故障转移：如果执⾏器集群的⼀台机器发⽣故障，会⾃动切换到⼀台正常的执⾏器发送任务调度。
Rolling实时⽇志的监控：⽀持rolling⽅式查看输⼊的完整执⾏⽇志。
脚本任务：⽀持GLUE模式开发和运⾏脚本任务，包括Shell、python、node.js、php等等类型脚本。
```

##### 17.4.11.3XXl-Job的搭建

- 搭建XXL-Job相关环境

```
1.创建数据库脚本
2.部署XXL-Job服务端
3.客户端项目添加依赖
```

- 注意

```
Client-Server通信，需要网络互通才⾏.
所以不能⼀个是阿⾥云ECS，⼀个是本地电脑.
建议：本地电脑安装Docker，或者本地Linux虚拟机安装Docker部署.
```

###### 17.4.11.3.1创建数据库脚本

```
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for xxl_job_group
-- ----------------------------
DROP TABLE IF EXISTS `xxl_job_group`;
CREATE TABLE `xxl_job_group` (
  `id` int NOT NULL AUTO_INCREMENT,
  `app_name` varchar(64) NOT NULL COMMENT '执行器AppName',
  `title` varchar(12) NOT NULL COMMENT '执行器名称',
  `address_type` tinyint NOT NULL DEFAULT '0' COMMENT '执行器地址类型：0=自动注册、1=手动录入',
  `address_list` varchar(512) DEFAULT NULL COMMENT '执行器地址列表，多地址逗号分隔',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of xxl_job_group
-- ----------------------------
BEGIN;
INSERT INTO `xxl_job_group` VALUES (2, 'data-app-executor', '时间段内违规短链检测', 0, NULL);
COMMIT;

-- ----------------------------
-- Table structure for xxl_job_info
-- ----------------------------
DROP TABLE IF EXISTS `xxl_job_info`;
CREATE TABLE `xxl_job_info` (
  `id` int NOT NULL AUTO_INCREMENT,
  `job_group` int NOT NULL COMMENT '执行器主键ID',
  `job_cron` varchar(128) NOT NULL COMMENT '任务执行CRON',
  `job_desc` varchar(255) NOT NULL,
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `author` varchar(64) DEFAULT NULL COMMENT '作者',
  `alarm_email` varchar(255) DEFAULT NULL COMMENT '报警邮件',
  `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT '执行器路由策略',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT '阻塞处理策略',
  `executor_timeout` int NOT NULL DEFAULT '0' COMMENT '任务执行超时时间，单位秒',
  `executor_fail_retry_count` int NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `glue_type` varchar(50) NOT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) DEFAULT NULL COMMENT 'GLUE备注',
  `glue_updatetime` datetime DEFAULT NULL COMMENT 'GLUE更新时间',
  `child_jobid` varchar(255) DEFAULT NULL COMMENT '子任务ID，多个逗号分隔',
  `trigger_status` tinyint NOT NULL DEFAULT '0' COMMENT '调度状态：0-停止，1-运行',
  `trigger_last_time` bigint NOT NULL DEFAULT '0' COMMENT '上次调度时间',
  `trigger_next_time` bigint NOT NULL DEFAULT '0' COMMENT '下次调度时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of xxl_job_info
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for xxl_job_lock
-- ----------------------------
DROP TABLE IF EXISTS `xxl_job_lock`;
CREATE TABLE `xxl_job_lock` (
  `lock_name` varchar(50) NOT NULL COMMENT '锁名称',
  PRIMARY KEY (`lock_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of xxl_job_lock
-- ----------------------------
BEGIN;
INSERT INTO `xxl_job_lock` VALUES ('schedule_lock');
COMMIT;

-- ----------------------------
-- Table structure for xxl_job_log
-- ----------------------------
DROP TABLE IF EXISTS `xxl_job_log`;
CREATE TABLE `xxl_job_log` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `job_group` int NOT NULL COMMENT '执行器主键ID',
  `job_id` int NOT NULL COMMENT '任务，主键ID',
  `executor_address` varchar(255) DEFAULT NULL COMMENT '执行器地址，本次执行的地址',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT '执行器任务分片参数，格式如 1/2',
  `executor_fail_retry_count` int NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `trigger_time` datetime DEFAULT NULL COMMENT '调度-时间',
  `trigger_code` int NOT NULL COMMENT '调度-结果',
  `trigger_msg` text COMMENT '调度-日志',
  `handle_time` datetime DEFAULT NULL COMMENT '执行-时间',
  `handle_code` int NOT NULL COMMENT '执行-状态',
  `handle_msg` text COMMENT '执行-日志',
  `alarm_status` tinyint NOT NULL DEFAULT '0' COMMENT '告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败',
  PRIMARY KEY (`id`),
  KEY `I_trigger_time` (`trigger_time`),
  KEY `I_handle_code` (`handle_code`)
) ENGINE=InnoDB AUTO_INCREMENT=89467 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of xxl_job_log
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for xxl_job_log_report
-- ----------------------------
DROP TABLE IF EXISTS `xxl_job_log_report`;
CREATE TABLE `xxl_job_log_report` (
  `id` int NOT NULL AUTO_INCREMENT,
  `trigger_day` datetime DEFAULT NULL COMMENT '调度-时间',
  `running_count` int NOT NULL DEFAULT '0' COMMENT '运行中-日志数量',
  `suc_count` int NOT NULL DEFAULT '0' COMMENT '执行成功-日志数量',
  `fail_count` int NOT NULL DEFAULT '0' COMMENT '执行失败-日志数量',
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_trigger_day` (`trigger_day`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of xxl_job_log_report
-- ----------------------------
BEGIN;
INSERT INTO `xxl_job_log_report` VALUES (1, '2021-10-14 00:00:00', 0, 0, 0);
INSERT INTO `xxl_job_log_report` VALUES (2, '2021-10-13 00:00:00', 0, 0, 0);
INSERT INTO `xxl_job_log_report` VALUES (3, '2021-10-12 00:00:00', 0, 0, 0);
INSERT INTO `xxl_job_log_report` VALUES (4, '2021-10-15 00:00:00', 0, 0, 2427);
INSERT INTO `xxl_job_log_report` VALUES (5, '2021-10-16 00:00:00', 0, 0, 11348);
INSERT INTO `xxl_job_log_report` VALUES (6, '2021-10-17 00:00:00', 0, 0, 21517);
INSERT INTO `xxl_job_log_report` VALUES (7, '2021-10-18 00:00:00', 2, 0, 15558);
INSERT INTO `xxl_job_log_report` VALUES (8, '2021-10-19 00:00:00', 1, 0, 7057);
INSERT INTO `xxl_job_log_report` VALUES (9, '2021-10-20 00:00:00', 0, 0, 2005);
INSERT INTO `xxl_job_log_report` VALUES (10, '2021-10-24 00:00:00', 1, 0, 1827);
INSERT INTO `xxl_job_log_report` VALUES (11, '2021-10-23 00:00:00', 0, 0, 0);
INSERT INTO `xxl_job_log_report` VALUES (12, '2021-10-22 00:00:00', 0, 0, 0);
INSERT INTO `xxl_job_log_report` VALUES (13, '2022-02-10 00:00:00', 0, 0, 0);
INSERT INTO `xxl_job_log_report` VALUES (14, '2022-02-09 00:00:00', 0, 0, 0);
INSERT INTO `xxl_job_log_report` VALUES (15, '2022-02-08 00:00:00', 0, 0, 0);
COMMIT;

-- ----------------------------
-- Table structure for xxl_job_logglue
-- ----------------------------
DROP TABLE IF EXISTS `xxl_job_logglue`;
CREATE TABLE `xxl_job_logglue` (
  `id` int NOT NULL AUTO_INCREMENT,
  `job_id` int NOT NULL COMMENT '任务，主键ID',
  `glue_type` varchar(50) DEFAULT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) NOT NULL COMMENT 'GLUE备注',
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of xxl_job_logglue
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for xxl_job_registry
-- ----------------------------
DROP TABLE IF EXISTS `xxl_job_registry`;
CREATE TABLE `xxl_job_registry` (
  `id` int NOT NULL AUTO_INCREMENT,
  `registry_group` varchar(50) NOT NULL,
  `registry_key` varchar(255) NOT NULL,
  `registry_value` varchar(255) NOT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`)
) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of xxl_job_registry
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for xxl_job_user
-- ----------------------------
DROP TABLE IF EXISTS `xxl_job_user`;
CREATE TABLE `xxl_job_user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '账号',
  `password` varchar(50) NOT NULL COMMENT '密码',
  `role` tinyint NOT NULL COMMENT '角色：0-普通用户、1-管理员',
  `permission` varchar(255) DEFAULT NULL COMMENT '权限：执行器ID列表，多个逗号分割',
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_username` (`username`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of xxl_job_user
-- ----------------------------
BEGIN;
INSERT INTO `xxl_job_user` VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 1, NULL);
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
```

![1675844069668](短链平台项目.assets/1675844069668.png)

###### 17.4.11.3.2部署server

- 本地Linux虚拟机安装Docker部署
- 一键安装二进制Docker脚本

```
#!/bin/bash
#
#**********************************************************************************************
#Author:        liusenbiao
#QQ:            1805336068
#Date:          2022-07-31
#FileName:      install_docker_binary.sh
#System:        适用版本:centos 7/8 & ubuntu 18.04/20.04
#Description:   一键安装二进制docker
#*********************************************************************************************
SRC_DIR=/usr/local/src
COLOR="echo -e \\033[01;31m"
END='\033[0m'
URL='https://mirrors.cloud.tencent.com/docker-ce/linux/static/stable/x86_64/'
DOCKER_FILE=docker-19.03.10.tgz

os(){
    OS_ID=`sed -rn '/^NAME=/s@.*="([[:alpha:]]+).*"$@\1@p' /etc/os-release`
}

check_file (){
    cd ${SRC_DIR}
    rpm -q wget &> /dev/null || yum -y install wget &> /dev/null
    if [ ! -e ${DOCKER_FILE} ];then
        ${COLOR}"缺少${DOCKER_FILE}文件,如果是离线包,请把文件放到${SRC_DIR}目录下"${END}
        ${COLOR}'开始下载DOCKER二进制安装包'${END}
        wget ${URL}${DOCKER_FILE} || { ${COLOR}"DOCKER二进制安装包下载失败"${END}; exit; } 
    else
        ${COLOR}"相关文件已准备好"${END}
    fi
}

install(){ 
    [ -f /usr/bin/docker ] && { ${COLOR}"DOCKER已存在，安装失败"${END};exit; }
    ${COLOR}"开始安装DOCKER..."${END}
    tar xf ${DOCKER_FILE} 
    mv docker/* /usr/bin/
    cat > /lib/systemd/system/docker.service <<-EOF
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target

[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
#add label-name and reomote visit functions
ExecStart=/usr/bin/dockerd -H unix://var/run/docker.sock --label="name=docker1-liu" -H tcp://0.0.0.0:6666
ExecReload=/bin/kill -s HUP \$MAINPID
# Having non-zero Limit*s causes performance problems due to accounting overhead
# in the kernel. We recommend using cgroups to do container-local accounting.
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
# Uncomment TasksMax if your systemd version supports it.
# Only systemd 226 and above support this version.
#TasksMax=infinity
TimeoutStartSec=0
# set delegate yes so that systemd does not reset the cgroups of docker containers
Delegate=yes
# kill only the docker process, not all processes in the cgroup
KillMode=process
# restart the docker process if it exits prematurely
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s

[Install]
WantedBy=multi-user.target
EOF
    mkdir -p /etc/docker
    tee /etc/docker/daemon.json <<-'EOF'
{
    "registry-mirrors": [
        "https://h1ea2sza.mirror.aliyuncs.com",
        "https://docker.mirrors.ustc.edu.cn",
        "http://f1361db2.m.daocloud.io",
        "https://registry.docker-cn.com",
        "https://dockerhub.azk8s.cn",
        "https://reg-mirror.qiniu.com",
        "https://hub-mirror.c.163.com",
        "https://mirror.ccs.tencentyun.com"
    ]
}
EOF
    systemctl daemon-reload
    systemctl enable --now docker &> /dev/null
    systemctl is-active docker &> /dev/null && ${COLOR}"Docker 服务启动成功"${END} || { ${COLOR}"Docker 启动失败"${END};exit; }
    docker version && ${COLOR}"Docker 安装成功"${END} || ${COLOR}"Docker 安装失败"${END}
}

set_swap_limit(){
    if [ ${OS_ID} == "Ubuntu" ];then
        ${COLOR}'设置Docker的"WARNING: No swap limit support"警告'${END}
        sed -ri '/^GRUB_CMDLINE_LINUX=/s@"$@ swapaccount=1"@' /etc/default/grub
        update-grub &> /dev/null
        ${COLOR}"10秒后，机器会自动重启"${END}
        sleep 10
        reboot
    fi
}


set_centos_alias(){
    cat >>~/.bashrc <<-EOF
alias cdnet="cd /etc/sysconfig/network-scripts"
alias vie0="vim /etc/sysconfig/network-scripts/ifcfg-eth0"
alias vie1="vim /etc/sysconfig/network-scripts/ifcfg-eth1"
alias scandisk="echo '- - -' > /sys/class/scsi_host/host0/scan;echo '- - -' > /sys/class/scsi_host/host1/scan;echo '- - -' > /sys/class/scsi_host/host2/scan"
alias rmi="docker images -qa|xargs docker rmi -f"
alias rmc="docker ps -qa|xargs docker rm -f"
EOF
source ~/.bashrc
}


set_ubuntu_alias(){
    cat >>~/.bashrc <<-EOF
alias cdnet="cd /etc/netplan"
alias scandisk="echo '- - -' > /sys/class/scsi_host/host0/scan;echo '- - -' > /sys/class/scsi_host/host1/scan;echo '- - -' > /sys/class/scsi_host/host2/scan"
EOF
alias rmi="docker images -qa|xargs sudo docker rmi -f"
alias rmc="docker ps -qa|xargs sudo docker rm -f"
sudo source ~/.bashrc
}


set_alias(){
    if [ ${OS_ID} == "CentOS" ] &> /dev/null;then
        set_centos_alias        
    else
        set_ubuntu_alias
    fi
}

main(){
    os
    check_file
    install
    set_alias
    set_swap_limit
}

main
```

![1675844878652](短链平台项目.assets/1675844878652.png)

- 虚拟机上部署xxl-job

```
docker run -d -e PARAMS="--spring.datasource.url=jdbc:mysql://101.200.159.132:3306/xxl_job?Unicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai \
> --spring.datasource.username=root \
> --spring.datasource.password=Liu19971009 \
> --xxl.job.accessToken=Liu19971009" \
> -p 8080:8080 \
> --name xxl-job-admin --restart=always xuxueli/xxl-job-admin:2.2.0
```

![1675851928057](短链平台项目.assets/1675851928057.png)

- 登录

```
账号:admin
密码：123456


登录网址：http://10.0.0.67:8080/xxl-job-admin/
```

![1675852225025](短链平台项目.assets/1675852225025.png)

##### 17.4.11.4XXL-Job进行整合

###### 17.4.11.4.1添加依赖

- 聚合工程添加依赖

```
<!-- https://mvnrepository.com/artifact/com.xuxueli/xxl-job-core -->
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-job-core</artifactId>
    <version>2.2.0</version>
</dependency>
```

- common项目添加依赖

```
<!-- https://mvnrepository.com/artifact/com.xuxueli/xxl-job-core -->
<!--分布式调度-->
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-job-core</artifactId>
</dependency>
```

###### 17.4.11.4.2添加日志文件

- logback.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="false" scan="true" scanPeriod="1 seconds">

    <contextName>logback</contextName>
    <property name="log.path" value="./data/logs/xxl-job/app.log"/>

    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log.path}.%d{yyyy-MM-dd}.zip</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%date %level [%thread] %logger{36} [%file : %line] %msg%n
            </pattern>
        </encoder>
    </appender>

    <root level="info">
        <appender-ref ref="console"/>
        <appender-ref ref="file"/>
    </root>

</configuration>
```

###### 17.4.11.4.3properties配置文件

- account/application.properties

```
#----------xxl-job配置--------------
logging.config=classpath:logback.xml
#调度中心部署地址,多个配置逗号分隔 "http://address01,http://address02"
xxl.job.admin.addresses=http://10.0.0.67:8080/xxl-job-admin
#执行器token，非空时启用 xxl-job, access token
xxl.job.accessToken=Liu19971009
# 执行器app名称,和控制台那边配置一样的名称，不然注册不上去
xxl.job.executor.appname=traffic-app-executor
# [选填]执行器注册：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。
#从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。
xxl.job.executor.address=
#[选填]执行器IP ：默认为空表示自动获取IP（即springboot容器的ip和端口，可以自动获取，也可以指定），多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 "执行器注册" 和 "调度中心请求并触发任务"，
xxl.job.executor.ip=
# [选填]执行器端口号：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；
xxl.job.executor.port=9999
#执行器日志文件存储路径，需要对该路径拥有读写权限；为空则使用默认路径
xxl.job.executor.logpath=./data/logs/xxl-job/executor
#执行器日志保存天数
xxl.job.executor.logretentiondays=30
```

![1675853818617](短链平台项目.assets/1675853818617.png)

###### 17.4.11.4.4xxl配置类

```
package net.xdclass.config;

import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author 刘森飚
 * @since 2023-02-08
 */
@Configuration
@Slf4j
public class XxlJobConfig {


    @Value("${xxl.job.admin.addresses}")
    private String adminAddresses;

    @Value("${xxl.job.executor.appname}")
    private String appName;

    @Value("${xxl.job.executor.ip}")
    private String ip;

    @Value("${xxl.job.executor.port}")
    private int port;

    @Value("${xxl.job.accessToken}")
    private String accessToken;

    @Value("${xxl.job.executor.logpath}")
    private String logPath;

    @Value("${xxl.job.executor.logretentiondays}")
    private int logRetentionDays;


    @Bean
    public XxlJobSpringExecutor xxlJobSpringExecutor(){

        log.info("》》》》》》流量包 xxl job 配置初始化");
        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
        xxlJobSpringExecutor.setAppname(appName);
        xxlJobSpringExecutor.setIp(ip);
        xxlJobSpringExecutor.setPort(port);
        xxlJobSpringExecutor.setAccessToken(accessToken);
        xxlJobSpringExecutor.setLogPath(logPath);
        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);

        return xxlJobSpringExecutor;
    }

}
```

##### 17.4.11.5创建分布式调度任务

###### 17.4.11.5.1TrafficJobHandler

```
package net.xdclass.job;

import com.xxl.job.core.biz.model.ReturnT;
import com.xxl.job.core.handler.annotation.XxlJob;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.service.TrafficService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-08
 */

@Component
@Slf4j
public class TrafficJobHandler {


    @Autowired
    private TrafficService trafficService;

    /**
     * 过期流量包处理
     * @param param
     * @return
     */
    @XxlJob(value = "trafficExpiredHandler",init = "init",destroy = "destroy")
    public ReturnT<String> execute(String param){
        log.info("execute 任务方法触发成功,删除过期流量包");
        trafficService.deleteExpireTraffic();
        return ReturnT.SUCCESS;
    }

    private void init(){

        log.info("MyJobHandler init >>>>>");
    }

    private void destroy(){
        log.info(" MyJobHandler destroy >>>>>");
    }

}
```
###### 17.4.11.5.2TrafficServiceImpl

```
/**
 * 删除过期流量包
 * @return
 */
@Override
public boolean deleteExpireTraffic() {
    return trafficManager.deleteExpireTraffic();
}
```
###### 17.4.11.5.3TrafficManagerImpl

```
/**
 * 删除过期流量包
 * @return
 */
@Override
public boolean deleteExpireTraffic() {
    int rows = trafficMapper.delete(new QueryWrapper<TrafficDO>()
            .le("expired_date",new Date()));
    log.info("删除过期流量包行数：rows={}",rows);
    return true;
}
```

###### 17.4.11.5.4触发任务

![1675857179478](短链平台项目.assets/1675857179478.png)

![1675857374119](短链平台项目.assets/1675857374119.png)

![1675857412452](短链平台项目.assets/1675857412452.png)

![1675857454786](短链平台项目.assets/1675857454786.png)

#### 17.4.12流量包更新维护

##### 17.4.12.1Redis设计思想

- 背景

```
redis的key配置了过期时间，这个是怎么被删除的？
redis数据明明过期了，怎么还占用着内存？
```

- Redis key过期策略

```
定期删除+惰性删除
```

- 定期删除

```
Redis会每秒进行十次过期扫描，过期扫描不会遍历容器中所有的 key，而是采用⼀种特殊策略
从容器中随机 20 个 key；
删除这 20 个 key 中已经过期的 key；
如果过期的 key ⽐率超过 1/4，那就重复步骤 1；
```

- 惰性删除

```
当某个客户端试图访问key时，发现该key已超时会把此key从内存中删除。
```

- 需求

```
1.每个用户每天都有流量包次数，第二天自动恢复，怎么维护更新？
2.用户量上千万上亿的时候，如果利用定时任务每天去数据库更新流量包使用次数，会造成很大的延迟，怎么办？
3.你确定这几千万用户都是活跃用户？都会使用你的短链流量包？你每天更新，用户确不用，有什么意义？
```

##### 17.4.12.2惰性更新策略

- 流量包更新维护需求

```
付费流量包：通过购买，然后每天都是有⼀定的使用次数。
免费流量包：业务为了拉新，⿎励新用户注册，赠送⼀个免费流量包，每天允许有⼀定次免费创建短链的次数。
```

- 采用惰性策略解决方案

```
不用每天更新全部流量包，用的时候再更新即可

好处
只要用户有使用，流量包都是可以得到更新
没使用的用户流量包不会去更新，避免了海量数据下更新维护的问题
如果采用定时更新，几千万用户更新记录都是会有不少时间的延迟
```

- 大体步骤

```
查询用户全部可用流量包
遍历用户可用流量包
判断是否更新-用⽇期判断（要么都更新过，要么都没更新，根据gmt_modified）
 没更新的流量包后加⼊【待更新集合】中
  增加【今天剩余可用总次数】
 已经更新的判断是否超过当天使用次数
  如果没超过则增加【今天剩余可用总次数】
  超过则忽略
更新用户今⽇流量包相关数据
扣减使用的某个流量包使用次数
```

##### 17.4.12.3流量包Manager开发

###### 17.4.12.3.1TrafficManager

```
/**
 * 查找可用的短链流量包(未过期)
 * 免费流量包和付费流量包
 * @param accountNo
 * @return
 */
List<TrafficDO> selectAvailableTraffics(Long accountNo);


/**
 * 给某个流量包增加使用次数
 *
 * @param trafficId
 * @param accountNo
 * @param usedTimes
 * @return
 */
int addDayUsedTimes(Long accountNo, Long trafficId, Integer usedTimes) ;



/**
 * 恢复流量包使用当天次数
 * @param accountNo
 * @param trafficId
 * @param useTimes
 */
int releaseUsedTimes(Long accountNo, Long trafficId, Integer useTimes);


/**
 * 批量更新流量包使用次数为0
 * @param accountNo
 * @param unUpdatedTrafficIds
 */
int batchUpdateUsedTimes(Long accountNo, List<Long> unUpdatedTrafficIds);
```

###### 17.4.12.3.2TrafficManagerImpl

```
/**
 * 查找可用的短链流量包(未过期),包括免费流量包
 * 为了过滤出免费和付费流量包
 *  select * from traffic where account_no =111 and (expired_date >= ? OR out_trade_no=free_init )
 * @param accountNo
 * @return
 */
@Override
public List<TrafficDO> selectAvailableTraffics(Long accountNo) {
    String today = TimeUtil.format(new Date(),"yyyy-MM-dd");
    QueryWrapper<TrafficDO> queryWrapper = new QueryWrapper<TrafficDO>();
    queryWrapper.eq("account_no",accountNo);
    //拿到免费流量包和付费流量包
    queryWrapper.and(wrapper->wrapper.ge("expired_date",today)
            .or().eq("out_trade_no","free_init"));
    return trafficMapper.selectList(queryWrapper);
}



/**
 * 增加流量包使用次数
 * @param accountNo
 * @param trafficId
 * @param usedTimes
 * @return
 */
@Override
public int addDayUsedTimes(Long accountNo, Long trafficId, Integer usedTimes) {

    return trafficMapper.addDayUsedTimes(accountNo,trafficId,usedTimes);
}



/**
 * 恢复某个流量包使用次数，回滚流量包
 * @param accountNo
 * @param trafficId
 * @param usedTimes
 * @return
 */
@Override
public int releaseUsedTimes(Long accountNo, Long trafficId, Integer usedTimes) {
    return trafficMapper.releaseUsedTimes(accountNo,trafficId,usedTimes);
}



/**
 * 批量更新流量包使用次数为0
 * @param accountNo
 * @param unUpdatedTrafficIds
 */
@Override
public int batchUpdateUsedTimes(Long accountNo, List<Long> unUpdatedTrafficIds) {

    int rows = trafficMapper.update(null, new UpdateWrapper<TrafficDO>()
            .eq("account_no", accountNo)
            .in("id", unUpdatedTrafficIds)
            .set("day_used", 0));

    return rows;
```

###### 17.4.12.3.3TrafficMapper

```
package net.xdclass.mapper;

import net.xdclass.model.TrafficDO;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.apache.ibatis.annotations.Param;

/**
 * @author 刘森飚
 * @since 2023-01-09
 */
public interface TrafficMapper extends BaseMapper<TrafficDO> {


    /**
     * 给某个流量包增加天使用次数
     * @param accountNo
     * @param trafficId
     * @param usedTimes
     * @return
     */
    int addDayUsedTimes(@Param("accountNo") Long accountNo,@Param("trafficId") Long trafficId,
                        @Param("usedTimes") Integer usedTimes);


    /**
     * 恢复某个流量包使用次数
     * @param accountNo
     * @param trafficId
     * @param usedTimes
     * @return
     */
    int releaseUsedTimes(@Param("accountNo") Long accountNo, @Param("trafficId") Long trafficId,
                         @Param("usedTimes") Integer usedTimes);
}
```

###### 17.4.12.3.4TrafficMapper.xml

```
<!--给某个流量包增加天使用次数-->
<update id="addDayUsedTimes">

    update traffic set day_used = day_used + #{usedTimes}
    where id = #{trafficId} and account_no = #{accountNo}
    and (day_limit - day_used) >= #{usedTimes} limit 1

</update>


<!--恢复流量包-->
<update id="releaseUsedTimes">

     update traffic set day_used = day_used - #{usedTimes}
     where id = #{trafficId} and account_no = #{accountNo}
     and (day_used - #{usedTimes}) >= 0 limit 1;
</update>
```
##### 17.4.12.4扣减流量包开发

###### 17.4.12.4.1UseTrafficVO

```
package net.xdclass.controller;

import net.xdclass.controller.request.TrafficPageRequest;
import net.xdclass.controller.request.UseTrafficRequest;
import net.xdclass.service.TrafficService;
import net.xdclass.util.JsonData;
import net.xdclass.vo.TrafficVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-07
 */

@RestController
@RequestMapping("/api/traffic/v1")
public class TrafficController {

    @Autowired
    private TrafficService trafficService;


    /**
     * 扣减流量包
     *
     * @param useTrafficRequest
     * @param request
     * @return
     */
    @PostMapping("reduce")
    public JsonData useTraffic(@RequestBody UseTrafficRequest useTrafficRequest, HttpServletRequest request){

        //具体使用流量包逻辑  TODO
        JsonData jsonData = trafficService.reduce(useTrafficRequest);

        return jsonData;
    }



    /**
     * 分页查询流量包列表，查看可用的流量包
     * @param request
     * @return
     */
    @RequestMapping("page")
    public JsonData pageAvailable(@RequestBody TrafficPageRequest request){
        Map<String,Object> pageMap = trafficService.pageAvailable(request);
        return JsonData.buildSuccess(pageMap);
    }


    /**
     * 查找某个流量包详情
     * @param trafficId
     * @return
     */
    @GetMapping("/detail/{trafficId}")
    public JsonData detail(@PathVariable("trafficId") long trafficId){
        TrafficVO trafficVO = trafficService.detail(trafficId);
        return JsonData.buildSuccess(trafficVO);
    }
}
```

###### 17.4.12.4.2UseTrafficRequest

```
package net.xdclass.controller.request;

import lombok.Data;

/**
 * @author 刘森飚
 * @since 2023-02-07
 */


@Data
public class UseTrafficRequest {

    /**
     * 账号
     */
    private Long accountNo;

    /**
     * 业务id, 短链码
     */
    private String bizId;
}
```

###### 17.4.12.4.3TrafficController

```
/**
 * 扣减流量包
 *
 * @param useTrafficRequest
 * @param request
 * @return
 */
@PostMapping("reduce")
public JsonData useTraffic(@RequestBody UseTrafficRequest useTrafficRequest, HttpServletRequest request){

    //具体使用流量包逻辑  TODO
    JsonData jsonData = trafficService.reduce(useTrafficRequest);

    return jsonData;
}
```

###### 17.4.12.4.4TrafficServiceImpl

```
/**
 *  查询用户全部可用流量包
 *  遍历用户可用流量包
 *    判断是否更新-用日期判断
 *      没更新的流量包后加入【待更新集合】中
 *        增加【今天剩余可用总次数】
 *      已经更新的判断是否超过当天使用次数
 *        如果没超过则增加【今天剩余可用总次数】
 *        超过则忽略
 *
 * * 更新用户今日流量包相关数据
 * * 扣减使用的某个流量包使用次数
 * @param trafficRequest
 * @return
 */
@Override
@Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
public JsonData reduce(UseTrafficRequest trafficRequest) {
    Long accountNo = trafficRequest.getAccountNo();
    //处理流量包，筛选出未更新流量包，当前使用的流量包
    UseTrafficVO useTrafficVO = processTrafficList(accountNo);
    log.info("今天可用总次数:{},当前使用流量包:{}",
            useTrafficVO.getDayTotalLeftTimes(),useTrafficVO.getCurrentTrafficDO());
    //如果没有可用流量包
    if(useTrafficVO.getCurrentTrafficDO() == null){
        return JsonData.buildResult(BizCodeEnum.TRAFFIC_REDUCE_FAIL);
    }
    log.info("待更新流量包列表:{}",useTrafficVO.getUnUpdatedTrafficIds());
    if(useTrafficVO.getUnUpdatedTrafficIds().size() > 0){
        //更新今日流量包
        trafficManager.batchUpdateUsedTimes(accountNo,useTrafficVO.getUnUpdatedTrafficIds());
    }
    //先更新，再扣减当前使用的流量包
    //扣减流量包就是意味着增加了一次当天流量包的使用次数
    int rows = trafficManager.addDayUsedTimes(accountNo,useTrafficVO.getCurrentTrafficDO().getId(),1);
    if(rows != 1){
        throw new BizException(BizCodeEnum.TRAFFIC_REDUCE_FAIL);
    }
    return JsonData.buildSuccess();
}



/**
 * 处理流量包
 * 筛选出未更新流量包
 * 当前使用的流量包
 * @param accountNo
 * @return
 */
private UseTrafficVO processTrafficList(Long accountNo) {
    //全部流量包
    List<TrafficDO> list = trafficManager.selectAvailableTraffics(accountNo);
    if(list == null || list.size() == 0){ throw  new BizException(BizCodeEnum.TRAFFIC_EXCEPTION); }
    //天剩余可用总次数
    Integer dayTotalLeftTimes = 0;
    //当前使用
    TrafficDO currentTrafficDO = null;
    //没过期，但是今天没更新的流量包id列表
    List<Long> unUpdatedTrafficIds = new ArrayList<>();
    //今天日期
    String todayStr = TimeUtil.format(new Date(),"yyyy-MM-dd");
    //遍历用户所有可用流量包
    for(TrafficDO trafficDO : list){
        String trafficUpdateDate = TimeUtil.format(trafficDO.getGmtModified(),"yyyy-MM-dd");
        if(todayStr.equalsIgnoreCase(trafficUpdateDate)){
            //已经更新  天剩余可用总次数 = 总次数 - 已用
            int dayLeftTimes = trafficDO.getDayLimit() - trafficDO.getDayUsed();
            dayTotalLeftTimes = dayTotalLeftTimes + dayLeftTimes;
            //选取当次使用流量包
            //currentTrafficDO == null表示当前流量包没有在被人使用
            if(dayLeftTimes > 0 && currentTrafficDO == null){
                currentTrafficDO = trafficDO;
            }
        }else {
            //未更新
            dayTotalLeftTimes = dayTotalLeftTimes + trafficDO.getDayLimit();
            //记录未更新的流量包
            unUpdatedTrafficIds.add(trafficDO.getId());
            //选取当次使用流量包
            if(currentTrafficDO == null){
                currentTrafficDO = trafficDO;
            }
        }
    }
    UseTrafficVO useTrafficVO = new UseTrafficVO(dayTotalLeftTimes,currentTrafficDO,unUpdatedTrafficIds);
    return useTrafficVO;
}
```

#### 17.4.13短链服务+流量包联动

##### 17.4.13.1高并发下扣减流量包解决

- 性能需求分析

```
创建短链->扣减流量包(RPC)->发送MQ消息
在调用rpc的过程中要经过多次数据库io，高并发下性能很差，该怎么解决？
类似于商城下的秒杀活动该如何设计？？
```

- 扣减流量包性能优化解决方案

![1675946093958](短链平台项目.assets/1675946093958.png)

- 电商秒杀方案

![1675946116629](短链平台项目.assets/1675946116629.png)

##### 17.4.13.2创建短链和流量包联动开发

- 需求

```
创建短链
扣减流量包
发送MQ
```

###### 17.4.13.2.1鉴权增加token

- link/application.properties
- account/application.properties

```
#用于rpc调用token验证
rpc.token=Liu19971009
```

###### 17.4.13.2.2UseTrafficRequest

- link/UseTrafficRequest

```
package net.xdclass.controller.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author 刘森飚
 * @since 2023-02-07
 */


@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class UseTrafficRequest {

    /**
     * 账号
     */
    private Long accountNo;

    /**
     * 业务id, 短链码
     */
    private String bizId;
}
```

###### 17.4.13.2.3TrafficFeignService

- link/TrafficFeignService

```
package net.xdclass.feign;

import net.xdclass.controller.request.UseTrafficRequest;
import net.xdclass.util.JsonData;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;


/**
 * @author 刘森飚
 * @since 2023-02-09
 */

@FeignClient(name = "dcloud-account-service")
public interface TrafficFeignService {

    /**
     * 使用流量包
     * @param request
     * @return
     */
    @PostMapping(value = "/api/traffic/v1/reduce",headers = {"rpc-token=${rpc.token}"})
    JsonData useTraffic(@RequestBody UseTrafficRequest request);

}
```

###### 17.4.13.2.4ShortLinkServiceImpl

```
if (result > 0) {
    //加锁成功
    //C端处理
    if (EventMessageType.SHORT_LINK_ADD_LINK.name().equalsIgnoreCase(messageType)) {
        // 查询短链码是否存在
        ShortLinkDO shortLinkCodeDOInDB = shortLinkManager.findByShortLinkCode(shortLinkCode);
        if (shortLinkCodeDOInDB == null) {
            //流量包扣减成功，在创建短链码
            //在此行添加代码
            boolean reduceFlag = reduceTraffic(eventMessage,shortLinkCode);
            if(reduceFlag){
                ShortLinkDO shortLinkDO = ShortLinkDO.builder()
                        .accountNo(accountNo).code(shortLinkCode)
                        .title(addRequest.getTitle()).originalUrl(addRequest.getOriginalUrl())
                        .domain(domainDO.getValue()).groupId(linkGroupDO.getId())
                        .expired(addRequest.getExpired()).sign(originalUrlDigest)
                        .state(ShortLinkStateEnum.ACTIVE.name()).del(0).build();
                shortLinkManager.addShortLink(shortLinkDO);
                return true;
            }
            
   
   
   
  
    /**
     * 扣减流量包
     * @param eventMessage
     * @param shortLinkCode
     * @return
     */
    private boolean reduceTraffic(EventMessage eventMessage, String shortLinkCode) {
        UseTrafficRequest request = UseTrafficRequest.builder()
                .accountNo(eventMessage.getAccountNo())
                .bizId(shortLinkCode)
                .build();
        JsonData jsonData = trafficFeignService.useTraffic(request);
        if(jsonData.getCode() != 0){
            log.error("流量包不足，扣减失败:{}",eventMessage);
            return false;
        }
        return true;
    }
```

###### 17.4.13.2.5TrafficController

- account/TrafficController

```
@RestController
@RequestMapping("/api/traffic/v1")
public class TrafficController {

    @Autowired
    private TrafficService trafficService;

    @Value("${rpc.token}")
    private String rpcToken;


    /**
     * 扣减流量包
     *
     * @param useTrafficRequest
     * @param request
     * @return
     */
    @PostMapping("reduce")
    public JsonData useTraffic(@RequestBody UseTrafficRequest useTrafficRequest, HttpServletRequest request){
        String requestToken = request.getHeader("rpc-token");
        if(rpcToken.equalsIgnoreCase(requestToken)){
            //具体使用流量包逻辑
            JsonData jsonData = trafficService.reduce(useTrafficRequest);
            return jsonData;
        }else {
            return JsonData.buildError("非法访问");
        }
    }
```

###### 17.4.13.2.6InterceptorConfig

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Slf4j
public class InterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(new LoginInterceptor())
                //添加拦截的路径
                .addPathPatterns("/api/account/*/**", "/api/traffic/*/**")

                //不拦截
                .excludePathPatterns(
                        "/api/account/*/register","/api/account/*/upload","/api/account/*/login",
                        "/api/notify/v1/captcha","/api/notify/*/send_code","/api/traffic/*/reduce");
    }
}
```

##### 17.4.13.3日剩余流量包计算存储redis

###### 17.4.13.3.1RedisKey

- common/RedisKey

```
package net.xdclass.constant;


/**
 * @author 刘森飚
 * @since 2023-01-30
 */

public class RedisKey {
    /**
     * 验证码缓存key，第一个是类型,第二个是唯一标识比如手机号或者邮箱
     */
    public static final String CHECK_CODE_KEY = "code:%s:%s";


    /**
     * 提交订单令牌的缓存key,第一个是账号，第二个是token
     */
    public static final String SUBMIT_ORDER_TOKEN_KEY = "order:submit:%s:%s";



    //此行添加代码
    /**
     * 1天的可用的总流量包
     */
    public static final String DAY_TOTAL_TRAFFIC = "lock:traffic:day_total:%s";
}
```

###### 17.4.13.3.2TimeUtil

```
/**
 * 获取当天剩余的秒数,用于流量包过期配置
 * @param currentDate
 * @return
 */
public static Integer getRemainSecondsOneDay(Date currentDate) {
    LocalDateTime midnight = LocalDateTime.ofInstant(currentDate.toInstant(),
            ZoneId.systemDefault()).plusDays(1).withHour(0).withMinute(0)
            .withSecond(0).withNano(0);

    LocalDateTime currentDateTime = LocalDateTime.ofInstant(currentDate.toInstant(),
            ZoneId.systemDefault());
    long seconds = ChronoUnit.SECONDS.between(currentDateTime, midnight);
    return (int) seconds;
}
```

###### 17.4.13.3.3TrafficServiceImpl

```
/**
 * 处理流量消息
 * @param eventMessage
 */
@Override
@Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
public void handleTrafficMessage(EventMessage eventMessage) {
...
            log.info("消费消息新增流量包:rows={},trafficDO={}",rows,trafficDO);
            //新增流量包，应该删除这个key
            String totalTrafficTimesKey = String.format(RedisKey.DAY_TOTAL_TRAFFIC,accountNo);
            redisTemplate.delete(totalTrafficTimesKey);
}




/**
 * 扣减流量包
 * @param eventMessage
 */
 @Override
    @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
    public JsonData reduce(UseTrafficRequest trafficRequest) {
       if(rows != 1){
            throw new BizException(BizCodeEnum.TRAFFIC_REDUCE_FAIL);
        }

        //往redis设置下总流量包次数，短链服务那边递减即可； 如果有新增流量包，则删除这个key
        long leftSeconds = TimeUtil.getRemainSecondsOneDay(new Date());
        String totalTrafficTimesKey = String.format(RedisKey.DAY_TOTAL_TRAFFIC,accountNo);
        redisTemplate.opsForValue().set(totalTrafficTimesKey,
                useTrafficVO.getDayTotalLeftTimes() - 1,leftSeconds, TimeUnit.SECONDS);
        return JsonData.buildSuccess();
}
```

##### 17.4.13.4预扣减流量包Lua脚本开发

###### 17.4.13.4.1ShortLinkServiceImpl

```
/**
 * 创建短链
 * @param request
 * @return
 */
@Override
public JsonData createShortLink(ShortLinkAddRequest request) {
    Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
    //需要预先检查下是否有足够多的可以进行创建
    String cacheKey = String.format(RedisKey.DAY_TOTAL_TRAFFIC, accountNo);
    // 检查key是否存在，然后-1，是否大于等于0，使用lua脚本
    // 如果key不存在，则未使用过，lua返回值是0；
    // 新增流量包的时候，不用重新计算次数，直接删除key,消费的时候回计算更新
    String script = "if redis.call('get',KEYS[1]) then return redis.call('decr',KEYS[1]) else return 0 end";
    Long leftTimes = redisTemplate.execute
            (new DefaultRedisScript<>(script,Long.class),Arrays.asList(cacheKey),"");
    log.info("今日流量包剩余次数:{}",leftTimes);
    if(leftTimes >= 0){
        String newOriginalUrl = CommonUtil.addUrlPrefix(request.getOriginalUrl());
        request.setOriginalUrl(newOriginalUrl);
        EventMessage eventMessage = EventMessage.builder().accountNo(accountNo)
                .content(JsonUtil.obj2Json(request))
                .messageId(IDUtil.geneSnowFlakeID().toString())
                .eventMessageType(EventMessageType.SHORT_LINK_ADD.name())
                .build();
        rabbitTemplate.convertAndSend
                (rabbitMQConfig.getShortLinkEventExchange(), rabbitMQConfig.getShortLinkAddRoutingKey(), eventMessage);
        return JsonData.buildSuccess();
    }else {
        //流量包不足
        return JsonData.buildResult(BizCodeEnum.TRAFFIC_REDUCE_FAIL);
    }
}
```
##### 17.4.13.5预扣减流量包链路测试


测试

- 流量包扣减

**请求json数据**

```
{
    "groupId":1623876828194168833,
    "title":"6666666",
    "originalUrl":"liusenbiao.net?asdf=2a1",
    "domainId":1,
    "domainType":"OFFICIAL",
    "expired":-1
    
}
```

![1675998415382](短链平台项目.assets/1675998415382.png)**domainId和domainType和下图保持一致**

![1675998556987](短链平台项目.assets/1675998556987.png)

**创建短链**

![1675998625709](短链平台项目.assets/1675998625709.png)

- 流量包更新维护

**创建一条短链，扣减一次流量包**

![1675998757556](短链平台项目.assets/1675998757556.png)

- **查看控制台打印日志**

![1675998870158](短链平台项目.assets/1675998870158.png)

- **查看redis里的值**

![1675999398756](短链平台项目.assets/1675999398756.png)

#### 17.4.14短链服务+流量包分布式事务

##### 17.4.14.1高并发下解决方式

![1676042958567](短链平台项目.assets/1676042958567.png)

- 使用rabbitMQ实现分布式调度

![1676043717421](短链平台项目.assets/1676043717421.png)



##### 17.4.14.2流量包task表创建

###### 17.4.14.2.1traffic_task

```
-- ----------------------------
-- Table structure for traffic_task
-- ----------------------------
DROP TABLE IF EXISTS `traffic_task`;
CREATE TABLE `traffic_task` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `account_no` bigint DEFAULT NULL,
  `traffic_id` bigint DEFAULT NULL,
  `use_times` int DEFAULT NULL,
  `lock_state` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '锁定状态锁定LOCK  完成FINISH-取消CANCEL',
  `biz_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '唯一标识',
  `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_biz_id` (`biz_id`) USING BTREE,
  KEY `idx_release` (`account_no`,`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

###### 17.4.14.2.2创建LOCK状态枚举类

```
package net.xdclass.enums;


/**
 * @author 刘森飚
 * @since 2023-02-10
 */

public enum TaskStateEnum {

    /**
     * 锁定
     */
    LOCK,

    /**
     * 完成
     */
    FINISH,

    /**
     * 取消，释放库存
     */
    CANCEL;

}
```

##### 17.4.14.3流量包任务Manager层开发

###### 17.4.14.3.1TrafficTaskManager

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.TrafficTaskManager;
import net.xdclass.mapper.TrafficTaskMapper;
import net.xdclass.model.TrafficTaskDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-11
 */


@Component
@Slf4j
public class TrafficTaskManagerImpl implements TrafficTaskManager {

    @Autowired
    private TrafficTaskMapper trafficTaskMapper;


    /**
     * 添加流量包任务
     * @param trafficTaskDO
     * @return
     */
    @Override
    public int add(TrafficTaskDO trafficTaskDO) {
        return trafficTaskMapper.insert(trafficTaskDO);
    }


    /**
     * 查找流量包任务
     * @param id
     * @param accountNo
     * @return
     */
    @Override
    public TrafficTaskDO findByIdAndAccountNo(Long id, Long accountNo) {
        TrafficTaskDO taskDO = trafficTaskMapper.selectOne(new QueryWrapper<TrafficTaskDO>()
                .eq("id", id)
                .eq("account_no", accountNo));
        return taskDO;
    }


    /**
     * 删除流量包任务
     * @param id
     * @param accountNo
     * @return
     */
    @Override
    public int deleteByIdAndAccountNo(Long id, Long accountNo) {
        return trafficTaskMapper.delete(new QueryWrapper<TrafficTaskDO>()
                .eq("id", id)
                .eq("account_no", accountNo));
    }
}
```

###### 17.4.14.3.2TrafficTaskManagerImpl

```
package net.xdclass.manager.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.manager.TrafficTaskManager;
import net.xdclass.mapper.TrafficTaskMapper;
import net.xdclass.model.TrafficTaskDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-11
 */


@Component
@Slf4j
public class TrafficTaskManagerImpl implements TrafficTaskManager {

    @Autowired
    private TrafficTaskMapper trafficTaskMapper;


    /**
     * 添加流量包任务
     * @param trafficTaskDO
     * @return
     */
    @Override
    public int add(TrafficTaskDO trafficTaskDO) {
        return trafficTaskMapper.insert(trafficTaskDO);
    }


    /**
     * 查找流量包任务
     * @param id
     * @param accountNo
     * @return
     */
    @Override
    public TrafficTaskDO findByIdAndAccountNo(Long id, Long accountNo) {
        TrafficTaskDO taskDO = trafficTaskMapper.selectOne(new QueryWrapper<TrafficTaskDO>()
                .eq("id", id)
                .eq("account_no", accountNo));
        return taskDO;
    }


    /**
     * 删除流量包任务
     * @param id
     * @param accountNo
     * @return
     */
    @Override
    public int deleteByIdAndAccountNo(Long id, Long accountNo) {
        return trafficTaskMapper.delete(new QueryWrapper<TrafficTaskDO>()
                .eq("id", id)
                .eq("account_no", accountNo));
    }
}
```

##### 17.4.14.4RabbitMQ死信队列配置

###### 17.4.14.4.1account/RabbitMQConfig

```
 //================流量包扣减，创建短链死信队列配置==================================
// 发送锁定流量包消息-》延迟exchange-》lock.queue-》死信exchange-》release.queue 延迟队列，不能被监听消费
    /**
     * 第一个队列延迟队列，
     */
    private String trafficReleaseDelayQueue = "traffic.release.delay.queue";

    /**
     * 第一个队列的路由key
     * 进入队列的路由key
     */
    private String trafficReleaseDelayRoutingKey = "traffic.release.delay.routing.key";


    /**
     * 第二个队列，被监听恢复流量包的队列
     */
    private String trafficReleaseQueue = "traffic.release.queue";

    /**
     * 第二个队列的路由key
     *
     * 即进入死信队列的路由key
     */
    private String trafficReleaseRoutingKey="traffic.release.routing.key";

    /**
     * 过期时间，毫秒,1分钟
     */
    private Integer ttl = 60000;



    /**
     * 延迟队列
     */
    @Bean
    public Queue trafficReleaseDelayQueue(){

        Map<String,Object> args = new HashMap<>(3);
        args.put("x-message-ttl",ttl);
        args.put("x-dead-letter-exchange", trafficEventExchange);
        args.put("x-dead-letter-routing-key",trafficReleaseRoutingKey);

        return new Queue(trafficReleaseDelayQueue,true,false,false,args);
    }


    /**
     * 死信队列，普通队列，用于被监听
     */
    @Bean
    public Queue trafficReleaseQueue(){

        return new Queue(trafficReleaseQueue,true,false,false);

    }


    /**
     * 第一个队列，即延迟队列的绑定关系建立
     * @return
     */
    @Bean
    public Binding trafficReleaseDelayBinding(){

        return new Binding(trafficReleaseDelayQueue,Binding.DestinationType.QUEUE,
                trafficEventExchange,trafficReleaseDelayRoutingKey,null);
    }

    /**
     * 死信队列绑定关系建立
     * @return
     */
    @Bean
    public Binding trafficReleaseBinding(){

        return new Binding(trafficReleaseQueue,Binding.DestinationType.QUEUE,
                trafficEventExchange,trafficReleaseRoutingKey,null);
    }
```

###### 17.4.14.4.2TrafficServiceImpl

```
/**
 *  查询用户全部可用流量包
 *  遍历用户可用流量包
 *    判断是否更新-用日期判断
 *      没更新的流量包后加入【待更新集合】中
 *        增加【今天剩余可用总次数】
 *      已经更新的判断是否超过当天使用次数
 *        如果没超过则增加【今天剩余可用总次数】
 *        超过则忽略
 *
 * * 更新用户今日流量包相关数据
 * * 扣减使用的某个流量包使用次数
 * @param trafficRequest
 * @return
 */
@Override
@Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
public JsonData reduce(UseTrafficRequest trafficRequest) {
 ....
    //先更新，再扣减当前使用的流量包
    //扣减流量包就是意味着增加了一次当天流量包的使用次数
    int rows = trafficManager.addDayUsedTimes(
            accountNo,useTrafficVO.getCurrentTrafficDO().getId(),1);

    //此处添加代码
    //6-1保存task任务
    TrafficTaskDO trafficTaskDO = TrafficTaskDO.builder()
            .accountNo(accountNo)
            .bizId(trafficRequest.getBizId())
            .useTimes(1)
            .trafficId(useTrafficVO.getCurrentTrafficDO().getId())
            .lockState(TaskStateEnum.LOCK.name())
            .build();

    trafficTaskManager.add(trafficTaskDO);

    if(rows != 1){
        throw new BizException(BizCodeEnum.TRAFFIC_REDUCE_FAIL);
    }
.....
    //此处添加代码
    //6-3发送MQ消息
    EventMessage trafficUseEventMessage = EventMessage.builder()
            .accountNo(accountNo)
            .bizId(trafficTaskDO.getId() + "")
            .eventMessageType(EventMessageType.TRAFFIC_USED.name())
            .build();

    //发送延迟消息，用于异常回滚
    rabbitTemplate.convertAndSend(rabbitMQConfig.getTrafficEventExchange(),
            rabbitMQConfig.getTrafficReleaseDelayRoutingKey(),trafficUseEventMessage);

    return JsonData.buildSuccess();
    
    
    
    
    
    /**
     * 处理流量消息
     * @param eventMessage
     */
    @Override
    @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
    public void handleTrafficMessage(EventMessage eventMessage) {
        ....
        //此行往下添加代码
        } else if (EventMessageType.TRAFFIC_USED.name().equalsIgnoreCase(messageType)) {
            //流量包使用，检查是否成功使用
            //检查task是否存在
            //检查短链是否成功
            //如果不成功，则恢复流量包
            //删除task (也可以更新task状态，定时删除就行)
            Long trafficTaskId = Long.valueOf(eventMessage.getBizId());
            TrafficTaskDO trafficTaskDO = trafficTaskManager.findByIdAndAccountNo(trafficTaskId, accountNo);
            //非空且锁定
            if (trafficTaskDO != null && trafficTaskDO.getLockState().equalsIgnoreCase(TaskStateEnum.LOCK.name())) {
                //远程调用，查看短链码是否存在
                JsonData jsonData = shortLinkFeignService.check(trafficTaskDO.getBizId());
                if (jsonData.getCode() != 0) {
                    log.error("创建短链失败，流量包回滚");
                    String useDateStr =  TimeUtil.format(trafficTaskDO.getGmtCreate(),"yyyy-MM-dd");
                    trafficManager.releaseUsedTimes(accountNo,trafficTaskDO.getTrafficId(),1,useDateStr);
                    //恢复流量包，应该删除这个key（也可以让这个key递增）
                    String totalTrafficTimesKey = String.format(RedisKey.DAY_TOTAL_TRAFFIC,accountNo);
                    redisTemplate.delete(totalTrafficTimesKey);
                }
                //多种方式处理task，不立刻删除，可以更新状态，然后定时删除也行
                trafficTaskManager.deleteByIdAndAccountNo(trafficTaskId, accountNo);
            }
        }
    }
}
```

###### 17.4.14.4.3TrafficMQListener

```
package net.xdclass.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.exception.BizException;
import net.xdclass.model.EventMessage;
import net.xdclass.service.TrafficService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author 刘森飚
 * @since 2023-02-06
 */

@Component
@RabbitListener(queuesToDeclare = {
        @Queue("order.traffic.queue"),
        @Queue("traffic.free_init.queue"),
        //此行添加代码
        @Queue("traffic.release.queue")
})
@Slf4j
public class TrafficMQListener {

    @Autowired
    private TrafficService trafficService;



    @RabbitHandler
    public void trafficHandler(EventMessage eventMessage, Message message, Channel channel){
        log.info("监听到消息trafficHandler:{}",eventMessage);
        try{
            trafficService.handleTrafficMessage(eventMessage);
        }catch (Exception e){
            log.error("消费者失败:{}",eventMessage);
            throw new BizException(BizCodeEnum.MQ_CONSUME_EXCEPTION);
        }
        log.info("消费成功:{}",eventMessage);
    }
}
```

###### 17.4.14.4.4ShortLinkFeignService

```
package net.xdclass.feign;

import net.xdclass.util.JsonData;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;


/**
 * @author 刘森飚
 * @since 2023-02-12
 */

@FeignClient(name = "dcloud-link-service")
public interface ShortLinkFeignService {


    /**
     * 检查短链是否存在
     * @param shortLinkCode
     * @return
     */
    @GetMapping(value = "/api/link/v1/check",headers = {"rpc-token=${rpc.token}"})
    JsonData check(@RequestParam("shortLinkCode") String shortLinkCode);

}
```

###### 17.4.14.4.5ShortLinkController

```
package net.xdclass.controller;


import net.xdclass.controller.request.ShortLinkAddRequest;
import net.xdclass.controller.request.ShortLinkDelRequest;
import net.xdclass.controller.request.ShortLinkPageRequest;
import net.xdclass.controller.request.ShortLinkUpdateRequest;
import net.xdclass.service.ShortLinkService;
import net.xdclass.util.JsonData;
import net.xdclass.vo.ShortLinkVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/api/link/v1")
public class ShortLinkController {

    @Autowired
    private ShortLinkService shortLinkService;


    @Value("${rpc.token}")
    private String rpcToken;

    @GetMapping("check")
    public JsonData check(@RequestParam("shortLinkCode") String shortLinkCode, HttpServletRequest request){
        String token = request.getHeader("rpc-token");
        if(rpcToken.equalsIgnoreCase(token)){
            ShortLinkVO shortLinkVO = shortLinkService.parseShortLinkCode(shortLinkCode);
            return shortLinkVO == null ? JsonData.buildError("短链不存在"):JsonData.buildSuccess();
        }else {
            return JsonData.buildError("非法访问");
        }
    }



    /**
     * 新增短链
     *
     * @param request
     * @return
     */
    @PostMapping("add")
    public JsonData createShortLink(@RequestBody ShortLinkAddRequest request) {
        JsonData jsonData = shortLinkService.createShortLink(request);
        return jsonData;
    }


    /**
     * 分页查找短链
     */

    @RequestMapping("page")
    public JsonData pageByGroupId(@RequestBody ShortLinkPageRequest request) {
        Map<String, Object> result = shortLinkService.pageByGroupId(request);
        return JsonData.buildSuccess(result);
    }


    /**
     * 删除短链
     * @param request
     * @return
     */
    @PostMapping("del")
    public JsonData del(@RequestBody ShortLinkDelRequest request){
        JsonData jsonData = shortLinkService.del(request);
        return jsonData;
    }



    /**
     * 更新短链
     * @param request
     * @return
     */
    @PostMapping("update")
    public JsonData update(@RequestBody ShortLinkUpdateRequest request){
        JsonData jsonData = shortLinkService.update(request);
        return jsonData;
    }
}
```

###### 17.4.14.4.6InterceptorConfig

- link/InterceptorConfig

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @Description
 * @Author 刘森飚
 **/

@Configuration
@Slf4j
public class InterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(new LoginInterceptor())
                //添加拦截的路径
                .addPathPatterns("/api/link/*/**", "/api/group/*/**","/api/domain/*/**")

                //不拦截的路径
                //此行添加代码
                .excludePathPatterns("/api/link/*/check");
    }
}
```

###### 17.4.14.4.7流量包跨日期恢复bug修复

- 恢复流量包跨日期问题

```
1⽉1号晚上11点59分创建，然后失败了，1⽉2号凌晨恢复了次日流量包
解决⽅法：增加恢复流量包的日期
```

- TrafficServiceImpl

```
log.error("创建短链失败，流量包回滚");
String useDateStr =  TimeUtil.format(trafficTaskDO.getGmtCreate(),"yyyy-MM-dd");
trafficManager.releaseUsedTimes(accountNo,trafficTaskDO.getTrafficId(),1,useDateStr);
//恢复流量包，应该删除这个key（也可以让这个key递增）
String totalTrafficTimesKey = String.format(RedisKey.DAY_TOTAL_TRAFFIC,accountNo);
redisTemplate.delete(totalTrafficTimesKey);
```

- TrafficMapper.xml

```
<!--恢复流量包-->
<update id="releaseUsedTimes">

     update traffic set day_used = day_used - #{usedTimes}
     where id = #{trafficId} and account_no = #{accountNo}
     and (day_used - #{usedTimes}) >= 0 and date_format(gmt_modified,'%Y-%m-%d') = #{useDateStr} limit 1;
</update>
```

##### 17.4.14.5扣减流量包数据一致性链路测试

###### 17.4.14.5.1创建短链成功，流量包扣减成功，缓存-数据库一致

- json数据

```
{
    "groupId":1623876828194168833,
    "title":"流量包事务链路测试",
    "originalUrl":"liusenbiao.net?asdf=2a1",
    "domainId":1,
    "domainType":"OFFICIAL",
    "expired":-1
    
}
```

![1676214320845](短链平台项目.assets/1676214320845.png)

![1676214515042](短链平台项目.assets/1676214515042.png)

![1676214539314](短链平台项目.assets/1676214539314.png)

![1676214590689](短链平台项目.assets/1676214590689.png)

###### 17.4.14.5.2创建短链失败，流量包扣减回滚，缓存-数据库一致

- json数据

```
{
    "groupId":1623876828194168833,
    "title":"刘test1-流量包事务链路测试",
    "originalUrl":"liusenbiao.net?asdf=2a1",
    "domainId":1,
    "domainType":"OFFICIAL",
    "expired":-1
    
}
```

![1676214920158](短链平台项目.assets/1676214920158.png)

![1676215289641](短链平台项目.assets/1676215289641.png)

![1676215499421](短链平台项目.assets/1676215499421.png)

## 18.短链大数据模块

### 18.1大数据基本概念

#### 18.1.1商业智能BI

```
用来帮助企业更好地利用数据提高决策质量的技术集合，是从⼤量的数据中钻取信息与知识的过程。
⼀套完整的解决⽅案，可以将来自企业的不同业务系统的数据，提取出有用的数据进⾏整合清洗-分析和处理，利用合适
的查询和分析⼯具快速、准确地为企业提供报表展现与分析，为企业提供决策⽀持。
最终展现给用户的信息就是可视化报表，⼤屏数据
基于可视化报表⼤屏数据 进行分析，发现问题，并去做决策。

总结：
商业智能BI 是⼀系列工具产品和技术的集合，如数据仓库技术、ETL技术、OLAP技术、前端工具等
⽬的是为了提升数据价值，辅助企业决策
业务系统与商业智能系统的区别
业务系统保证企业日常运营，商业智能系统通辅助决策，提⾼企业的运营能⼒⽔平。
```

#### 18.1.2数据仓库

```
为了便于多维分析和多⻆度展现，将其数据按特定的模式进⾏存储⽽建⽴的数据库，数据仓库中的数据是细节的，集成的，⾯向主题的，是以 OLAP系统为分析目的.
是存储和管理⼀个或多个主题数据的集合，支持管理决策分析，有针对性抽取的结构化历史数据，能够⽣成各类报表。
将来⾃不同来源的结构化数据聚合起来，用于业务智能领域的比较和分析（BI商业智能），数据仓库是包含多种数据的存储库。

数据仓库有两个局限
⼀是只可以解决预先想到的问题, 需要提前建模
⼆是数据已经被多次处理过，无法看见其最初状态
```

#### 18.1.3数据湖

```
存储任何形式（包括结构化和非结构化）和任何格式（包括文本、音频、视频和图像）的原始数据.
数据不需要提前进行定义，在准备使用数据时再定义，提高了最高的灵活性与可扩展性。
适合使用机器学习和深度学习进行使用，比如数据挖掘和数据分析，以及提取非结构化数据
⼀个新的概念，但落地还很多问题需要解决
```

#### 18.1.4ETL和数据仓库建设分层

- 什么是ETL（Extract-Transform-Load）

```
抽取（extract）、转换（transform）、加载（load）缩写ETL⼀词常用在数据仓库，但其对象并不限于数据仓库
将业务系统的数据经过抽取、清洗转换之后加载到数据仓库的过程，目的是将企业中的分散、零乱、标准不统⼀的数据整合到⼀起，为企业的决策提供分析依据， ETL是BI（商业智能）项目重要的⼀个环节。
```

- 数仓分层介绍

![1676284644398](短链平台项目.assets/1676284644398.png)

### 18.2数据可视化分析链路

#### 18.2.1可视化精简链路

- 数据从哪里来，数据到哪里去

![1676277267373](短链平台项目.assets/1676277267373.png)

#### 18.2.2可视化全部链路

- 通用微服务+数据仓库详细链路

```
链路存在重叠，意思是多种⽅式都是可以的实现
短链平台的数据是其中⼀个链路
```

![1676277620552](短链平台项目.assets/1676277744439.png)

```
数据采集传输:Flume、Kafka、Canal、Maxwell、Sqoop、Logstash，DataX
数据存储:MySql、ClickHouse、HDFS、HBase、Redis
数据计算:Hive、Spark、Flink、Storm
数据查询:Presto、Kylin、Druid
数据可视化:Echarts、Superset、DataV
```

### 18.3数据埋点采集

#### 18.3.1数据埋点采集方案

- 什么是数据埋点

```
对网站、App、进行业务数据采集，包括用户行为数据及其他实际需要的数据进行采集上报。
方便分析用户行为、提高用户体验，通过这些采集的数据就可以进行分析辅助公司企业做决策。
```

- 常见埋点方式

```
代码埋点
编写埋点代码，通过代码进行控制，前端、后端、App客户端代码，需要埋点的逻辑通过sdk函数调用，上报数据。

可视化埋点
  通用采集SDK，项目只需要引⼊埋点采集sdk。分析⼈员通过分析平台进行操作，对可交互的页面元素（如：图⽚、
按钮、链接等）直接在界⾯上进行操作实现数据埋点，下发采集代码⽣效的埋点方式。
  所见即所得，使用者只需在其可视化埋点页面上，点击想要监测的元素，编辑名字编号等，埋点就完成了。
  
  缺点
    存在滞后性，每次调整埋点后需要应用重新发版才可以看到数据，也可以通过配置中心动态下发解决。
    相对⽣硬，满⾜不了全部数据采集，比如编码规范不统⼀、⽆法定位元素等，或者需要调用后台接⼝的数据等。
    比如看⼀个视频，点击播放⼀个视频，交互行为就是⼀个播放，但播放的背后还想知道这个视频的名字、类别、作者、评级等信息就获取不了
```

- 全埋点|无埋点

```
对应⽤上的所有的可交互事件元素进行解析，对页面上所有的⽤户操作行为进行监听，当有操作行为（交互事件）
发⽣时，监测⼯具会进行记录并上报。
会记录全部⽤户行为事件并上报，采集量过大。

缺点
满⾜不了全部数据采集，⽐如编码规范不统⼀、⽆法定位元素等，或者需要调⽤后台接⼝的数据等。
比如看⼀个视频，点击播放⼀个视频，交互行为就是⼀个播放，但播放的背后还想知道这个视频的名字、类别、作者、评级等信息就获取不了。
```

#### 18.3.2数据采集链路

- 日志采集分类

```
事件
曝光事件:1个item 或者1个页面被展示出来，就称作曝光
点击事件：点击某个页面、按钮

属性
打开 App ⼿机型号、网络制式、App版本信息 等公参信息
浏览器所属的客户端信息，用户网络ip、地理位置信息等
```

- 埋点数据上报时机分两种

```
方式⼀，在离开该页面时上传在这个页面产生的所有数据
优点，批量上传，服务器接收数据压力小
缺点，数据有延迟

方式⼆，每个事件动作数据产生后马上发送
优点，数据没延迟，实时看到数据
缺点，对服务器压力比较大，请求频繁
```

- 短链平台采用方式

```
访问短链码
记录日志-打印控制台(方便排查)
发送Kafka（本身异步发送）
```

![1676287773035](短链平台项目.assets/1676287773035.png)

### 18.4数据埋点采集开发

#### 18.4.1Docker部署Kafka+Zookeeper

- 部署zk

```
docker run -d --name zookeeper -p 2181:2181 -t wurstmeister/zookeeper
```

- 部署kafka

```
#1.docker部署kafka
docker run -d --name liu_kafka \
-p 9092:9092 \
-e KAFKA_BROKER_ID=0 \
--env KAFKA_HEAP_OPTS=-Xmx256M \
--env KAFKA_HEAP_OPTS=-Xms128M \
-e KAFKA_ZOOKEEPER_CONNECT=172.26.44.128:2181 \
-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://123.57.69.236:9092 \
-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka:2.13-2.7.0


#2.查看kafka是否成功启动
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker logs -f e8e0


#3.进入kafka内部容器
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker exec -it e8e05849f91d /bin/bash
bash-5.1# cd /opt/kafka/bin



#4.创建⼀个主题
bash-5.1# ./kafka-topics.sh --create --zookeeper 172.26.44.128:2181 --replication-factor 1 --partitions 1 --topic ods_link_visit_topic


#5.查看topic
bash-5.1# ./kafka-topics.sh --list --zookeeper 172.26.44.128:2181


#6.删除topic(若有故障，执行)
./kafka-topics.sh --zookeeper 172.26.44.128:2181 --delete --topic ods_link_visit_topic


#7.消费者消费消息(浏览器发送消息后查看)
./kafka-console-consumer.sh --bootstrap-server 101.200.159.132:9092 --from-beginning --topic ods_link_visit_topic



#8.网络安全组记得开发端口9092、2181
[root@iZ2zeashk7kdvi5eievv7sZ ~]# firewall-cmd --zone=public --add-port=9092/tcp --permanent
```

#### 18.4.2Logback配置

- link/resources/logback.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <property name="LOG_HOME" value="./data/logs/link" />

    <!--采用打印到控制台，记录日志的方式-->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%date %level [%thread] %logger{36} [%file : %line] %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 采用保存到日志文件 记录日志的方式-->
    <appender name="rollingFile" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_HOME}/link.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/link-%d{yyyy-MM-dd}.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%date %level [%thread] %logger{36} [%file : %line] %msg%n</pattern>
        </encoder>
    </appender>


    <!-- 指定某个类单独打印日志 -->
    <logger name="net.xdclass.service.impl.LogServiceImpl"
            level="INFO" additivity="false">
        <appender-ref ref="rollingFile" />
        <appender-ref ref="console" />
    </logger>

    <root level="error" additivity="false">
        <appender-ref ref="console" />
    </root>

</configuration>
```

#### 18.4.3发送Kafka消息

##### 18.4.3.1Kafak依赖和配置

- common/pom.xml

```
<!--Springboot项目整合spring-kafka依赖包配置-->
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>
```

- link/application.properties

```
#----------kafka配置--------------
spring.kafka.bootstrap-servers=101.200.159.132:9092
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer
```

##### 18.4.3.2编码实战

###### 18.4.3.2.1LogRecord

- common/model/LogRecord

```
package net.xdclass.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @Description
 * @Author 刘森飚
 **/


@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class LogRecord {

    /**
     * 客户端ip
     */
    private String ip;

    /**
     * 产生时间戳
     */
    private Long ts;


    /**
     * 日志事件类型
     */
    private String event;


    /**
     * udid，是设备的唯一标识，全称uniqueDeviceIdentifier
     */
    private String udid;


    /**
     * 业务id
     */
    private String bizId;


    /**
     * 日志内容
     */
    private Object data;

}
```

###### 18.4.3.2.2LogService

```
package net.xdclass.service;

import net.xdclass.util.JsonData;

import javax.servlet.http.HttpServletRequest;


/**
 * @author 刘森飚
 * @since 2023-02-13
 */

public interface LogService {

    /**
     * 记录日志
     * @param request
     * @param shortLinkCode
     * @param accountNo
     * @return
     */
    void recordShortLinkLog(HttpServletRequest request, String shortLinkCode, Long accountNo);

}
```

###### 18.4.3.2.3LogServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.LogTypeEnum;
import net.xdclass.model.LogRecord;
import net.xdclass.service.LogService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JsonUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-13
 */

@Service
@Slf4j
public class LogServiceImpl implements LogService {

    private static final String TOPIC_NAME = "ods_link_visit_topic";

    @Autowired
    private KafkaTemplate kafkaTemplate;



    @Override
    public void recordShortLinkLog(HttpServletRequest request, String shortLinkCode, Long accountNo) {
        //ip、浏览器信息
        String ip = CommonUtil.getIpAddr(request);
        //全部请求头
        Map<String,String> headerMap = CommonUtil.getAllRequestHeader(request);
        Map<String,String> availableMap = new HashMap<>();
        availableMap.put("user-agent",headerMap.get("user-agent"));
        availableMap.put("referer",headerMap.get("referer"));
        availableMap.put("accountNo",accountNo.toString());
        LogRecord logRecord = LogRecord.builder()
                //日志类型
                .event(LogTypeEnum.SHORT_LINK_TYPE.name())
                //日志内容
                .data(availableMap)
                //客户端ip
                .ip(ip)
                //产生时间
                .ts(CommonUtil.getCurrentTimestamp())
                //业务唯一标识
                .bizId(shortLinkCode).build();
        String jsonLog = JsonUtil.obj2Json(logRecord);
        //打印控制台
        log.info(jsonLog);
        //发送kafka
        kafkaTemplate.send(TOPIC_NAME,jsonLog);
    }
}
```

#### 18.4.4发送和消费Kafka链路测试

- 链路测试

```
访问短链
控制台打印日志
发送消息到Kafka
Kafka消费消息
```

- Kafka命令

```
#创建topic
bash-5.1# ./kafka-topics.sh --create --zookeeper 172.26.44.128:2181 --replication-factor 1 --partitions 1 --topic ods_link_visit_topic


#查看topic
bash-5.1# ./kafka-topics.sh --list --zookeeper 172.26.44.128:2181


删除topic
./kafka-topics.sh --zookeeper 172.26.44.128:2181 --delete --topic ods_link_visit_topic


#消费者消费消息
./kafka-console-consumer.sh --bootstrap-server 101.200.159.132:9092 --from-beginning --topic ods_link_visit_topic


#⽣产者发送消息
./kafka-console-producer.sh --broker-list 101.200.159.132:9092 --topic ods_link_visit_topic
```

- 修改数据库测试

![1676346171039](短链平台项目.assets/1676346171039.png)

- 浏览器发送消息

![1676346205146](短链平台项目.assets/1676346205146.png)

- kafka容器里查看消息是否被消费

![1676346276429](短链平台项目.assets/1676346276429.png)

### 18.5Flink实时计算开发

#### 18.5.1Flink实时计算项目搭建

##### 18.5.1.1添加依赖

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>dcloud-short-link</artifactId>
        <groupId>net.xdclass</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>dcloud-app</artifactId>


    <properties>
        <encoding>UTF-8</encoding>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>

        <scala.version>2.12</scala.version>
        <flink.version>1.13.1</flink.version>
    </properties>


    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>

        <!--flink客户端-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-clients_${scala.version}</artifactId>
            <version>${flink.version}</version>
        </dependency>

        <!--scala版本-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-scala_${scala.version}</artifactId>
            <version>${flink.version}</version>
        </dependency>
        <!--java版本-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-java</artifactId>
            <version>${flink.version}</version>
        </dependency>

        <!--streaming的scala版本-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-streaming-scala_${scala.version}</artifactId>
            <version>${flink.version}</version>
        </dependency>
        <!--streaming的java版本-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-streaming-java_${scala.version}</artifactId>
            <version>${flink.version}</version>
        </dependency>


        <!--Flink web ui-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-runtime-web_${scala.version}</artifactId>
            <version>${flink.version}</version>
        </dependency>


        <!--使用 RocksDBStateBackend 需要加依赖-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-statebackend-rocksdb_${scala.version}</artifactId>
            <version>1.13.1</version>
        </dependency>

        <!--mysql驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.25</version>
        </dependency>

        <!--flink cep依赖包-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-cep_${scala.version}</artifactId>
            <version>${flink.version}</version>
        </dependency>

        <!--redis connector-->
        <dependency>
            <groupId>org.apache.bahir</groupId>
            <artifactId>flink-connector-redis_2.11</artifactId>
            <version>1.0</version>
        </dependency>

        <!--kafka connector-->
        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-connector-kafka_${scala.version}</artifactId>
            <version>${flink.version}</version>
        </dependency>


        <!--日志输出-->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>1.7.7</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
            <scope>runtime</scope>
        </dependency>

        <!--json依赖包-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.44</version>
        </dependency>


        <dependency>
            <groupId>org.apache.flink</groupId>
            <artifactId>flink-connector-jdbc_${scala.version}</artifactId>
            <version>${flink.version}</version>
        </dependency>

    </dependencies>


    <!-- 指定仓库位置，先从aliyun找，找不到再从apache仓库找 -->
    <repositories>
        <repository>
            <id>aliyun</id>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
        </repository>
        <repository>
            <id>apache</id>
            <url>https://repository.apache.org/content/repositories/snapshots/</url>
        </repository>
    </repositories>

    <build>
        <finalName>xdclass-flink</finalName>
        <plugins>

            <!--默认编译版本比较低，所以用compiler插件,指定项目源码的jdk版本，编译后的jdk版本和编码,-->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.6.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${file.encoding}</encoding>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>2.3</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

##### 18.5.1.2目录结构划分

![1676366679424](短链平台项目.assets/1676366679424.png)

##### 18.5.1.3入口类编写

```
package net.xdclass.dwd;

import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

/**
 * @author 刘森飚
 * @since 2023-02-14
 */

@Slf4j
public class DwdShortLinkLogApp {
    public static void main(String [] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        DataStream<String> ds =  env.socketTextStream("10.0.0.67",8888);
        ds.print();
        env.execute();
    }
}
```

![1676366988628](短链平台项目.assets/1676366988628.png)

#### 18.5.2Kafka工具类封装

- 需求背景

```
Flink的source和sink跟kafka交互频繁，提升代码复⽤性，封装工具类。
每次变动的只有topic和group，其他的broker等基本属性是固定不变的。
```



##### 18.5.2.1application.properties

```
#----------kafka配置--------------
kafka.servers=101.200.159.132:9092
```

##### 18.5.2.2KafkaUtil

```
package net.xdclass.util;

import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.serialization.SimpleStringSchema;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;
import org.apache.kafka.clients.consumer.ConsumerConfig;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * @author 刘森飚
 * @since 2023-02-14
 */


@Slf4j
public class KafkaUtil {


    /**
     * kafka的broker地址
     */
    private static String KAFKA_SERVER = null;

    static {
        Properties properties = new Properties();
        InputStream in = KafkaUtil.class.getClassLoader().getResourceAsStream("application.properties");
        try {
            properties.load(in);
        } catch (IOException e) {
            log.error("加载kafka配置文件失败,{}",e);
        }
        //获取key配置对应的value
        KAFKA_SERVER = properties.getProperty("kafka.servers");
    }



    /**
     * 获取flink的kafka消费者
     * @param topic
     * @param groupId
     * @return
     */
    public static FlinkKafkaConsumer<String> getKafkaConsumer(String topic, String groupId){
        Properties props = new Properties();
        props.setProperty(ConsumerConfig.GROUP_ID_CONFIG,groupId);
        props.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,KAFKA_SERVER);
        return new FlinkKafkaConsumer<String>(topic,new SimpleStringSchema(),props);
    }



    /**
     * 获取flink的kafka生产者
     * @param topic
     * @return
     */
    public static FlinkKafkaProducer<String> getKafkaProducer(String topic){
        return new FlinkKafkaProducer<String>(KAFKA_SERVER,topic,new SimpleStringSchema());
    }
}
```

##### 18.5.2.3DwdShortLinkLogApp

```
package net.xdclass.dwd;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.util.KafkaUtil;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;

/**
 * @author 刘森飚
 * @since 2023-02-14
 */

@Slf4j
public class DwdShortLinkLogApp {
    /**
     * 定义topic
     */
    public static final String SOURCE_TOPIC = "ods_link_visit_topic";

    /**
     * 定义消费者组
     */
    public static final String GROUP_ID = "dwd_short_link_group";

    public static void main(String [] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        //DataStream<String> ds =  env.socketTextStream("10.0.0.67",8888);
        FlinkKafkaConsumer<String> kafkaConsumer = KafkaUtil.getKafkaConsumer(SOURCE_TOPIC, GROUP_ID);
        DataStreamSource<String> ds = env.addSource(kafkaConsumer);
        ds.print();
        env.execute();
    }
}
```

#### 18.5.3Flink消费Kafka数据链路测试

##### 18.5.3.1访问短链

![1676372180025](短链平台项目.assets/1676372180025.png)

##### 18.5.3.2发送数据

![1676372135403](短链平台项目.assets/1676372135403.png)

##### 18.5.3.3Flink消费打印

![1676372195272](短链平台项目.assets/1676372195272.png)

##### 18.5.3.4留存数据

```
{"ip":"0:0:0:0:0:0:0:1","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}
```

#### 18.5.4Flink实时标记-短链新老访客统计

##### 18.5.4.1需求背景

```
从ODS读取数据，处理后存储到DWD层，做哪些职责？
需要识别标记出短链的新老访客

说明
新老访客可以有天、周、月维度
我们只做天维度的新老访客标记
```

- 思路（ETL的流程）

```
通过设备唯⼀标识，服务端进行【天维度】状态存储，标记新老访客

详情
需要生成唯⼀设备标识
利用Flink的状态存储 ValueState
```

##### 18.5.4.2短链访问来源开发

###### 18.5.4.2.1日志分析

```
{
    "ip":"0:0:0:0:0:0:0:1",
    "ts":1676371826607,
    "event":"SHORT_LINK_TYPE",
    "udid":null,
    "bizId":"01U7PXo0",
    "data":{
        "referer":null,
        "accountNo":"830033392337682432",
        "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"
    }
}
```

###### 18.5.4.2.2浏览器指纹

```
是通过浏览器对网站可见的配置来匿名识别浏览器，从硬件、操作系统、浏览器、网络等维度进行分析。
浏览器指纹现在也比较多⼤厂都在使用：反欺诈，防⽌刷票脚本、机器⼈、异地可疑登录提示等，在注重用户隐私的情况下，进行⼀些数据分析。

⽐如阿⾥云、淘宝等账号登录，常用设备和⾮常用设备登录是不⼀样的验证级别
维度参考
MAC地址，网络中唯⼀标识⼀个网卡，固定化
IP地址
Http的Cookie
Http的UserAgent，包括了客户使⽤的操作系统及版本、CPU 类型、浏览器及版本、渲染引擎等
Canvas（HTML5画布），渲染⽂字，可以转出值

唯⼀标识ID设计
⽤户通过浏览器访问页面的同时产生⼀个用户唯⼀标识（ID)
考虑：唯⼀性和稳定性
最终参考的维度：ip+UserAgent地址（会有偏差但是不多）
```

###### 18.5.4.2.3DwdShortLinkLogApp

```
package net.xdclass.dwd;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.func.VistorMapFunction;
import net.xdclass.util.DeviceUtil;
import net.xdclass.util.KafkaUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.api.java.functions.KeySelector;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;
import org.apache.flink.util.Collector;

import java.net.MalformedURLException;
import java.net.URL;

import java.util.Map;
import java.util.TreeMap;

/**
 * @author 刘森飚
 * @since 2023-02-14
 */

@Slf4j
public class DwdShortLinkLogApp {

    /**
     * 定义source topic
     */
    public static final String SOURCE_TOPIC = "ods_link_visit_topic";

    /**
     * 定义sink topic
     */
    public static final String SINK_TOPIC = "dwd_link_visit_topic";

    /**
     * 定义消费者组
     */
    public static final String GROUP_ID = "dwd_short_link_group";

    public static void main(String [] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        DataStream<String> ds =  env.socketTextStream("10.0.0.67",8888);
        //FlinkKafkaConsumer<String> kafkaConsumer = KafkaUtil.getKafkaConsumer(SOURCE_TOPIC, GROUP_ID);
        //DataStreamSource<String> ds = env.addSource(kafkaConsumer);
        ds.print();

        //1.数据补齐
        //解析字符串还原成json类型的
        SingleOutputStreamOperator<JSONObject> jsonDS = ds.flatMap(new FlatMapFunction<String, JSONObject>() {
            @Override
            public void flatMap(String value, Collector<JSONObject> out) throws Exception {
                JSONObject jsonObject = JSON.parseObject(value);
                //生成设备唯一id
                String udid = getDeviceId(jsonObject);
                jsonObject.put("udid",udid);

                //生成访问来源地址
                String referer = getReferer(jsonObject);
                jsonObject.put("referer",referer);
                out.collect(jsonObject);
            }
        });

        //2.分组
        //同个终端设备进入到同组内
        KeyedStream<JSONObject, String> keyedStream = jsonDS.keyBy(new KeySelector<JSONObject, String>() {
            @Override
            public String getKey(JSONObject value) throws Exception {
                return value.getString("udid");
            }
        });

        //3.识别 richMap open函数，做状态存储的初始化
        SingleOutputStreamOperator<String> jsonDSWithVisitorState = keyedStream.map(new VistorMapFunction());
        jsonDSWithVisitorState.print("ods新老访客");

        //4.存储到dwd
        FlinkKafkaProducer<String> kafkaProducer = KafkaUtil.getKafkaProducer(SINK_TOPIC);
        jsonDSWithVisitorState.addSink(kafkaProducer);
        env.execute();
    }



    /**
     * 提取referer
     * @param jsonObject
     * @return
     */
    public static String getReferer(JSONObject jsonObject){

        JSONObject dataJsonObj = jsonObject.getJSONObject("data");
        if(dataJsonObj.containsKey("referer")){

            String referer = dataJsonObj.getString("referer");
            if(StringUtils.isNotBlank(referer)){
                try {
                    URL url = new URL(referer);
                    return url.getHost();
                }catch (MalformedURLException e) {
                    log.error("提取referer失败:{}",e);
                }
            }
        }
        return "";
    }



    /**
     * 生成设备唯一id
     * @param jsonObject
     * @return
     */
    public static String getDeviceId(JSONObject jsonObject){
        Map<String,String> map = new TreeMap<>();
        try {
            map.put("ip",jsonObject.getString("ip"));
            map.put("event",jsonObject.getString("event"));
            map.put("bizId",jsonObject.getString("bizId"));
            String userAgent = jsonObject.getJSONObject("data").getString("user-agent");
            map.put("userAgent",userAgent);
            String deviceId = DeviceUtil.geneWebUniqueDeviceId(map);
            return deviceId;
        }catch (Exception e){

            log.error("生成唯一deviceid异常:{}",jsonObject);
            return null;
        }
    }
}
```

###### 18.5.4.2.4DeviceUtil

```
package net.xdclass.util;

import java.security.MessageDigest;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-14
 */


public class DeviceUtil {

    /**
     * 生成web设备唯一ID
     * @param map
     * @return
     */
    public static String geneWebUniqueDeviceId(Map<String,String> map){
        String deviceId = MD5(map.toString());
        return deviceId;
    }



    /**
     * MD5加密
     *
     * @param data
     * @return
     */
    public static String MD5(String data) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] array = md.digest(data.getBytes("UTF-8"));
            StringBuilder sb = new StringBuilder();
            for (byte item : array) {
                sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));
            }
            return sb.toString().toUpperCase();
        } catch (Exception exception) {
        }
        return null;
    }
}
```

###### 18.5.4.2.5VistorMapFunction

```
package net.xdclass.func;

import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.util.TimeUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.flink.api.common.functions.RichMapFunction;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;

/**
 * @author 刘森飚
 * @since 2023-02-14
 */


@Slf4j
public class VistorMapFunction extends RichMapFunction<JSONObject,String> {
    //记录用户的udid访问(访问日期)
    private ValueState<String> newDayVisitorState;



    /**
     * 对状态做初始化
     * @param parameters
     * @throws Exception
     */
    @Override
    public void open(Configuration parameters) throws Exception {
        newDayVisitorState = getRuntimeContext().getState
                (new ValueStateDescriptor<String>("newDayVisitorState",String.class));
    }


    /**
     * 判断新老访客
     * @param value
     * @return
     * @throws Exception
     */
    @Override
    public String map(JSONObject value) throws Exception {
        //获取之前是否有访问日期
        String beforeDateState = newDayVisitorState.value();
        //获取当前访问时间戳
        Long ts = value.getLong("ts");
        String currentDateStr = TimeUtil.format(ts);
        //判断日期是否为空进行新老访客识别
        if(StringUtils.isNotBlank(beforeDateState)){
            if(beforeDateState.equalsIgnoreCase(currentDateStr)){
                //一样则是老访客
                value.put("is_new",0);
                log.info("老访客:{}", currentDateStr);
            }else {
                //时间不一样，则是新用户,标记1，老访客标记0
                value.put("is_new",1);
                newDayVisitorState.update(currentDateStr);
                log.info("新访客:{}",currentDateStr);
            }
        }else {
            //如果状态为空，则是新用户,标记1，老访客标记0
            value.put("is_new",1);
            newDayVisitorState.update(currentDateStr);
            log.info("新访客:{}",currentDateStr);
        }
        return value.toJSONString();
    }
}
```

###### 18.5.4.2.6新老访客链路测试

- 测试数据

```
{"ip":"141.123.11.31","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}


{"ip":"141.123.11.30","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}
```

- 10.0.0.67测试

```
[root@centos7 ~]# nc -lk 8888

#第一次新访客
{"ip":"141.123.11.31","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}

#相同ip第二次老访客
{"ip":"141.123.11.31","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}


#又来了一个新的ip
{"ip":"141.123.11.30","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}
```

- idea控制台打印

```
##第一次新访客
{"ip":"141.123.11.31","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}
ods新老访客> {"referer":"","data":{"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"},"is_new":1,"ip":"141.123.11.31","bizId":"01U7PXo0","event":"SHORT_LINK_TYPE","udid":"1236B35491B946EB509D8E7B726158FB","ts":1676371826607}



#相同ip第二次老访客
{"ip":"141.123.11.31","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}
ods新老访客> {"referer":"","data":{"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"},"is_new":0,"ip":"141.123.11.31","bizId":"01U7PXo0","event":"SHORT_LINK_TYPE","udid":"1236B35491B946EB509D8E7B726158FB","ts":1676371826607}



#又来了一个新的ip
{"ip":"141.123.11.30","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}
ods新老访客> {"referer":"","data":{"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"},"is_new":1,"ip":"141.123.11.30","bizId":"01U7PXo0","event":"SHORT_LINK_TYPE","udid":"9BBD40A2888B2F47BD3F38DFA50E3A49","ts":1676371826607}
```

- 查看kafka

```
[root@iZ2zeashk7kdvi5eievv7sZ ~]# docker exec -it 68098f21 /bin/bash
bash-5.1# cd /opt/kafka/bin/

bash-5.1# ./kafka-console-consumer.sh --bootstrap-server 101.200.159.132:9092 --from-beginning --topic dwd_link_visit_topic

{"referer":"","data":{"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"},"is_new":1,"ip":"141.123.11.31","bizId":"01U7PXo0","event":"SHORT_LINK_TYPE","udid":"1236B35491B946EB509D8E7B726158FB","ts":1676371826607}
{"referer":"","data":{"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"},"is_new":0,"ip":"141.123.11.31","bizId":"01U7PXo0","event":"SHORT_LINK_TYPE","udid":"1236B35491B946EB509D8E7B726158FB","ts":1676371826607}
{"referer":"","data":{"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"},"is_new":1,"ip":"141.123.11.30","bizId":"01U7PXo0","event":"SHORT_LINK_TYPE","udid":"9BBD40A2888B2F47BD3F38DFA50E3A49","ts":1676371826607}
```

![1676388846201](短链平台项目.assets/1676388846201.png)

#### 18.5.5Flink实时标记-来源分布统计

##### 18.5.5.1需求背景

```
统计下哪些渠道推广比较好，比如投放广告，统计各个渠道的点击率来源统计

例⼦：
 老刘推广liusenbiao.com，对应的短链是g1.fit/adcdeft
 
付费广告（花钱）
 公众号广告
 抖音⾸屏广告
 B站广告
 知乎广告
免费广告（没钱）
 CSDN发文文章
 博客园发文章
 开源中国发文章
 知乎发文章
```

例子：https://tongji.baidu.com/web/demo/source/all?viewType=site&siteId=16847648

![1676377576909](短链平台项目.assets/1676377576909.png)

##### 18.5.5.2分布统计开发

###### 18.5.5.2.1DwdShortLinkLogApp

```
package net.xdclass.dwd;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.util.DeviceUtil;
import net.xdclass.util.KafkaUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.util.Collector;

import java.net.MalformedURLException;
import java.net.URL;

import java.util.Map;
import java.util.TreeMap;

/**
 * @author 刘森飚
 * @since 2023-02-14
 */

@Slf4j
public class DwdShortLinkLogApp {

    /**
     * 定义topic
     */
    public static final String SOURCE_TOPIC = "ods_link_visit_topic";

    /**
     * 定义消费者组
     */
    public static final String GROUP_ID = "dwd_short_link_group";

    public static void main(String [] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        DataStream<String> ds =  env.socketTextStream("10.0.0.67",8888);
        //FlinkKafkaConsumer<String> kafkaConsumer = KafkaUtil.getKafkaConsumer(SOURCE_TOPIC, GROUP_ID);
        //DataStreamSource<String> ds = env.addSource(kafkaConsumer);
        ds.print();
        //解析字符串还原成json类型的
        SingleOutputStreamOperator<JSONObject> jsonDS = ds.flatMap(new FlatMapFunction<String, JSONObject>() {
            @Override
            public void flatMap(String value, Collector<JSONObject> out) throws Exception {
                JSONObject jsonObject = JSON.parseObject(value);
                //生成设备唯一id
                String udid = getDeviceId(jsonObject);
                jsonObject.put("udid",udid);

                //生成访问来源地址
                String referer = getReferer(jsonObject);
                jsonObject.put("referer",referer);
                out.collect(jsonObject);
            }
        });
        env.execute();
    }



    /**
     * 提取referer
     * @param jsonObject
     * @return
     */
    public static String getReferer(JSONObject jsonObject){

        JSONObject dataJsonObj = jsonObject.getJSONObject("data");
        if(dataJsonObj.containsKey("referer")){

            String referer = dataJsonObj.getString("referer");
            if(StringUtils.isNotBlank(referer)){
                try {
                    URL url = new URL(referer);
                    return url.getHost();
                }catch (MalformedURLException e) {
                    log.error("提取referer失败:{}",e);
                }
            }
        }
        return "";
    }



    /**
     * 生成设备唯一id
     * @param jsonObject
     * @return
     */
    public static String getDeviceId(JSONObject jsonObject){
        Map<String,String> map = new TreeMap<>();
        try {
            map.put("ip",jsonObject.getString("ip"));
            map.put("event",jsonObject.getString("event"));
            map.put("bizId",jsonObject.getString("bizId"));
            String userAgent = jsonObject.getJSONObject("data").getString("user-agent");
            map.put("userAgent",userAgent);
            String deviceId = DeviceUtil.geneWebUniqueDeviceId(map);
            return deviceId;
        }catch (Exception e){

            log.error("生成唯一deviceid异常:{}",jsonObject);
            return null;
        }
    }
}
```
#### 18.5.6Flink数仓知识

##### 18.5.6.1数仓概念

- 度量值

```
可统计次数、个数、金额等，比如订单表中的下单金额
```

- 维度表

```
对事实的描述信息，每⼀张维表对应现实世界中的⼀个对象或者概念，如：用户、商品、日期、地区维度
比如分析产品销售情况，可以选择按商品类型，销售区域等等来分析
```

- 事实表

```
联系事实与维度表的数字度量值，事实数据表 包含 描述业务内特定事件的数据。
是数据聚合后依据【某些维度】生成的结果表。
事实表⾥存放了能体现实际数据或详细数据，⼀般由维度编码和事实数据组成。
```

- 例子一

```
⽼王，在22年11⽉11号，在天猫超市买了100件情趣⾐服花了800元，10盒霸王⽣发洗发⽔花了400元。
维度：时间、⽼王⽤户、情趣商品、霸王洗发⽔。
事实：100件、800元，10盒、400元。
```

- 结论

```
站在维度的角度去看事实表，看事实表的度量值。
事实表就是你要关注的内容，维度表就是【你观察该事物的角度，是从哪个角度去观察这个内容的，商品角度，地
区角度等】
维度是维度建模的基础和灵魂。在维度建模中，将度量称为“事实” ， 将环境描述为“维度”。
```

- 宽表（明细表)

```
简单讲字段比较多的数据库表，通常是指业务主题相关的指标、维度、属性关联在⼀起的⼀张数据库表。
把不同的内容都放在同⼀张表存储，宽表不符合三范式的模型设计规范。
尽量满⾜多维，多度量，遵循维度建模的原则。
缺点：数据的⼤量冗余。
优点：减少表关联数量，查询性能的提高，空间换时间。
```

- 窄表

```
严格按照数据库设计三范式，尽量减少数据冗余。
缺点：做数据分析查询OLAP时，需要大量关联多个表，性能下降。
优点：存储省空间，大量数据只存储某个表。
```

- 什么是数仓建模

```
OLTP中：Mysql数据库建表，表和表之间的关系模型，叫关系建模。
OLAP中：根据⼀个事实表为中心进行建表，面向业务分析为主，叫维度建模。
```

##### 18.5.6.2DWM层业务需求

- 数据处理分层说明

```
ODS、DWD和业务关联不⼤
DWM、DWS和业务关联就大，属于轻量级聚合部分数据
```

- 业务需求

```
需要得出短链访问的终端设备分布情况，做出【宽表】
浏览器类型分布 Chrome
操作系统分布 Android
设备类型分布 Mobile、Computer
设备生产⼚商 GOOGLE、APPLE
系统版本 Android 10、Intel Mac OS X 10_15_7
```

- 例子

```
浏览器组getBrowserName ：Chrome
设备操作系统getOs:Android
系统版本getOSVersion: Android 10
设备类型getDeviceType：MOBILE
设备生产⼚商getDeviceManufacturer:GOOGLE



设备操作系统getOs:Mac OS X
系统版本getOSVersion: Intel Mac OS X 10.15
设备类型getDeviceType：COMPUTER
设备生产⼚商getDeviceManufacturer:APPLE
```

##### 18.5.6.3浏览器头User-Agent

###### 18.5.6.3.1UserAgentUtils工具介绍

```
⼀个⽤来解析 User-Agent 字符串的 Java 类库。
可以识别 浏览器名字，浏览器组，浏览器类型，浏览器版本，浏览器的渲染引擎，android和ios设备的类型。
超过150种不同的浏览器; 7种不同的浏览器类型； 9种不同的Web应用。
超过60种不同的操作系统； 6种不同的设备类型； 9种不同的渲染引擎；
```

###### 18.5.6.3.2工具类依赖

```
<!-- useragent提取工具 -->
<dependency>
    <groupId>eu.bitwalker</groupId>
    <artifactId>UserAgentUtils</artifactId>
    <version>1.21</version>
</dependency>
```

###### 18.5.6.3.3单元测试

```
package net.xdclass;

import eu.bitwalker.useragentutils.Browser;
import eu.bitwalker.useragentutils.OperatingSystem;
import eu.bitwalker.useragentutils.UserAgent;
import lombok.extern.slf4j.Slf4j;
import org.junit.Test;

/**
 * @author 刘森飚
 * @since 2023-02-15
 */

@Slf4j
public class UtilTest {

    @Test
    public void testUserAgentUtil(){
        String userAgentStr = "Mozilla/5.0 (Linux; Android 10; LIO-AN00 Build/HUAWEILIO-AN00; wv)" +
                " AppleWebKit/537.36 (KHTML, like Gecko) " +
                "Version/4.0 Chrome/77.0.3865.120 MQQBrowser/6.2 TBS/045713 Mobile Safari/537.36 MMWEBID/3189" +
                " MicroMessenger/8.0.11.1980(0x28000B51) Process/tools WeChat/arm64 Weixin NetType/WIFI " +
                "Language/zh_CN ABI/arm64";
        UserAgent userAgent = UserAgent.parseUserAgentString(userAgentStr);
        Browser browser = userAgent.getBrowser();
        OperatingSystem operatingSystem = userAgent.getOperatingSystem();
        String browserName = browser.getGroup().getName();
        String os = operatingSystem.getGroup().getName();
        String manufacture = operatingSystem.getManufacturer().getName();
        String deviceType = operatingSystem.getDeviceType().getName();
        System.out.println("browserName="+browserName+",os="+os+",manufacture="+manufacture+",deviceType="+deviceType);
    }
}
```

![1676456660808](短链平台项目.assets/1676456660808.png)

###### 18.5.6.3.4工具类封装

- DeviceUtil

```
/**
 * 获取浏览器对象
 * @param agent
 * @return
 */
public static Browser getBrowser(String agent){
    UserAgent userAgent = UserAgent.parseUserAgentString(agent);
    return userAgent.getBrowser();
}



/**
 * 获取操作系统
 * @param agent
 * @return
 */
public static OperatingSystem getOperationSystem(String agent){
    UserAgent userAgent = UserAgent.parseUserAgentString(agent);
    return userAgent.getOperatingSystem();
}



/**
 * 获取浏览器名称
 * @param agent
 * @return Firefox、Chrome
 */
public static String getBrowserName(String agent){
    return getBrowser(agent).getGroup().getName();
}



/**
 * 获取设备类型
 * @param agent
 * @return MOBILE、COMPUTER
 */
public static String getDeviceType(String agent){
    return getOperationSystem(agent).getDeviceType().toString();
}



/**
 * 获取os: windwos、IOS、Android
 * @param agent
 * @return
 */
public static String getOS(String agent){
    return getOperationSystem(agent).getGroup().getName();
}



/**
 * 获取设备厂家
 * @param agent
 * @return
 */
public static String getDeviceManufacturer(String agent){
    return getOperationSystem(agent).getManufacturer().toString();
}




/**
 * 操作系统版本
 * @param userAgent
 * @return Android 1.x、Intel Mac OS X 10.15
 */
public static String getOSVersion(String userAgent) {
    String osVersion = "";
    if(StringUtils.isBlank(userAgent)) {
        return osVersion;
    }
    String[] strArr = userAgent.substring(userAgent.indexOf("(")+1,
            userAgent.indexOf(")")).split(";");
    if(null == strArr || strArr.length == 0) {
        return osVersion;
    }
    osVersion = strArr[1];
    return osVersion;
}



/**
 * 解析对象
 * @param agent
 * @return
 */
public static DeviceInfoDO getDeviceInfo(String agent){
    UserAgent userAgent = UserAgent.parseUserAgentString(agent);
    Browser browser = userAgent.getBrowser();
    OperatingSystem operatingSystem = userAgent.getOperatingSystem();
    String browserName = browser.getGroup().getName();
    String os = operatingSystem.getGroup().getName();
    String manufacture = operatingSystem.getManufacturer().toString();
    String deviceType = operatingSystem.getDeviceType().toString();
    DeviceInfoDO deviceInfoDO = DeviceInfoDO.builder().browserName(browserName)
            .deviceManufacturer(manufacture)
            .deviceType(deviceType)
            .os(os)
            .osVersion(getOSVersion(agent))
            .build();
    return deviceInfoDO;
}
```

- DeviceInfoDO

```
package net.xdclass.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author 刘森飚
 * @since 2023-02-15
 */


@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class DeviceInfoDO {

    /**
     * 浏览器名称
     */
    private String browserName;

    /**
     * 系统
     */
    private String os;

    /**
     * 系统版本
     */
    private String osVersion;


    /**
     * 设备类型
     */
    private String deviceType;

    /**
     * 厂商
     */
    private String deviceManufacturer;


    /**
     * 终端用户唯一标识
     */
    private String udid;
}
```

##### 18.5.6.4短链访问设备信息宽表开发

###### 18.5.6.4.1ShortLinkWideDO

```
package net.xdclass.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author 刘森飚
 * @since 2023-02-15
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ShortLinkWideDO {

    //======短链业务本身信息==========

    /**
     * 短链码
     */
    private String code;


    /**
     * 账号
     */
    private Long accountNo;


    /**
     * 访问时间
     */
    private Long visitTime;


    /**
     * 站点来源，只记录域名
     */
    private String referer;


    /**
     * 1是新访客，0是旧访客
     */
    private Integer isNew;


    /**
     * 访问来源ip
     */
    private String ip;


    //===============设备相关字段=============

    /**
     *
     * 浏览器名称
     */
    private String browserName;

    /**
     * 系统
     */
    private String os;

    /**
     * 系统版本
     */
    private String osVersion;


    /**
     * 设备类型
     */
    private String deviceType;

    /**
     * 厂商
     */
    private String deviceManufacturer;


    /**
     * 终端用户唯一标识
     */
    private String udid;


}
```

###### 18.5.6.4.2DwmShortLinWideApp

```
package net.xdclass.dwm;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import net.xdclass.model.DeviceInfoDO;
import net.xdclass.model.ShortLinkWideDO;
import net.xdclass.util.DeviceUtil;
import net.xdclass.util.KafkaUtil;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.util.Collector;

/**
 * @author 刘森飚
 * @since 2023-02-15
 */

public class DwmShortLinWideApp {

    /**
     * 定义source topic
     */
    public static final String SOURCE_TOPIC = "dwd_link_visit_topic";

    /**
     * 定义消费者组
     */
    public static final String GROUP_ID = "dwm_short_link_group";

    public static void main(String [] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        //DataStream<String> ds =  env.socketTextStream("127.0.0.1",8888);
        FlinkKafkaConsumer<String> kafkaConsumer = KafkaUtil.getKafkaConsumer(SOURCE_TOPIC, GROUP_ID);
        DataStreamSource<String> ds = env.addSource(kafkaConsumer);
        //格式装换，补齐设备信息
        //做出宽表
        SingleOutputStreamOperator<ShortLinkWideDO> deviceWideDS = ds.flatMap(new FlatMapFunction<String, ShortLinkWideDO>() {
            @Override
            public void flatMap(String value, Collector<ShortLinkWideDO> out) throws Exception {
                //还原json
                JSONObject jsonObject = JSON.parseObject(value);
                String userAgent = jsonObject.getJSONObject("data").getString("user-agent");
                String udid = jsonObject.getString("udid");
                DeviceInfoDO deviceInfoDO = DeviceUtil.getDeviceInfo(userAgent);
                deviceInfoDO.setUdid(udid);
                //配置短链基本信息宽表
                ShortLinkWideDO shortLinkWideDO = ShortLinkWideDO.builder()
                        //短链访问基本信息
                        .visitTime(jsonObject.getLong("ts"))
                        .accountNo(jsonObject.getJSONObject("data").getLong("accountNo"))
                        .code(jsonObject.getString("bizId"))
                        .referer(jsonObject.getString("referer"))
                        .isNew(jsonObject.getInteger("is_new"))
                        .ip(jsonObject.getString("ip"))

                        //设备信息补齐
                        .browserName(deviceInfoDO.getBrowserName())
                        .os(deviceInfoDO.getOs())
                        .osVersion(deviceInfoDO.getOsVersion())
                        .deviceType(deviceInfoDO.getDeviceType())
                        .deviceManufacturer(deviceInfoDO.getDeviceManufacturer())
                        .udid(deviceInfoDO.getUdid())
                        .build();
                out.collect(shortLinkWideDO);
            }
        });

        deviceWideDS.print("设备信息宽表补齐");
        env.execute();
    }
}
```

###### 18.5.6.4.3短链访问记录宽表链路数据测试

- 不同浏览器访问短链

http://localhost:8003/01U7PXo0

- 改ip为ip访问	

http://192.168.100.99:8003/01U7PXo0

- 打印访问记录宽表信息

```
设备信息宽表补齐> ShortLinkWideDO(code=01U7PXo0, accountNo=830033392337682432, visitTime=1676460971174, referer=, isNew=1, ip=192.168.100.99, browserName=Chrome, os=Windows, osVersion= WOW64, deviceType=COMPUTER, deviceManufacturer=MICROSOFT, udid=7DEFEAD9EAD86EF4B65554BD9D031C45)


设备信息宽表补齐> ShortLinkWideDO(code=01U7PXo0, accountNo=830033392337682432, visitTime=1676461077583, referer=, isNew=0, ip=192.168.100.99, browserName=Chrome, os=Windows, osVersion= Win64, deviceType=COMPUTER, deviceManufacturer=MICROSOFT, udid=953D8F238672BA9495CAD8A427987B28)
```

![1676474207523](短链平台项目.assets/1676474207523.png)

#### 18.5.7短链UV统计开发

##### 18.5.7.1开发思路

```
获取数据
转换对象
分组统计
排重过滤
写入Kafka
```

##### 18.5.7.2编码开发

###### 18.5.7.2.1DwmUniqueVisitorApp

```
package net.xdclass.dwm;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import net.xdclass.func.UniqueVisitorFilterFunction;
import net.xdclass.util.KafkaUtil;
import org.apache.flink.api.java.functions.KeySelector;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;

/**
 * @author 刘森飚
 * @since 2023-02-16
 */

public class DwmUniqueVisitorApp {

    /**
     * 定义source topic
     */
    public static final String SOURCE_TOPIC = "dwm_link_visit_topic";

    /**
     * 定义消费者组
     */
    public static final String GROUP_ID = "dwm_unique_visitor_group";

    /**
     * 定义输出
     */
    public static final String SINK_TOPIC = "dwm_unique_visitor_topic";

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        //DataStream<String> ds =  env.socketTextStream("127.0.0.1",8888);
        //1、获取数据流
        FlinkKafkaConsumer<String> kafkaConsumer = KafkaUtil.getKafkaConsumer(SOURCE_TOPIC,GROUP_ID);
        DataStreamSource<String> ds = env.addSource(kafkaConsumer);

        //2、数据转换
        SingleOutputStreamOperator<JSONObject> jsonDS = ds.map(jsonStr -> JSON.parseObject(jsonStr));

        //3、分组
        KeyedStream<JSONObject, String> keyedStream = jsonDS.keyBy(new KeySelector<JSONObject, String>() {
            @Override
            public String getKey(JSONObject value) throws Exception {
                return value.getString("udid");
            }
        });

        //4、排重过滤
        SingleOutputStreamOperator<JSONObject> filterDS = keyedStream.filter(new UniqueVisitorFilterFunction());
        filterDS.print("独立访客");

        //5、转成字符串写入kafka
        SingleOutputStreamOperator<String> uniqueVisitorDS = filterDS.map(obj -> obj.toJSONString());
        FlinkKafkaProducer<String> kafkaProducer = KafkaUtil.getKafkaProducer(SINK_TOPIC);
        uniqueVisitorDS.addSink(kafkaProducer);
        env.execute();
    }
}
```

###### 18.5.7.2.2UniqueVisitorFilterFunction

```
package net.xdclass.func;

import com.alibaba.fastjson.JSONObject;
import net.xdclass.util.TimeUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.flink.api.common.functions.RichFilterFunction;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.time.Time;
import org.apache.flink.configuration.Configuration;

/**
 * @author 刘森飚
 * @since 2023-02-16
 */

public class UniqueVisitorFilterFunction extends RichFilterFunction<JSONObject> {

    private ValueState<String> lastVisitDateState = null;


    @Override
    public void open(Configuration parameters) throws Exception {
        ValueStateDescriptor<String> visitDateStateDes = new ValueStateDescriptor<>
                ("visitDateState", String.class);
        //统计UV
        StateTtlConfig stateTtlConfig = StateTtlConfig.newBuilder(Time.days(1)).build();
        visitDateStateDes.enableTimeToLive(stateTtlConfig);
        this.lastVisitDateState = getRuntimeContext().getState(visitDateStateDes);

    }




    @Override
    public void close() throws Exception {
        super.close();
    }



    @Override
    public boolean filter(JSONObject jsonObj) throws Exception {
        //获取当前访问时间
        Long visitTime = jsonObj.getLong("visitTime");
        String udid = jsonObj.getString("udid");
        //当前访问时间
        String currentVisitDate = TimeUtil.format(visitTime);
        //获取上次的状态访问时间
        String lastVisitDate = lastVisitDateState.value();
        ////用当前页面的访问时间和状态时间进行对比
        if(StringUtils.isNotBlank(lastVisitDate) && currentVisitDate.equalsIgnoreCase(lastVisitDate)){
            System.out.println(udid+" 已经在 "+currentVisitDate+"时间访问过");
            return false;
        }else {
            System.out.println(udid+" 在 "+currentVisitDate+"时间初次访问");
            lastVisitDateState.update(currentVisitDate);
            return true;
        }
    }
}
```

###### 18.5.7.2.3短链UV统计链路测试

- 测试数据

```
{"ip":"223.107.195.118","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}
```

- 控制台打印

```
08B8EE5BE81B4880D56CEBD506B102E5 在 2023-02-14时间初次访问
独立访客> {"deviceType":"COMPUTER","referer":"","code":"01U7PXo0","os":"Windows","city":"泰州市","ip":"223.107.195.118","isNew":1,"visitTime":1676371826607,"osVersion":" Win64","province":"江苏省","accountNo":830033392337682432,"browserName":"Chrome","deviceManufacturer":"MICROSOFT","udid":"08B8EE5BE81B4880D56CEBD506B102E5"}
08B8EE5BE81B4880D56CEBD506B102E5 已经在 2023-02-14时间访问过
08B8EE5BE81B4880D56CEBD506B102E5 已经在 2023-02-14时间访问过
08B8EE5BE81B4880D56CEBD506B102E5 已经在 2023-02-14时间访问过
```

![1676568294581](短链平台项目.assets/1676568294581.png)

#### 18.5.8DWS层数据处理

##### 18.5.8.1多流数据聚合介绍

- 统计指标

```
PV -》从DWM层 dwm_link_visit_topic统计
UV-》从DWM层 dwm_unique_visitor_topic统计
```

- Flink多流合并

```
Flink提供了多流转换算⼦，方便我们对多个数据流进行整合处理。

union
可以合并多个【同类型】的数据流，并生成【同类型】的数据流。
数据将按照先进先出（First In First Out）的模式合并，且不去重。

connect
和union类型，但是各有利弊
connect只能连接两个不同类型的数据流，union可以连接多个同类型数据流。
经过connect之后被转化为ConnectedStreams，会对两个流的数据应用不同的处理方法。
```

##### 18.5.8.2业务Topic主题开发

###### 18.5.8.2.1ShortLinkVisitStatsDO

```
package net.xdclass.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author 刘森飚
 * @since 2023-02-17
 */


@Data	
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ShortLinkVisitStatsDO {

    /**
     * 窗口开始时间  Clickhouse里面会用到
     */
    String startTime;

    /**
     * 窗口结束时间
     */
    String endTime;

/**
 * ================================================
 */


    /**
     * 短链压缩码
     */
    private String code;

    /**
     * 租户id
     */
    private Long accountNo;


    /**
     * 访问时间
     */
    private Long visitTime;

    /**
     * 站点来源，只记录域名
     */
    private String referer;

    /**
     * 1是新访客，0是老访客
     */
    private Integer isNew;

    /**
     * 唯一标识
     */
    private String udid;

    //==============RegionInfoDO==================

    /**
     * 省份
     */
    private String province;

    /**
     * 城市
     */
    private String city;

    /**
     * 运营商
     */
    private String isp;

    /**
     * 访问ip
     */
    private String ip;

//==============DeviceInfoDO==================

    /**
     * 浏览器名称
     */
    private String browserName;

    /**
     * 操作系统
     */
    private String os;

    /**
     * 系统版本
     */
    private String osVersion;

    /**
     * 设备类型
     */
    private String deviceType;

    /**
     * 设备厂商
     */
    private String deviceManufacturer;

//==============度量==================

    private Long uv=0L;

    private Long pv=0L;

}
```

###### 18.5.8.2.2DwsShortLinkVisitStatsApp

- 开发流程

```
//1、获取多个数据
//2、结构转换 uniqueVisitorDS、shortLinkDS
//3、多流合并（合并相同结构的流）
//4、设置WaterMark
//5、多维度、多个字段分组
//6、开窗15秒⼀次数据插入到ck
//7、聚合统计(补充统计起止时间)
//8、输出Clickhouse
```

```
package net.xdclass.dws;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import net.xdclass.model.ShortLinkVisitStatsDO;
import net.xdclass.util.KafkaUtil;
import net.xdclass.util.MyClickHouseSink;
import net.xdclass.util.TimeUtil;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.common.functions.ReduceFunction;
import org.apache.flink.api.java.functions.KeySelector;
import org.apache.flink.api.java.tuple.Tuple9;
import org.apache.flink.streaming.api.datastream.*;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.util.Collector;

import java.time.Duration;

/**
 * @author 刘森飚
 * @since 2023-02-17
 */

public class DwsShortLinkVisitStatsApp {


    /**
     * 宽表
     */
    public static final String SHORT_LINK_SOURCE_TOPIC = "dwm_link_visit_topic";

    public static final String SHORT_LINK_SOURCE_GROUP = "dws_link_visit_group";



    /**
     * uv的数据流
     */
    public static final String UNIQUE_VISITOR_SOURCE_TOPIC = "dwm_unique_visitor_topic";

    public static final String UNIQUE_VISITOR_SOURCE_GROUP = "dws_unique_visitor_group";


    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        //1、获取多个数据
        FlinkKafkaConsumer<String> shortLinkSource = KafkaUtil.getKafkaConsumer
                (SHORT_LINK_SOURCE_TOPIC,SHORT_LINK_SOURCE_GROUP);
        DataStreamSource<String> shortLinkDS = env.addSource(shortLinkSource);

        FlinkKafkaConsumer<String> uniqueVisitorSource = KafkaUtil.getKafkaConsumer
                (UNIQUE_VISITOR_SOURCE_TOPIC, UNIQUE_VISITOR_SOURCE_GROUP);
        DataStreamSource<String> uniqueVisitorDS = env.addSource(uniqueVisitorSource);

        //2、结构转换 uniqueVisitorDS、shortLinkDS
        SingleOutputStreamOperator<ShortLinkVisitStatsDO> shortLinkMapDS = shortLinkDS.map(new MapFunction<String, ShortLinkVisitStatsDO>() {
            @Override
            public ShortLinkVisitStatsDO map(String value) throws Exception {
                ShortLinkVisitStatsDO visitStatsDO = parseVisitStats(value);
                visitStatsDO.setPv(1L);
                visitStatsDO.setUv(0L);
                return visitStatsDO;
            }
        });


        SingleOutputStreamOperator<ShortLinkVisitStatsDO> uniqueVisitorMapDS = uniqueVisitorDS.map(new MapFunction<String, ShortLinkVisitStatsDO>() {
            @Override
            public ShortLinkVisitStatsDO map(String value) throws Exception {
                ShortLinkVisitStatsDO visitStatsDO = parseVisitStats(value);
                visitStatsDO.setPv(0L);
                visitStatsDO.setUv(1L);
                return visitStatsDO;
            }
        });


        //3、多流合并（合并相同结构的流）
        DataStream<ShortLinkVisitStatsDO> unionDS = shortLinkMapDS.union(uniqueVisitorMapDS);

        //4、设置WaterMark
        //设置WaterMark触发计算的条件是：watermark = 窗口的endtime + 最大允许延迟时间
        SingleOutputStreamOperator<ShortLinkVisitStatsDO> watermarkDS = unionDS.
                assignTimestampsAndWatermarks(WatermarkStrategy
                //指定允许乱序延迟最大3秒
                .<ShortLinkVisitStatsDO>forBoundedOutOfOrderness(Duration.ofSeconds(3))
                //指定事件时间列，毫秒
                .withTimestampAssigner((event, timestamp) -> event.getVisitTime()));


        //5、多维度、多个字段分组
        // code、referer、isNew
        // province、city、ip
        // browserName、os、deviceType
        KeyedStream<ShortLinkVisitStatsDO, Tuple9<String, String, Integer, String, String, String, String, String, String>> keyedStream =
                watermarkDS.keyBy(new KeySelector<ShortLinkVisitStatsDO, Tuple9<String, String, Integer, String, String, String, String, String, String>>() {
            @Override
            public Tuple9<String, String, Integer, String, String, String, String, String, String>
            getKey(ShortLinkVisitStatsDO obj) throws Exception {
                return Tuple9.of(obj.getCode(), obj.getReferer(), obj.getIsNew(),
                        obj.getProvince(), obj.getCity(), obj.getIp(),
                        obj.getBrowserName(), obj.getOs(), obj.getDeviceType());
            }
        });


        //6、开窗 10秒一次数据插入到 ck
        WindowedStream<ShortLinkVisitStatsDO, Tuple9
                <String, String, Integer, String, String, String, String, String, String>, TimeWindow> windowedStream =
                keyedStream.window(TumblingEventTimeWindows.of(Time.seconds(10)));


        //7、聚合统计(补充统计起止时间)
        SingleOutputStreamOperator<Object> reduceDS = windowedStream.reduce(new ReduceFunction<ShortLinkVisitStatsDO>() {
            @Override
            public ShortLinkVisitStatsDO reduce(ShortLinkVisitStatsDO value1, ShortLinkVisitStatsDO value2) throws Exception {
                value1.setPv(value1.getPv() + value2.getPv());
                value1.setUv(value1.getUv() + value2.getUv());
                return value1;
            }
        }, new ProcessWindowFunction<ShortLinkVisitStatsDO, Object, Tuple9
                <String, String, Integer, String, String, String, String, String, String>, TimeWindow>() {
            @Override
            public void process(Tuple9<String, String, Integer, String, String, String, String, String, String> tuple,
                                Context context, Iterable<ShortLinkVisitStatsDO> elements, Collector<Object> out) throws Exception {
                for (ShortLinkVisitStatsDO visitStatsDO : elements) {
                    //窗口开始和结束时间
                    String startTime = TimeUtil.formatWithTime(context.window().getStart());
                    String endTime = TimeUtil.formatWithTime(context.window().getEnd());
                    visitStatsDO.setStartTime(startTime);
                    visitStatsDO.setEndTime(endTime);
                    out.collect(visitStatsDO);
                }
            }
        });
        reduceDS.print(">>>>>>");

        //8、输出Clickhouse
        String sql = "insert into visit_stats values(?,?,?,? ,?,?,?,? ,?,?,?,? ,?,?,?)";
        reduceDS.addSink(MyClickHouseSink.getJdbcSink(sql));
        env.execute();
    }




    /**
     * 把json转换成Do对象
     * @param value
     * @return
     */
    private static ShortLinkVisitStatsDO parseVisitStats(String value) {
        JSONObject jsonObj = JSON.parseObject(value);
        ShortLinkVisitStatsDO visitStatsDO = ShortLinkVisitStatsDO.builder()
                .code(jsonObj.getString("code"))
                .accountNo(jsonObj.getLong("accountNo"))
                .visitTime(jsonObj.getLong("visitTime"))
                .referer(jsonObj.getString("referer"))
                .isNew(jsonObj.getInteger("isNew"))
                .udid(jsonObj.getString("udid"))

                //地理位置信息
                .province(jsonObj.getString("province"))
                .city(jsonObj.getString("city"))
                .isp(jsonObj.getString("isp"))
                .ip(jsonObj.getString("ip"))

                //设备信息
                .browserName(jsonObj.getString("browserName"))
                .os(jsonObj.getString("os"))
                .osVersion(jsonObj.getString("osVersion"))
                .deviceType(jsonObj.getString("deviceType"))
                .deviceManufacturer(jsonObj.getString("deviceManufacturer"))
                .build();
        return visitStatsDO;
    }
}
```

###### 18.5.8.2.3TimeUtil

```
package net.xdclass.util;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Date;

/**
 * @author 刘森飚
 * @since 2023-02-17
 */

public class TimeUtil {


    /**
     * 默认日期格式
     */
    private static final String DEFAULT_PATTERN = "yyyy-MM-dd";

    private static final String DEFAULT_PATTERN_WITH_TIME = "yyyy-MM-dd hh:mm:ss";

    /**
     * 默认日期格式
     */
    private static final DateTimeFormatter DEFAULT_DATE_FORMATTER  = DateTimeFormatter.ofPattern(DEFAULT_PATTERN);

    /**
     * 默认日期时间格式
     */
    private static final DateTimeFormatter DEFAULT_DATE_TIME_FORMATTER  = DateTimeFormatter.ofPattern(DEFAULT_PATTERN_WITH_TIME);


    private static final ZoneId DEFAULT_ZONE_ID = ZoneId.systemDefault();


    /**
     * LocalDateTime 转 字符串，指定日期格式
     * @param localDateTime
     * @param pattern
     * @return
     */
    public static String format(LocalDateTime localDateTime, String pattern){
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        String timeStr = formatter.format(localDateTime.atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }


    /**
     * Date 转 字符串, 指定日期格式
     * @param time
     * @param pattern
     * @return
     */
    public static String format(Date time, String pattern){
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        String timeStr = formatter.format(time.toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }

    /**
     *  Date 转 字符串，默认日期格式
     * @param time
     * @return
     */
    public static String format(Date time){

        String timeStr = DEFAULT_DATE_FORMATTER.format(time.toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }

    /**
     *  Date 转 字符串，默认日期格式
     * @param timestamp
     * @return
     */
    public static String format(Long timestamp){
        String timeStr = DEFAULT_DATE_FORMATTER.format(new Date(timestamp).toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }



    /**
     * timestamp 转 字符串，指定日期格式
     *
     * @param timestamp
     * @return
     */
    public static String formatWithTime(long timestamp) {
        String timeStr = DEFAULT_DATE_TIME_FORMATTER.format(new Date(timestamp).toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }


    /**
     * 字符串 转 Date
     * @param time
     * @return
     */
    public static Date strToDate(String time) {
        LocalDateTime localDateTime = LocalDateTime.parse(time, DEFAULT_DATE_FORMATTER);
        return Date.from(localDateTime.atZone(DEFAULT_ZONE_ID).toInstant());
    }
}
```

##### 18.5.8.3模拟IP数据处理链路测试

###### 18.5.8.3.1链路测试需求

```
访问短链->记录日志->KAFKA->ODS->DWD->DWM(设备补齐、地区补齐、UV统计、PV统计)->DWS

问题
本地访问是局域网ip，没法解析地理位置信息，临时编写死ip
```

###### 18.5.8.3.2测试数据

- LogServiceImpl

```
package net.xdclass.service.impl;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.enums.LogTypeEnum;
import net.xdclass.model.LogRecord;
import net.xdclass.service.LogService;
import net.xdclass.util.CommonUtil;
import net.xdclass.util.JsonData;
import net.xdclass.util.JsonUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;
import java.util.*;

/**
 * @author 刘森飚
 * @since 2023-02-17
 */

@Service
@Slf4j
public class LogServiceImpl implements LogService {



    private static final String TOPIC_NAME = "ods_link_visit_topic";

    @Autowired
    private KafkaTemplate kafkaTemplate;


    /**
     * ==========用于测试==========
     */
    private static List<String> ipList = new ArrayList<>();
    static {
        //深圳
        ipList.add("14.197.9.110");
        //广州
        ipList.add("113.68.152.139");
        //江苏
        ipList.add("223.107.195.118");
    }

    private static List<String> refererList = new ArrayList<>();
    static {
        refererList.add("https://taobao.com");
        refererList.add("https://douyin.com");
    }
    private Random random = new Random();


    @Override
    public void recordShortLinkLog(HttpServletRequest request, String shortLinkCode, Long accountNo) {
....
        //ip、浏览器信息
        //String ip = CommonUtil.getIpAddr(request);
        String ip = ipList.get(random.nextInt(ipList.size()));
        //全部请求头
        Map<String,String> headerMap = CommonUtil.getAllRequestHeader(request);
        Map<String,String> availableMap = new HashMap<>();
        availableMap.put("user-agent",headerMap.get("user-agent"));
        //availableMap.put("referer",headerMap.get("referer"));
        availableMap.put("referer",refererList.get(random.nextInt(refererList.size())));
....
    }
}
```

###### 18.5.8.3.3测试链路

```
短链地址 http://localhost:8003/0372Oot0
A浏览器 访问短链
B浏览器 访问短链
```

- DwsShortLinkVisitStatsAppc测试结果

```
>>>>>>> ShortLinkVisitStatsDO(startTime=2023-02-17 11:50:30, endTime=2023-02-17 11:50:40, code=0372Oot0, accountNo=830033392337682432, visitTime=1676649039489, referer=douyin.com, isNew=1, udid=8188703483D9C0A4AA61719E450B6F1A, province=江苏省, city=泰州市, isp=null, ip=223.107.195.118, browserName=Chrome, os=Windows, osVersion= Win64, deviceType=COMPUTER, deviceManufacturer=null, uv=1, pv=1)

>>>>>>> ShortLinkVisitStatsDO(startTime=2023-02-17 11:51:00, endTime=2023-02-17 11:51:10, code=0372Oot0, accountNo=830033392337682432, visitTime=1676649065171, referer=taobao.com, isNew=1, udid=DC4F04761094059FD8FA003220CD87BD, province=广东省, city=广州市, isp=null, ip=113.68.152.139, browserName=Chrome, os=Windows, osVersion= Win64, deviceType=COMPUTER, deviceManufacturer=null, uv=1, pv=1)

>>>>>>> ShortLinkVisitStatsDO(startTime=2023-02-17 11:51:00, endTime=2023-02-17 11:51:10, code=0372Oot0, accountNo=830033392337682432, visitTime=1676649067894, referer=taobao.com, isNew=0, udid=8188703483D9C0A4AA61719E450B6F1A, province=江苏省, city=泰州市, isp=null, ip=223.107.195.118, browserName=Chrome, os=Windows, osVersion= Win64, deviceType=COMPUTER, deviceManufacturer=null, uv=0, pv=1)
```

### 18.6短链访问数据可视化

#### 18.6.1地理位置信息解析

##### 18.6.1.1需求说明

```
IP信息转换为地理位置信息
案例：https://tongji.baidu.com/web/demo/visit/district?siteId=16847648
```

- 解决方案

```
离线
纯真IP库
GeoLite2
埃文科技
ip2region
https://github.com/lionsoul2014/ip2region

在线
百度地图API
https://lbsyun.baidu.com/index.php?title=webapi/ip-api
高德地图API
https://lbs.amap.com/api/webservice/guide/api/ipconfig
```

##### 18.6.1.2高德地图API接入

###### 18.6.1.2.1调用API流程

```
第一步，申请”web服务 API”密钥（Key）；
第二步，拼接HTTP请求URL，第一步申请的Key需作为必填参数一同发送；
第三步，接收HTTP请求返回的数据（JSON或XML格式），解析数据。
如无特殊声明，接口的输入参数和输出数据编码全部统一为UTF-8。
```

- **请求参数**

![1676476343871](短链平台项目.assets/1676476343871.png)

- **返回结果参数说明**

![1676476388978](短链平台项目.assets/1676476388978.png)



###### 18.6.1.2.2申请API密钥

![1676476572365](短链平台项目.assets/1676476572365.png)

![1676476771665](短链平台项目.assets/1676476771665.png)

![1676477030166](短链平台项目.assets/1676477030166.png)

- 测试

![1676477304394](短链平台项目.assets/1676477304394.png)

###### 18.6.1.2.3添加依赖

```
<!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient -->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
    <version>4.5.13</version>
</dependency>
```

###### 18.6.1.2.4补齐宽表数据DO

- ShortLinkWideDO

```
//====地理位置信息=======

/**
 * 国家
 */
private String country;

/**
 * 省份
 */
private String province;

/**
 * 城市
 */
private String city;

/**
 * 运营商
 */
private String isp;

/**
 * 访问来源ip
 */
private String ip;
```

###### 18.6.1.2.5自定义函数

- LocationMapFunction

![1676531827866](短链平台项目.assets/1676531827866.png)

```
package net.xdclass.func;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.model.ShortLinkWideDO;
import org.apache.flink.api.common.functions.RichMapFunction;
import org.apache.flink.configuration.Configuration;
import org.apache.http.HttpEntity;
import org.apache.http.HttpStatus;
import org.apache.http.client.HttpClient;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.util.EntityUtils;

/**
 * @author 刘森飚
 * @since 2023-02-16
 */

@Slf4j
public class LocationMapFunction extends RichMapFunction<ShortLinkWideDO,String> {

    private static final String IP_PARSE_URL =
            "https://restapi.amap.com/v3/ip?ip=%s&output=json&key=5a7de5d119a47da428dfe7cc26d550d7";

    private CloseableHttpClient httpClient;


    /**
     * void open(Configuration parameters)：
     * 该方法在 map 函数执行之前被调用，用于执行一些初始化工作，
     * 如获取连接、加载模型等操作。
     * 可以通过参数parameters传递配置信息，如连接地址、模型路径等
     * @param parameters
     * @throws Exception
     */
    @Override
    public void open(Configuration parameters) throws Exception {
        this.httpClient = createHttpClient();
    }



    /**
     *void close()：
     * 该方法在 map 函数执行完成后被调用，
     * 用于执行一些清理工作，如关闭连接、释放资源等操作。
     * @throws Exception
     */
    @Override
    public void close() throws Exception {
        if(httpClient != null){
            httpClient.close();
        }
    }



    /**
     * 解析地理位置
     * @param value
     * @return
     * @throws Exception
     */
    @Override
    public String map(ShortLinkWideDO value) throws Exception {
        String ip = value.getIp();
        String url = String.format(IP_PARSE_URL,ip);
        HttpGet httpGet = new HttpGet(url);
        try(CloseableHttpResponse response = httpClient.execute(httpGet)){
            int statusCode = response.getStatusLine().getStatusCode();
            if(statusCode == HttpStatus.SC_OK){
                HttpEntity entity = response.getEntity();
                String result = EntityUtils.toString(entity, "UTF-8");
                JSONObject locationObj = JSON.parseObject(result);
                String province = locationObj.getString("province");
                String city = locationObj.getString("city");
                value.setProvince(province);
                value.setCity(city);
            }
        }catch (Exception e){
            log.error("ip解析错误,value={},msg={}",value,e.getMessage());
        }
        return JSON.toJSONString(value);
    }


    /**
     * CloseableHttpClient 是 Java 中一个用于发送 HTTP 请求和接收 HTTP 响应的接口。
     * 它是 Apache HttpClient 库中的一部分，提供了一组功能强大的方法，
     * 使开发人员可以使用各种 HTTP 方法（例如 GET、POST、PUT、DELETE 等）与服务器进行交互
     * @return
     */
    private CloseableHttpClient createHttpClient(){
        Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create()
                .register("http", PlainConnectionSocketFactory.getSocketFactory())
                .register("https", SSLConnectionSocketFactory.getSocketFactory())
                .build();
        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(registry);
        //MaxPerRoute是对maxtotal的细分，每个主机的并发最大是300，route是指域名
        connectionManager.setDefaultMaxPerRoute(300);
        //设置连接池最大是500个连接
        connectionManager.setMaxTotal(500);
        /**
         * 只请求 liusenbiao.net,最大并发300
         *
         * 请求 liusenbiao.net,最大并发300
         * 请求 open1024.com,最大并发200
         *
         * //MaxtTotal=400 DefaultMaxPerRoute=200
         * //只连接到http://xdclass.net时，到这个主机的并发最多只有200；而不是400；
         * //而连接到http://xdclass.net 和 http://open1024.com时，到每个主机的并发最多只有200；
         * // 即加起来是400（但不能超过400）；所以起作用的设置是DefaultMaxPerRoute。
         *
         */
        RequestConfig requestConfig = RequestConfig.custom()
                //返回数据的超时时间
                .setSocketTimeout(20000)
                //连接上服务器的超时时间
                .setConnectTimeout(10000)
                //从连接池中获取连接的超时时间
                .setConnectionRequestTimeout(1000)
                .build();
        CloseableHttpClient closeableHttpClient = HttpClientBuilder.create().setDefaultRequestConfig(requestConfig)
                .setConnectionManager(connectionManager)
                .build();
        return closeableHttpClient;
    }
}
```

- DeviceMapFunction

```
package net.xdclass.func;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import net.xdclass.model.DeviceInfoDO;
import net.xdclass.model.ShortLinkWideDO;
import net.xdclass.util.DeviceUtil;
import org.apache.flink.api.common.functions.MapFunction;

/**
 * @author 刘森飚
 * @since 2023-02-16
 */


public class DeviceMapFunction implements MapFunction<String, ShortLinkWideDO> {

    @Override
    public ShortLinkWideDO map(String value) throws Exception {
        //还原json
        JSONObject jsonObject = JSON.parseObject(value);
        String userAgent = jsonObject.getJSONObject("data").getString("user-agent");
        DeviceInfoDO deviceInfoDO = DeviceUtil.getDeviceInfo(userAgent);
        String udid = jsonObject.getString("udid");
        deviceInfoDO.setUdid(udid);
        //配置短链基本信息宽表
        ShortLinkWideDO shortLinkWideDO = ShortLinkWideDO.builder()
                //短链访问基本信息
                .visitTime(jsonObject.getLong("ts"))
                .accountNo(jsonObject.getJSONObject("data").getLong("accountNo"))
                .code(jsonObject.getString("bizId"))
                .referer(jsonObject.getString("referer"))
                .isNew(jsonObject.getInteger("is_new"))
                .ip(jsonObject.getString("ip"))

                //设备信息补齐
                .browserName(deviceInfoDO.getBrowserName())
                .os(deviceInfoDO.getOs())
                .osVersion(deviceInfoDO.getOsVersion())
                .deviceType(deviceInfoDO.getDeviceType())
                .deviceManufacturer(deviceInfoDO.getDeviceManufacturer())
                .udid(deviceInfoDO.getUdid())
                .build();
        return shortLinkWideDO;
    }
}
```

###### 18.6.1.2.6DWN层编写

- DwmShortLinWideApp

```
package net.xdclass.dwm;

import net.xdclass.func.DeviceMapFunction;
import net.xdclass.func.LocationMapFunction;
import net.xdclass.model.ShortLinkWideDO;
import net.xdclass.util.KafkaUtil;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;

/**
 * @author 刘森飚
 * @since 2023-02-16
 */


public class DwmShortLinWideApp {

    /**
     * 定义source topic
     */
    public static final String SOURCE_TOPIC = "dwd_link_visit_topic";

    /**
     * 定义消费者组
     */
    public static final String GROUP_ID = "dwm_short_link_group";


    /**
     * 定义输出
     */
    public static final String SINK_TOPIC = "dwm_link_visit_topic";


    public static void main(String [] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        //DataStream<String> ds =  env.socketTextStream("127.0.0.1",8888);
        // 1、获取流
        FlinkKafkaConsumer<String> kafkaConsumer = KafkaUtil.getKafkaConsumer(SOURCE_TOPIC, GROUP_ID);
        DataStreamSource<String> ds = env.addSource(kafkaConsumer);

        //2、格式装换，补齐设备信息
        SingleOutputStreamOperator<ShortLinkWideDO> deviceWideDS = ds.map(new DeviceMapFunction());
        deviceWideDS.print("设备信息宽表补齐");

        //3、补齐地理位置信息
        SingleOutputStreamOperator<String> shortLinkWideDS  = deviceWideDS.map(new LocationMapFunction());
        shortLinkWideDS.print("地理位置信息宽表补齐");
        FlinkKafkaProducer<String> kafkaProducer = KafkaUtil.getKafkaProducer(SINK_TOPIC);

        //4、将sink写到dwm层，kafka存储
        shortLinkWideDS.addSink(kafkaProducer);
        env.execute();
    }
}
```

###### 18.6.1.2.7Flink异步IO使用步骤

- 文档

```
https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/asyncio/
```

- 使用步骤

```
An implementation of AsyncFunction that dispatchesthe requests
实现接口 AsyncFunction 用于请求分发

A callback that takes the result of the operationand hands it to the ResultFuture
定义⼀个callback回调函数，该函数用于取出异步请求的返回结果，并将返回的结果传递给ResultFuture

Applying the async I/O operation on a DataStreamas a transformation
对DataStream的数据使用Async操作
```

- 例子

```
// This example implements the asynchronous request and callback with Futures that have the
// interface of Java 8's futures (which is the same one followed by Flink's Future)

/**
 * An implementation of the 'AsyncFunction' that sends requests and sets the callback.
 */
class AsyncDatabaseRequest extends RichAsyncFunction<String, Tuple2<String, String>> {

    /** The database specific client that can issue concurrent requests with callbacks */
    private transient DatabaseClient client;

    @Override
    public void open(Configuration parameters) throws Exception {
        client = new DatabaseClient(host, post, credentials);
    }

    @Override
    public void close() throws Exception {
        client.close();
    }

    @Override
    public void asyncInvoke(String key, final ResultFuture<Tuple2<String, String>> resultFuture) throws Exception {

        // issue the asynchronous request, receive a future for result
        final Future<String> result = client.query(key);

        // set the callback to be executed once the request by the client is complete
        // the callback simply forwards the result to the result future
        CompletableFuture.supplyAsync(new Supplier<String>() {

            @Override
            public String get() {
                try {
                    return result.get();
                } catch (InterruptedException | ExecutionException e) {
                    // Normally handled explicitly.
                    return null;
                }
            }
        }).thenAccept( (String dbResult) -> {
            resultFuture.complete(Collections.singleton(new Tuple2<>(key, dbResult)));
        });
    }
}

// create the original stream
DataStream<String> stream = ...;

// apply the async I/O transformation
DataStream<Tuple2<String, String>> resultStream =
    AsyncDataStream.unorderedWait(stream, new AsyncDatabaseRequest(), 1000, TimeUnit.MILLISECONDS, 100);
```

- 注意事项

```
Timeout：定义请求超时时间，异步请求多久没完成会被认为是超时了
Capacity：定义了同时进⾏的异步请求的数量，可以限制并发请求数量，不会积压过多的请求
超时处理：默认当⼀个异步 I/O 请求超时时，会引发异常并重新启动作业。 如果要处理超时，可以覆盖该AsyncFunction的timeout方法来自定义超时之后的处理方式

响应结果的顺序：AsyncDataStream包含两种输出模式
unorderedWait无序：响应结果的顺序与异步请求的顺序不同。
orderedWait有序：响应结果的顺序与异步请求的顺序相同。
```

###### 18.6.1.2.8Flink异步IO优化IP地理位置

- asyncInvoke方法两种方式实现异步

```
ExecutorService线程池
HTTP异步客户端
```

- 引入异步http客户端

```
<!--异步http客户端-->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpasyncclient</artifactId>
    <version>4.1.5</version>
</dependency>
```

- AsyncLocaltionRequestFunction

```
package net.xdclass.func;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import net.xdclass.model.ShortLinkWideDO;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.async.ResultFuture;
import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;
import org.apache.http.impl.nio.client.HttpAsyncClients;
import org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager;
import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;
import org.apache.http.nio.reactor.ConnectingIOReactor;
import org.apache.http.nio.reactor.IOReactorException;
import org.apache.http.util.EntityUtils;

import java.io.IOException;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * @author 刘森飚
 * @since 2023-02-16
 */

@Slf4j
public class AsyncLocaltionRequestFunction extends RichAsyncFunction<ShortLinkWideDO,String> {

    private static final String IP_PARSE_URL =
            "https://restapi.amap.com/v3/ip?ip=%s&output=json&key=5a7de5d119a47da428dfe7cc26d550d7";

    private CloseableHttpAsyncClient httpAsyncClient;


    /**
     * 超时处理
     * @param input
     * @param resultFuture
     * @throws Exception
     */
    @Override
    public void timeout(ShortLinkWideDO input, ResultFuture<String> resultFuture) throws Exception {
        resultFuture.complete(Collections.singleton(null));
    }



    /**
     * 初始化异步客户端
     * @param parameters
     * @throws Exception
     */
    @Override
    public void open(Configuration parameters) throws Exception {
        this.httpAsyncClient = createAsyncHttpClient();
    }


    /**
     * 关闭异步客户端
     * @throws Exception
     */
    @Override
    public void close() throws Exception {
        if(httpAsyncClient!=null){
            httpAsyncClient.close();
        }
    }


    /**
     * 异步解析地理信息
     * @param shortLinkWideDO
     * @param resultFuture
     * @throws Exception
     */
    @Override
    public void asyncInvoke(ShortLinkWideDO shortLinkWideDO, ResultFuture<String> resultFuture) throws Exception {
        String ip = shortLinkWideDO.getIp();
        String url = String.format(IP_PARSE_URL,ip);
        HttpGet httpGet = new HttpGet(url);
        Future<HttpResponse> future = httpAsyncClient.execute(httpGet, null);
        CompletableFuture<ShortLinkWideDO> completableFuture = CompletableFuture.
                supplyAsync(new Supplier<ShortLinkWideDO>() {
            @Override
            public ShortLinkWideDO get() {
                try {
                    HttpResponse response = future.get();
                    int statusCode = response.getStatusLine().getStatusCode();
                    if (statusCode == HttpStatus.SC_OK) {
                        HttpEntity entity = response.getEntity();
                        String result = EntityUtils.toString(entity, "UTF-8");
                        JSONObject locationObj = JSON.parseObject(result);
                        String city = locationObj.getString("city");
                        String province = locationObj.getString("province");
                        shortLinkWideDO.setProvince(province);
                        shortLinkWideDO.setCity(city);
                        return shortLinkWideDO;
                    }
                } catch (InterruptedException | ExecutionException | IOException e) {
                    log.error("ip解析错误,value={},msg={}", shortLinkWideDO, e.getMessage());
                }
                shortLinkWideDO.setProvince("-");
                shortLinkWideDO.setCity("-");
                return shortLinkWideDO;
            }
        });
        completableFuture.thenAccept(new Consumer<ShortLinkWideDO>() {
            @Override
            public void accept(ShortLinkWideDO shortLinkWideDO) {
                resultFuture.complete(Collections.singleton(JSON.toJSONString(shortLinkWideDO)));
            }
        });
    }



    /**
     * 创建异步客户端
     * @return
     */
    private CloseableHttpAsyncClient createAsyncHttpClient() {
        try {
            RequestConfig requestConfig = RequestConfig.custom()
                    //返回数据的超时时间
                    .setSocketTimeout(20000)
                    //连接上服务器的超时时间
                    .setConnectTimeout(10000)
                    //从连接池中获取连接的超时时间
                    .setConnectionRequestTimeout(1000)
                    .build();
            ConnectingIOReactor ioReactor = new DefaultConnectingIOReactor();
            PoolingNHttpClientConnectionManager connManager = new PoolingNHttpClientConnectionManager(ioReactor);
            //设置连接池最大是500个连接
            connManager.setMaxTotal(500);
            //MaxPerRoute是对maxtotal的细分，每个主机的并发最大是300，route是指域名
            connManager.setDefaultMaxPerRoute(300);
            CloseableHttpAsyncClient httpClient = HttpAsyncClients.custom().setConnectionManager(connManager)
                    .setDefaultRequestConfig(requestConfig)
                    .build();
            httpClient.start();
            return httpClient;
        } catch (IOReactorException e) {
            log.error("初始化 CloseableHttpAsyncClient异常:{}",e.getMessage());
            return null;
        }
    }
}
```

- DwmShortLinWideApp

```
package net.xdclass.dwm;

import net.xdclass.func.AsyncLocaltionRequestFunction;
import net.xdclass.func.DeviceMapFunction;
import net.xdclass.func.LocationMapFunction;
import net.xdclass.model.ShortLinkWideDO;
import net.xdclass.util.KafkaUtil;
import org.apache.flink.streaming.api.datastream.AsyncDataStream;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;

import java.util.concurrent.TimeUnit;

/**
 * @author 刘森飚
 * @since 2023-02-16
 */


public class DwmShortLinWideApp {

    /**
     * 定义source topic
     */
    public static final String SOURCE_TOPIC = "dwd_link_visit_topic";

    /**
     * 定义消费者组
     */
    public static final String GROUP_ID = "dwm_short_link_group";


    /**
     * 定义输出
     */
    public static final String SINK_TOPIC = "dwm_link_visit_topic";


    public static void main(String [] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        DataStream<String> ds =  env.socketTextStream("10.0.0.67",8888);
        // 1、获取流
        //FlinkKafkaConsumer<String> kafkaConsumer = KafkaUtil.getKafkaConsumer(SOURCE_TOPIC, GROUP_ID);
        //DataStreamSource<String> ds = env.addSource(kafkaConsumer);

        //2、格式装换，补齐设备信息
        SingleOutputStreamOperator<ShortLinkWideDO> deviceWideDS = ds.map(new DeviceMapFunction());
        deviceWideDS.print("设备信息宽表补齐");

        //3、补齐地理位置信息
        //此处添加代码
        SingleOutputStreamOperator<String> shortLinkWideDS = AsyncDataStream.unorderedWait
                (deviceWideDS, new AsyncLocaltionRequestFunction(), 1000, TimeUnit.MILLISECONDS, 200);

        shortLinkWideDS.print("地理位置信息宽表补齐");
        FlinkKafkaProducer<String> kafkaProducer = KafkaUtil.getKafkaProducer(SINK_TOPIC);

        //4、将sink写到dwm层，kafka存储
        shortLinkWideDS.addSink(kafkaProducer);
        env.execute();
    }
}
```

###### 18.6.1.2.9测试地理位置解析

- 测试数据

```
{"ip":"223.107.195.118","ts":1676371826607,"event":"SHORT_LINK_TYPE","udid":null,"bizId":"01U7PXo0","data":{"referer":null,"accountNo":"830033392337682432","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"}}
```

- 测试结果

```
设备信息宽表补齐> ShortLinkWideDO(code=01U7PXo0, accountNo=830033392337682432, visitTime=1676371826607, referer=null, isNew=null, browserName=Chrome, os=Windows, osVersion= Win64, deviceType=COMPUTER, deviceManufacturer=MICROSOFT, udid=null, country=null, province=null, city=null, isp=null, ip=223.107.195.118)


地理位置信息宽表补齐> {"accountNo":830033392337682432,"browserName":"Chrome","city":"泰州市","code":"01U7PXo0","deviceManufacturer":"MICROSOFT","deviceType":"COMPUTER","ip":"223.107.195.118","os":"Windows","osVersion":" Win64","province":"江苏省","visitTime":1676371826607}
```

![1676533972032](短链平台项目.assets/1676533972032.png)

#### 18.6.2数据可视化ADS层

##### 18.6.2.1微服务整合ClickHouse

- 需求

```
根据web可视化报表统计需求，从ClickHouse聚合统计
技术框架选择：SpringBoot + MybatisPlus +ClickHouse +Idea
```

###### 18.6.2.1.1添加项目pom依赖

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>dcloud-short-link</artifactId>
        <groupId>net.xdclass</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>dcloud-data</artifactId>


    <dependencies>
        <dependency>
            <groupId>ru.yandex.clickhouse</groupId>
            <artifactId>clickhouse-jdbc</artifactId>
            <version>0.1.55</version>
        </dependency>

        <dependency>
            <groupId>net.xdclass</groupId>
            <artifactId>dcloud-common</artifactId>
            <version>1.0-SNAPSHOT</version>
            <exclusions>
                <exclusion>
                    <groupId>org.apache.shardingsphere</groupId>
                    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

    </dependencies>


</project>
```

###### 18.6.2.1.2添加配置文件

- application.properties

```
server.port=8002
spring.application.name=dcloud-data-service

#----------服务注册和发现--------------
spring.cloud.nacos.discovery.server-addr=182.92.119.206:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos

spring.datasource.driver-class-name=ru.yandex.clickhouse.ClickHouseDriver

spring.datasource.url=jdbc:clickhouse://182.92.119.206:8123/default

mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

logging.level.root=INFO


#-------redis连接配置-------
spring.redis.client-type=jedis
spring.redis.host=123.57.69.236
spring.redis.password=Liu19971009
spring.redis.port=6379
spring.redis.jedis.pool.max-active=100
spring.redis.jedis.pool.max-idle=100
spring.redis.jedis.pool.min-idle=100
spring.redis.jedis.pool.max-wait=60000
```

###### 18.6.2.1.3开发启动类

```
package net.xdclass;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.transaction.annotation.EnableTransactionManagement;

/**
 * @author 刘森飚
 * @since 2023-02-19
 */

@SpringBootApplication
@EnableTransactionManagement
@MapperScan("net.xdclass.mapper")
@EnableFeignClients
@EnableDiscoveryClient
public class DataApplication {

    public static void main(String [] args){
        SpringApplication.run(DataApplication.class,args);
    }

}
```

###### 18.6.2.1.4开发拦截器

```
package net.xdclass.config;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @author 刘森飚
 * @since 2023-02-13
 */

@Configuration
@Slf4j
public class InterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(new LoginInterceptor())
                //添加拦截的路径
                .addPathPatterns("/api/visit_stats/*/**");

                //排除不拦截
                //.excludePathPatterns("/api/product/*/**");
    }
}
```

##### 18.6.2.2AlibabaCloud整合ClickHouse

###### 18.6.2.2.1新增类 VisitStatsDO

```
package net.xdclass.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author 刘森飚
 * @since 2023-02-19
 */


@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class VisitStatsDO {

    /**
     * 窗口开始时间  Clickhouse里面会用到
     */
    String startTime;

    /**
     * 窗口结束时间
     */
    String endTime;

/**
 * ================================================
 */


    /**
     * 短链压缩码
     */
    private String code;

    /**
     * 租户id
     */
    private Long accountNo;


    /**
     * 访问时间
     */
    private Long visitTime;

    /**
     * 站点来源，只记录域名
     */
    private String referer;

    /**
     * 1是新访客，0是老访客
     */
    private Integer isNew;

    /**
     * 唯一标识
     */
    private String udid;

    //==============RegionInfoDO==================

    /**
     * 省份
     */
    private String province;

    /**
     * 城市
     */
    private String city;

    /**
     * 运营商
     */
    private String isp;

    /**
     * 访问ip
     */
    private String ip;

//==============DeviceInfoDO==================

    /**
     * 浏览器名称
     */
    private String browserName;

    /**
     * 操作系统
     */
    private String os;

    /**
     * 系统版本
     */
    private String osVersion;

    /**
     * 设备类型
     */
    private String deviceType;

    /**
     * 设备厂商
     */
    private String deviceManufacturer;

//==============度量==================

    private Long uv=0L;

    private Long pv=0L;



    private Long ipCount=0L;

    private Long newUVCount=0L;

    /**
     * 时间的字符串映射，天、小时*/

    private String dateTimeStr;
}
```

###### 18.6.2.2.2mapper层开发

```
package net.xdclass.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import net.xdclass.model.VisitStatsDO;
import org.apache.ibatis.annotations.Param;

import java.util.List;


/**
 * @author 刘森飚
 * @since 2023-01-19
 */


public interface VisitStatsMapper extends BaseMapper<VisitStatsDO> {


    /**
     * 分页查询
     * @param code
     * @param accountNo
     * @param from
     * @param size
     * @return
     */
    List<VisitStatsDO> pageVisitRecord(@Param("code") String code, @Param("accountNo") Long accountNo,
                                       @Param("from") int from, @Param("size") int size);

    /**
     * 计算总条数
     * @param code
     * @param accountNo
     * @return
     */
    int countTotal(@Param("code") String code, @Param("accountNo") Long accountNo);
}
```

- VisitStatsMapper.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="net.xdclass.mapper.VisitStatsMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="net.xdclass.model.VisitStatsDO">
        <result column="code" property="code"/>
        <result column="referer" property="referer"/>
        <result column="is_new" property="isNew"/>
        <result column="account_no" property="accountNo"/>
        <result column="ts" property="visitTime"/>

        <result column="province" property="province"/>
        <result column="city" property="city"/>
        <result column="ip" property="ip"/>

        <result column="browser_name" property="browserName"/>
        <result column="os" property="os"/>
        <result column="device_type" property="deviceType"/>

        <result column="start_time" property="startTime"/>
        <result column="uv_count" property="uvCount"/>
        <result column="pv_count" property="pvCount"/>

        <result column="ip_count" property="ipCount"/>
        <result column="new_uv_count" property="newUVCount"/>
        <result column="date_time_str" property="dateTimeStr"/>

    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
       code,referer,ts,is_new,account_no,province,city,ip,browser_name,os,device_type,start_time
    </sql>


    <!--统计总条数-->
    <select id="countTotal" resultType="java.lang.Integer">
        select count(1) from visit_stats  where  account_no=#{accountNo} and code=#{code} limit 1000
    </select>


    <!--分页查找-->
    <select id="pageVisitRecord" resultMap="BaseResultMap">
        select
        <include refid="Base_Column_List"/>
        from visit_stats where account_no=#{accountNo} and code=#{code}
        order by ts desc limit #{from},#{size}
    </select>

</mapper>
```

###### 18.6.2.2.3controller层开发

```
package net.xdclass.controller;

import net.xdclass.controller.request.VisitRecordPageRequest;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.service.VisitStatsService;
import net.xdclass.util.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-19
 */

@RestController
@RequestMapping("/api/visit_stats/v1")
public class VisitStatsController {

    @Autowired
    private VisitStatsService statsService;


    @RequestMapping("page_record")
    public JsonData pageVisitRecord(@RequestBody VisitRecordPageRequest request){

        //条数限制
        int total = request.getSize() * request.getPage();
        if(total > 1000) {
            return JsonData.buildResult(BizCodeEnum.DATA_OUT_OF_LIMIT_SIZE);
        }
        Map<String,Object> pageResult = statsService.pageVisitRecord(request);
        return JsonData.buildSuccess(pageResult);
    }
}
```

###### 18.6.2.2.4service层开发

- VisitStatsService

```
package net.xdclass.service;

import net.xdclass.controller.request.VisitRecordPageRequest;

import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-19
 */


public interface VisitStatsService {

    /**
     * 访问记录分页
     * @param request
     * @return
     */
    Map<String,Object> pageVisitRecord(VisitRecordPageRequest request);
}
```

- VisitStatsServiceImpl

```
package net.xdclass.service.impl;

import net.xdclass.controller.request.VisitRecordPageRequest;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.mapper.VisitStatsMapper;
import net.xdclass.model.VisitStatsDO;
import net.xdclass.service.VisitStatsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-01-19
 */

@Service
public class VisitStatsServiceImpl implements VisitStatsService {

    @Autowired
    private VisitStatsMapper visitStatsMapper;



    /**
     * 访问记录分页
     * @param request
     * @return
     */
    @Override
    public Map<String, Object> pageVisitRecord(VisitRecordPageRequest request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        Map<String, Object> data = new HashMap<>(16);
        String code = request.getCode();
        int page = request.getPage();
        int size = request.getSize();
        int count = visitStatsMapper.countTotal(code, accountNo);
        int from = (page - 1) * size;
        List<VisitStatsDO> list = visitStatsMapper.pageVisitRecord(code, accountNo, from, size);
        data.put("total", count);
        data.put("current_page", page);

        /**计算总页数*/
        int totalPage = 0;
        if (count % size == 0) {
            totalPage = count / size;
        } else {
            totalPage = count / size + 1;
        }
        data.put("total_page", totalPage);
        data.put("data", list);
        return data;
    }
}
```

##### 18.6.2.3时间范围内地区访问接口

###### 18.6.2.3.1需求案例

```
访问统计分布 地理位置信息图
UV统计是天UV，月UV是是累计，没做去重（百度统计也是未去重）
有些业务统计月UV会根据月去重，有些业务是不去重
如果需要做月去重，需要记录访问唯⼀标识udid

https://echarts.apache.org/v4/examples/zh/editor.html?c=effectScatter-bmap
```

![1676871651997](短链平台项目.assets/1676871651997.png)

- 页面需求

![1676871691800](短链平台项目.assets/1676871691800.png)

###### 18.6.2.3.2VisitStatsController

```
/**
 * 按天地区分布
 * @param request
 * @return
 */
@RequestMapping("region_day")
public JsonData queryRegionWithDay(@RequestBody RegionQueryRequest request){
    List<VisitStatsVO> list = statsService.queryRegionWithDay(request);
    return JsonData.buildSuccess(list);
}
```

###### 18.6.2.3.3VisitStatsServiceImpl

```
/**
 * 按天地区分布
 * @param request
 * @return
 */
@Override
public List<VisitStatsVO> queryRegionWithDay(RegionQueryRequest request) {
    Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
    List<VisitStatsDO> list = visitStatsMapper.queryRegionVisitStatsWithDay
            (request.getCode(), request.getStartTime(), request.getEndTime(), accountNo);
    List<VisitStatsVO> visitStatsVOS = list.stream().map(obj -> beanProcess(obj)).collect(Collectors.toList());
    return visitStatsVOS;
}



/**
 * 将Do类转换成Vo类
 * @param visitStatsDO
 * @return
 */
private VisitStatsVO beanProcess(VisitStatsDO visitStatsDO){
    VisitStatsVO visitStatsVO = new VisitStatsVO();
    BeanUtils.copyProperties(visitStatsDO,visitStatsVO);
    return visitStatsVO;
}
```

###### 18.6.2.3.4VisitStatsMapper.xml

```
/**
 * 根据时间范围查询地区访问分布
 * @param code
 * @param startTime
 * @param endTime
 * @param accountNo
 * @return
 */
List<VisitStatsDO> queryRegionVisitStatsWithDay(@Param("code") String code, @Param("startTime") String startTime,
                                                    @Param("endTime") String endTime, @Param("accountNo") Long accountNo);

                                                
                                                
                                                



    <!--时间范围内地区访问分布-城市级别，天级别-->
    <select id="queryRegionVisitStatsWithDay" resultMap="BaseResultMap">
        select province,city,sum(pv) pv_count, sum(uv) uv_count,count( DISTINCT ip) ip_count from visit_stats
        where  account_no=#{accountNo} and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime} and #{endTime}
        group by province,city order by pv_count desc
    </select>
```

##### 18.6.2.4天维度访问曲线图接口

###### 18.6.2.4.1需求案例

```
性能优化的点：别⼀次性查询或者展示太多数据，根据需求查询。
比如百度统计 UV、PV、IP数等，是点击才触发。
```

![1676874306931](短链平台项目.assets/1676874306931.png)

- 页面需求

![1676874339515](短链平台项目.assets/1676874339515.png)

###### 18.6.2.4.2VisitStatsController

```
/**
 * 访问趋势图
 * @param request
 * @return
 */
@RequestMapping("trend")
public JsonData queryVisitTrend(@RequestBody VisitTrendQueryRequest request){
    List<VisitStatsVO> list = statsService.queryVisitTrend(request);
    return JsonData.buildSuccess(list);
}
```

###### 18.6.2.4.3VisitStatsServiceImpl

```
/**
 * 访问趋势图
 * @param request
 * @return
 */
List<VisitStatsVO> queryVisitTrend(VisitTrendQueryRequest request);




 /**
     * 访问趋势图
     * @param request
     * @return
     */
    @Override
    public List<VisitStatsVO> queryVisitTrend(VisitTrendQueryRequest request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        String code = request.getCode();
        String type = request.getType();
        String startTime = request.getStartTime();
        String endTime = request.getEndTime();
        List<VisitStatsDO> list = null;
        if(DateTimeFieldEnum.DAY.name().equalsIgnoreCase(type)){
            list = visitStatsMapper.queryVisitTrendWithMultiDay(code,accountNo,startTime,endTime);
        }else if(DateTimeFieldEnum.HOUR.name().equalsIgnoreCase(type)){


        }else if(DateTimeFieldEnum.MIUNTE.name().equalsIgnoreCase(type)){

        }
        List<VisitStatsVO> visitStatsVOS = list.stream().map(obj ->
                beanProcess(obj)).collect(Collectors.toList());
        return visitStatsVOS;

    }
```

###### 18.6.2.4.4VisitStatsMapper.xml

```
/**
 * 查询时间范围内的访问趋势图
 * @param code
 * @param startTime
 * @param endTime
 * @param accountNo
 * @return
 */
List<VisitStatsDO> queryVisitTrendWithMultiDay(@Param("code") String code,
                                               @Param("accountNo") Long accountNo,
                                               @Param("startTime") String startTime,
                                               @Param("endTime") String endTime);
                                               




	<!-- 多天内的访问曲线图,天基本 -->
    <select id="queryVisitTrendWithMultiDay" resultMap="BaseResultMap">
        select toYYYYMMDD(start_time) date_time_str,sum(if(is_new='1', visit_stats.uv,0)) new_uv_count,
        sum(visit_stats.uv) uv_count, sum(pv) pv_count, count( DISTINCT ip) ip_count from visit_stats
        where account_no=#{accountNo} and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime}
        and #{endTime} group by date_time_str ORDER BY date_time_str desc
</select>
```

###### 18.6.2.4.5DateTimeFieldEnum

```
package net.xdclass.enums;

/**
 * @author 刘森飚
 * @since 2023-02-20
 */


public enum DateTimeFieldEnum {

    /**
     * 分钟
     */
    MIUNTE,

    /**
     * 小时
     */
    HOUR,

    /**
     * 天
     */
    DAY,

    /**
     * 星期
     */
    WEEK;

}
```

##### 18.6.2.5小时-分钟维度访问接口

###### 18.6.2.5.1需求案例

```
统计小时-分钟维度的接口
```

![1676882778013](短链平台项目.assets/1676882778013.png)

###### 18.6.2.5.2VisitStatsServiceImpl

```
/**
 * 访问趋势图
 * @param request
 * @return
 */
@Override
public List<VisitStatsVO> queryVisitTrend(VisitTrendQueryRequest request) {
    Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
    String code = request.getCode();
    String type = request.getType();
    String startTime = request.getStartTime();
    String endTime = request.getEndTime();
    List<VisitStatsDO> list = null;
    if(DateTimeFieldEnum.DAY.name().equalsIgnoreCase(type)){
        list = visitStatsMapper.queryVisitTrendWithMultiDay(code,accountNo,startTime,endTime);
    }else if(DateTimeFieldEnum.HOUR.name().equalsIgnoreCase(type)){
        list = visitStatsMapper.queryVisitTrendWithHour(code, accountNo, startTime);
    }else if(DateTimeFieldEnum.MINUTE.name().equalsIgnoreCase(type)){
        list = visitStatsMapper.queryVisitTrendWithMinute(code, accountNo, startTime, endTime);
    }
    List<VisitStatsVO> visitStatsVOS = list.stream().map(obj ->
            beanProcess(obj)).collect(Collectors.toList());
    return visitStatsVOS;

}
```

###### 18.6.2.5.3VisitStatsMapper.xml

```
/**
 * 查询时间范围内的访问趋势图 小时级别
 * @param code
 * @param accountNo
 * @param startTime
 * @param endTime
 * @return
 */
List<VisitStatsDO> queryVisitTrendWithHour(@Param("code") String code,
                                           @Param("accountNo") Long accountNo,
                                           @Param("startTime") String startTime);


/**
 * 查询时间范围内的访问趋势图 分钟级别
 * @param code
 * @param accountNo
 * @param startTime
 * @param endTime
 * @return
 */
List<VisitStatsDO> queryVisitTrendWithMinute(@Param("code") String code,
                                             @Param("accountNo") Long accountNo,
                                             @Param("startTime") String startTime,
                                             @Param("endTime") String endTime);
                                             




	<!-- 一天内的访问曲线图,小时 -->
    <select id="queryVisitTrendWithHour" resultMap="BaseResultMap">
        select toHour(start_time) date_time_str,sum(if(is_new='1', visit_stats.uv,0)) new_uv_count,
        sum(visit_stats.uv) uv_count, sum(pv) pv_count, count( DISTINCT ip) ip_count from visit_stats
        where  account_no=#{accountNo} and code=#{code} and toYYYYMMDD(start_time)=#{startTime}
        group by date_time_str ORDER BY date_time_str desc
    </select>




    <!-- 小时内的访问曲线图,每分钟，如果要每5分钟，则把 toMinute 改为 toStartOfFiveMinute -->
    <select id="queryVisitTrendWithMinute" resultMap="BaseResultMap">
        select toMinute(start_time) date_time_str,sum(if(is_new='1', visit_stats.uv,0)) new_uv_count,
        sum(visit_stats.uv) uv_count, sum(pv) pv_count, count( DISTINCT ip) ip_count from visit_stats
        where account_no=#{accountNo} and code=#{code} and toYYYYMMDDhhmmss(start_time) BETWEEN #{startTime}
        and #{endTime}
        group by date_time_str ORDER BY date_time_str desc
    </select>
```

##### 18.6.2.6Top10访问来源统计接口

###### 18.6.2.6.1需求案例

```
访问来源Top10统计开发
```

![1676883854557](短链平台项目.assets/1676883854557.png)

- 页面需求

![1676883889268](短链平台项目.assets/1676883889268.png)



###### 18.6.2.6.2VisitStatsController

```
/**
 * 高频rerere统计
 * @param request
 * @return
 */
@RequestMapping("frequent_source")
public JsonData queryFrequentSource(@RequestBody FrequentSourceRequset request){

    List<VisitStatsVO> list = statsService.queryFrequentSource(request);
    return JsonData.buildSuccess(list);
}
```

###### 18.6.2.6.3VisitStatsServiceImpl

```
/**
 * 高频rerere统计
 * @param request
 * @return
 */
List<VisitStatsVO> queryFrequentSource(FrequentSourceRequset request);


 
 
 
	/**
     * 高频rerere统计
     * @param request
     * @return
     */
    @Override
    public List<VisitStatsVO> queryFrequentSource(FrequentSourceRequset request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        String code = request.getCode();
        String startTime = request.getStartTime();
        String endTime = request.getEndTime();
        List<VisitStatsDO> list = visitStatsMapper.queryFrequentSource(code, accountNo, startTime, endTime, 10);
        List<VisitStatsVO> visitStatsVOS = list.stream().map
                (obj -> beanProcess(obj)).collect(Collectors.toList());
        return visitStatsVOS;
    }
```

###### 18.6.2.6.4VisitStatsMapper.xml

```
/**
 * 查询高频访问来源
 * @param code
 * @param accountNo
 * @param startTime
 * @param endTime
 * @param size
 * @return
 */
List<VisitStatsDO> queryFrequentSource(@Param("code") String code,
                                       @Param("accountNo") Long accountNo,
                                       @Param("startTime") String startTime,
                                       @Param("endTime") String endTime,
                                       @Param("size") int size);





    <!--高频referer查询 访问来源-->
    <select id="queryFrequentSource" resultMap="BaseResultMap">
    select referer,sum(pv) pv_count from visit_stats where
    account_no=#{accountNo} and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime} and #{endTime}
    group by referer order by pv_count desc limit #{size}
    </select>
```

##### 18.6.2.7设备终端访问分布接口(所有接口完结)

###### 18.6.2.7.1需求案例

```
统计设备访问分布情况
```

![1676895898932](短链平台项目.assets/1676895898932.png)

###### 18.6.2.7.2Controller层

- VisitStatsController

```
package net.xdclass.controller;

import net.xdclass.controller.request.*;
import net.xdclass.enums.BizCodeEnum;
import net.xdclass.service.VisitStatsService;
import net.xdclass.util.JsonData;
import net.xdclass.vo.VisitStatsVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-19
 */

@RestController
@RequestMapping("/api/visit_stats/v1")
public class VisitStatsController {

    @Autowired
    private VisitStatsService statsService;


    /**
     *  访问记录分页
     * @param request
     * @return
     */
    @RequestMapping("page_record")
    public JsonData pageVisitRecord(@RequestBody VisitRecordPageRequest request){
        //条数限制
        int total = request.getSize() * request.getPage();
        if(total > 1000) {
            return JsonData.buildResult(BizCodeEnum.DATA_OUT_OF_LIMIT_SIZE);
        }
        Map<String,Object> pageResult = statsService.pageVisitRecord(request);
        return JsonData.buildSuccess(pageResult);
    }




    /**
     * 查询时间范围内的，地区访问分布
     * @param request
     * @return
     */
    @RequestMapping("region_day")
    public JsonData queryRegionWithDay(@RequestBody RegionQueryRequest request){
        List<VisitStatsVO> list = statsService.queryRegionWithDay(request);
        return JsonData.buildSuccess(list);
    }



    /**
     * 访问趋势图
     * @param request
     * @return
     */
    @RequestMapping("trend")
    public JsonData queryVisitTrend(@RequestBody VisitTrendQueryRequest request){
        List<VisitStatsVO> list = statsService.queryVisitTrend(request);
        return JsonData.buildSuccess(list);
    }



    /**
     * 高频rerere统计
     * @param request
     * @return
     */
    @RequestMapping("frequent_source")
    public JsonData queryFrequentSource(@RequestBody FrequentSourceRequset request){

        List<VisitStatsVO> list = statsService.queryFrequentSource(request);
        return JsonData.buildSuccess(list);
    }



    
    //这一行添加代码
    /**
     * 查询设备访问分布情况
     * @param request
     * @return
     */
    @RequestMapping("device_info")
    public JsonData queryDeviceInfo(@RequestBody QueryDeviceRequest request){

        Map<String,List<VisitStatsVO>> map = statsService.queryDeviceInfo(request);
        return JsonData.buildSuccess(map);
    }
}
```

###### 18.6.2.7.3service层

- VisitStatsService

```
package net.xdclass.service;

import net.xdclass.controller.request.*;
import net.xdclass.vo.VisitStatsVO;

import java.util.List;
import java.util.Map;

/**
 * @author 刘森飚
 * @since 2023-02-19
 */


public interface VisitStatsService {

    /**
     * 访问记录分页
     * @param request
     * @return
     */
    Map<String,Object> pageVisitRecord(VisitRecordPageRequest request);


    /**
     * 查询时间范围内的，地区访问分布
     * @param request
     * @return
     */
    List<VisitStatsVO> queryRegionWithDay(RegionQueryRequest request);


    /**
     * 访问趋势图
     * @param request
     * @return
     */
    List<VisitStatsVO> queryVisitTrend(VisitTrendQueryRequest request);


    /**
     * 高频rerere统计
     * @param request
     * @return
     */
    List<VisitStatsVO> queryFrequentSource(FrequentSourceRequset request);


    /**
     * 查询设备访问分布情况
     * @param request
     * @return
     */
    Map<String,List<VisitStatsVO>> queryDeviceInfo(QueryDeviceRequest request);
}
```

- VisitStatsServiceImpl

```
package net.xdclass.service.impl;

import net.xdclass.controller.request.*;
import net.xdclass.enums.DateTimeFieldEnum;
import net.xdclass.enums.QueryDeviceEnum;
import net.xdclass.interceptor.LoginInterceptor;
import net.xdclass.mapper.VisitStatsMapper;
import net.xdclass.model.VisitStatsDO;
import net.xdclass.service.VisitStatsService;
import net.xdclass.vo.VisitStatsVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @author 刘森飚
 * @since 2023-02-19
 */

@Service
public class VisitStatsServiceImpl implements VisitStatsService {

    @Autowired
    private VisitStatsMapper visitStatsMapper;



    /**
     * 访问记录分页
     * @param request
     * @return
     */
    @Override
    public Map<String, Object> pageVisitRecord(VisitRecordPageRequest request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        Map<String, Object> data = new HashMap<>(16);
        String code = request.getCode();
        int page = request.getPage();
        int size = request.getSize();
        int count = visitStatsMapper.countTotal(code, accountNo);
        int from = (page - 1) * size;
        List<VisitStatsDO> list = visitStatsMapper.pageVisitRecord(code, accountNo, from, size);
        data.put("total", count);
        data.put("current_page", page);

        /**计算总页数*/
        int totalPage = 0;
        if (count % size == 0) {
            totalPage = count / size;
        } else {
            totalPage = count / size + 1;
        }
        data.put("total_page", totalPage);
        data.put("data", list);
        return data;
    }


    /**
     * 查询时间范围内的，地区访问分布
     * @param request
     * @return
     */
    @Override
    public List<VisitStatsVO> queryRegionWithDay(RegionQueryRequest request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        List<VisitStatsDO> list = visitStatsMapper.queryRegionVisitStatsWithDay
                (request.getCode(),accountNo,request.getStartTime(), request.getEndTime());
        List<VisitStatsVO> visitStatsVOS = list.stream().map(obj -> beanProcess(obj)).collect(Collectors.toList());
        return visitStatsVOS;
    }



    /**
     * 访问趋势图
     * @param request
     * @return
     */
    @Override
    public List<VisitStatsVO> queryVisitTrend(VisitTrendQueryRequest request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        String code = request.getCode();
        String type = request.getType();
        String startTime = request.getStartTime();
        String endTime = request.getEndTime();
        List<VisitStatsDO> list = null;
        if(DateTimeFieldEnum.DAY.name().equalsIgnoreCase(type)){
            list = visitStatsMapper.queryVisitTrendWithMultiDay(code,accountNo,startTime,endTime);
        }else if(DateTimeFieldEnum.HOUR.name().equalsIgnoreCase(type)){
            list = visitStatsMapper.queryVisitTrendWithHour(code, accountNo, startTime);
        }else if(DateTimeFieldEnum.MINUTE.name().equalsIgnoreCase(type)){
            list = visitStatsMapper.queryVisitTrendWithMinute(code, accountNo, startTime, endTime);
        }
        List<VisitStatsVO> visitStatsVOS = list.stream().map(obj ->
                beanProcess(obj)).collect(Collectors.toList());
        return visitStatsVOS;

    }




    /**
     * 高频rerere统计
     * @param request
     * @return
     */
    @Override
    public List<VisitStatsVO> queryFrequentSource(FrequentSourceRequset request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        String code = request.getCode();
        String startTime = request.getStartTime();
        String endTime = request.getEndTime();
        List<VisitStatsDO> list = visitStatsMapper.queryFrequentSource(code, accountNo, startTime, endTime, 10);
        List<VisitStatsVO> visitStatsVOS = list.stream().map
                (obj -> beanProcess(obj)).collect(Collectors.toList());
        return visitStatsVOS;
    }



    /**
     * 查询设备访问分布情况
     * @param request
     * @return
     */
    @Override
    public Map<String, List<VisitStatsVO>> queryDeviceInfo(QueryDeviceRequest request) {
        Long accountNo = LoginInterceptor.threadLocal.get().getAccountNo();
        String code = request.getCode();
        String startTime = request.getStartTime();
        String endTime = request.getEndTime();
        String os = QueryDeviceEnum.OS.name().toLowerCase();
        String browser = QueryDeviceEnum.BROWSER.name().toLowerCase();
        String device = QueryDeviceEnum.DEVICE.name().toLowerCase();
        List<VisitStatsDO> osList = visitStatsMapper.queryDeviceInfo(code, accountNo, startTime, endTime, os);
        List<VisitStatsDO> browserList = visitStatsMapper.queryDeviceInfo(code, accountNo, startTime, endTime, browser);
        List<VisitStatsDO> deviceList = visitStatsMapper.queryDeviceInfo(code, accountNo, startTime, endTime, device);
        List<VisitStatsVO> osVisitStatsVOS = osList.stream().map
                (obj -> beanProcess(obj)).collect(Collectors.toList());
        List<VisitStatsVO> browserVisitStatsVOS = browserList.stream().
                map(obj -> beanProcess(obj)).collect(Collectors.toList());
        List<VisitStatsVO> deviceVisitStatsVOS = deviceList.stream().map
                (obj -> beanProcess(obj)).collect(Collectors.toList());
        Map<String, List<VisitStatsVO>> map = new HashMap<>(3);
        map.put("os", osVisitStatsVOS);
        map.put("browser", browserVisitStatsVOS);
        map.put("device", deviceVisitStatsVOS);
        return map;
    }




    /**
     * 将Do类转换成Vo类
     * @param visitStatsDO
     * @return
     */
    private VisitStatsVO beanProcess(VisitStatsDO visitStatsDO){
        VisitStatsVO visitStatsVO = new VisitStatsVO();
        BeanUtils.copyProperties(visitStatsDO,visitStatsVO);
        return visitStatsVO;
    }
}
```

###### 18.6.2.7.4mapper层

- VisitStatsMapper

```
package net.xdclass.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import net.xdclass.model.VisitStatsDO;
import org.apache.ibatis.annotations.Param;

import java.util.List;


/**
 * @author 刘森飚
 * @since 2023-02-19
 */


public interface VisitStatsMapper extends BaseMapper<VisitStatsDO> {


    /**
     * 分页查询
     * @param code
     * @param accountNo
     * @param from
     * @param size
     * @return
     */
    List<VisitStatsDO> pageVisitRecord(@Param("code") String code, @Param("accountNo") Long accountNo,
                                       @Param("from") int from, @Param("size") int size);

    /**
     * 计算总条数
     * @param code
     * @param accountNo
     * @return
     */
    int countTotal(@Param("code") String code, @Param("accountNo") Long accountNo);


    /**
     * 根据时间范围查询地区访问分布
     * @param code
     * @param startTime
     * @param endTime
     * @param accountNo
     * @return
     */
    List<VisitStatsDO> queryRegionVisitStatsWithDay(@Param("code") String code,
                                                    @Param("accountNo") Long accountNo,
                                                    @Param("startTime") String startTime,
                                                    @Param("endTime") String endTime);


    /**
     * 查询时间范围内的访问趋势图
     * @param code
     * @param startTime
     * @param endTime
     * @param accountNo
     * @return
     */
    List<VisitStatsDO> queryVisitTrendWithMultiDay(@Param("code") String code,
                                                   @Param("accountNo") Long accountNo,
                                                   @Param("startTime") String startTime,
                                                   @Param("endTime") String endTime);



    /**
     * 查询时间范围内的访问趋势图 小时级别
     * @param code
     * @param accountNo
     * @param startTime
     * @param endTime
     * @return
     */
    List<VisitStatsDO> queryVisitTrendWithHour(@Param("code") String code,
                                               @Param("accountNo") Long accountNo,
                                               @Param("startTime") String startTime);


    /**
     * 查询时间范围内的访问趋势图 分钟级别
     * @param code
     * @param accountNo
     * @param startTime
     * @param endTime
     * @return
     */
    List<VisitStatsDO> queryVisitTrendWithMinute(@Param("code") String code,
                                                 @Param("accountNo") Long accountNo,
                                                 @Param("startTime") String startTime,
                                                 @Param("endTime") String endTime);



    /**
     * 查询高频访问来源
     * @param code
     * @param accountNo
     * @param startTime
     * @param endTime
     * @param size
     * @return
     */
    List<VisitStatsDO> queryFrequentSource(@Param("code") String code,
                                           @Param("accountNo") Long accountNo,
                                           @Param("startTime") String startTime,
                                           @Param("endTime") String endTime,
                                           @Param("size") int size);


    /**
     * 查询设备类型
     * @param code
     * @param accountNo
     * @param startTime
     * @param endTime
     * @param field
     * @return
     */
    List<VisitStatsDO> queryDeviceInfo(@Param("code") String code,
                                       @Param("accountNo") Long accountNo,
                                       @Param("startTime") String startTime,
                                       @Param("endTime") String endTime,
                                       @Param("field") String field);
}
```

- VisitStatsMapper.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="net.xdclass.mapper.VisitStatsMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="net.xdclass.model.VisitStatsDO">
        <result column="code" property="code"/>
        <result column="referer" property="referer"/>
        <result column="is_new" property="isNew"/>
        <result column="account_no" property="accountNo"/>
        <result column="ts" property="visitTime"/>

        <result column="province" property="province"/>
        <result column="city" property="city"/>
        <result column="ip" property="ip"/>

        <result column="browser_name" property="browserName"/>
        <result column="os" property="os"/>
        <result column="device_type" property="deviceType"/>

        <result column="start_time" property="startTime"/>
        <result column="uv_count" property="uvCount"/>
        <result column="pv_count" property="pvCount"/>

        <result column="ip_count" property="ipCount"/>
        <result column="new_uv_count" property="newUVCount"/>
        <result column="date_time_str" property="dateTimeStr"/>

    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
       code,referer,ts,is_new,account_no,province,city,ip,browser_name,os,device_type,start_time
    </sql>


    <!--统计总条数-->
    <select id="countTotal" resultType="java.lang.Integer">
        select count(1) from visit_stats  where  account_no=#{accountNo} and code=#{code} limit 1000
    </select>


    <!--分页查找-->
    <select id="pageVisitRecord" resultMap="BaseResultMap">
        select
        <include refid="Base_Column_List"/>
        from visit_stats where account_no=#{accountNo} and code=#{code}
        order by ts desc limit #{from},#{size}
    </select>



    <!--时间范围内地区访问分布-城市级别，天级别-->
    <select id="queryRegionVisitStatsWithDay" resultMap="BaseResultMap">
        select province,city,sum(pv) pv_count,sum(uv) uv_count,count( DISTINCT ip) ip_count from visit_stats
        where  account_no=#{accountNo} and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime} and #{endTime}
        group by province,city order by pv_count desc
    </select>



    <!-- 多天内的访问曲线图,天基本 -->
    <select id="queryVisitTrendWithMultiDay" resultMap="BaseResultMap">
        select toYYYYMMDD(start_time) date_time_str,sum(if(is_new='1', visit_stats.uv,0)) new_uv_count,
        sum(visit_stats.uv) uv_count, sum(pv) pv_count, count( DISTINCT ip) ip_count from visit_stats
        where account_no=#{accountNo} and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime}
        and #{endTime} group by date_time_str ORDER BY date_time_str desc
</select>



    <!-- 一天内的访问曲线图,小时 -->
    <select id="queryVisitTrendWithHour" resultMap="BaseResultMap">
        select toHour(start_time) date_time_str,sum(if(is_new='1', visit_stats.uv,0)) new_uv_count,
        sum(visit_stats.uv) uv_count, sum(pv) pv_count, count( DISTINCT ip) ip_count from visit_stats
        where  account_no=#{accountNo} and code=#{code} and toYYYYMMDD(start_time)=#{startTime}
        group by date_time_str ORDER BY date_time_str desc
    </select>




    <!-- 小时内的访问曲线图,每分钟，如果要每5分钟，则把 toMinute 改为 toStartOfFiveMinute -->
    <select id="queryVisitTrendWithMinute" resultMap="BaseResultMap">
        select toMinute(start_time) date_time_str,sum(if(is_new='1', visit_stats.uv,0)) new_uv_count,
        sum(visit_stats.uv) uv_count, sum(pv) pv_count, count( DISTINCT ip) ip_count from visit_stats
        where account_no=#{accountNo} and code=#{code} and toYYYYMMDDhhmmss(start_time) BETWEEN #{startTime}
        and #{endTime}
        group by date_time_str ORDER BY date_time_str desc
    </select>


    <!--高频referer查询 访问来源-->
    <select id="queryFrequentSource" resultMap="BaseResultMap">
    select referer,sum(pv) pv_count from visit_stats where
    account_no=#{accountNo} and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime} and #{endTime}
    group by referer  order by pv_count desc limit #{size}
    </select>




    <!--查询设备信息分布情况-->
    <select id="queryDeviceInfo" resultMap="BaseResultMap">
        <if test=" field=='os'">
            select os,sum(pv) pv_count from visit_stats where account_no=#{accountNo}
            and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime} and #{endTime}
            group by os order by pv_count
        </if>
        <if test=" field=='browser'">
            select browser_name,sum(pv) pv_count from visit_stats where account_no=#{accountNo}
             and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime} and #{endTime}
            group by browser_name order by pv_count
        </if>
        <if test=" field=='device'">
            select device_type,sum(pv) pv_count from visit_stats where account_no=#{accountNo}
             and code=#{code} and toYYYYMMDD(start_time) BETWEEN #{startTime} and #{endTime}
            group by device_type order by pv_count
        </if>
    </select>
</mapper>
```

#### 18.7.1ClickHouse数据库介绍

- 官方文档

```
官网：https://clickhouse.com/
中文：https://clickhouse.com/docs/zh/
GitHub: https://github.com/ClickHouse/ClickHouse
```

- 特点和应用场景

```
不依赖Hadoop生态、安装和维护简单
列存储在聚合、统计等操作性能会优于行存储
列存储将多行记录的列连续存储在⼀起，⼀列接着⼀列
列式存储是同个数据类型，会进行数据压缩率更高，更省空间
列存储数据更新成本较高，⼀般适合读多写少的场景，适合OLAP分析型系统
拓展性强，在⽣产中经过实战测试，从单服务器部署到具有数千个节点的集群的线性⽔平可扩展性
⽀持主流的⼤部分SQL语法和函数、吞吐能力强，官方测试⽀持，⽀持多种存储引擎，满足多数业务场景
广泛应用：互联网电商、在线教育、⾦融等领域用，户行为数据记录和分析，搭建数据可视化平台
```

#### 18.7.2Linux部署ClickHouse

##### 18.7.2.1RPM包安装

```
Linux机器安装ClickHouse，版本：ClickHouse 22.1.2.2
文档地址：https://clickhouse.com/docs/zh/getting-started/install/

直接使用rpm -ivh后⾯跟上所有的包安装就可以了
基本上不缺少其他依赖，安装之后clickhouse会自动加到systemd启动当中
```

- 安装流程

```
#1.安装把windows上的文件拖到linux上的安装包
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# yum -y install lrzsz vim


#2.创建clickhouse文件夹
[root@iZ2zeashk7kdvi5eievv7sZ ~]# mkdir /usr/local/software/clickhouse -p
[root@iZ2zeashk7kdvi5eievv7sZ ~]# cd /usr/local/software/clickhouse


#3.查看clickhouse需要的安装包
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# ls -l
total 907092
-rw-r--r-- 1 root root    131535 Jan  6 12:21 clickhouse-client-22.1.2.2-2.noarch.rpm
-rw-r--r-- 1 root root 215344894 Jan  6 12:22 clickhouse-common-static-22.1.2.2-2.x86_64.rpm
-rw-r--r-- 1 root root 713210726 Jan  6 12:23 clickhouse-common-static-dbg-22.1.2.2-2.x86_64.rpm
-rw-r--r-- 1 root root    156210 Jan  6 12:21 clickhouse-server-22.1.2.2-2.noarch.rpm


#4.进行clickhouse安装
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# sudo rpm -ivh *.rpm


#5.启动clickhouse
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# systemctl start clickhouse-server


#6.查看clickhouse状态
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# systemctl status clickhouse-server


#7.开启远程访问，取消下面的注释
[root@iZ2zeashk7kdvi5eievv7sZ clickhouse]# vim /etc/clickhouse-server/config.xml
183行  <listen_host>0.0.0.0</listen_host> 


#8.重启服务
[root@iZ2zeashk7kdvi5eievv7sZ ~]# systemctl restart clickhouse-server


#9.网络安全组记得开放http端口是8123
```

##### 18.7.2.2Docker安装

```
docker run -d --name liu_clickhouse --ulimit nofile=262144:262144 \
-p 8123:8123 -p 9000:9000 -p 9009:9009 --privileged=true \
-v /mydata/docker/clickhouse/log:/var/log/clickhouse-server \
-v /mydata/docker/clickhouse/data:/var/lib/clickhouse clickhouse/clickhouse-server:22.2.3.5
```

##### 18.7.2.3创建visit_stats表

```
CREATE TABLE default.visit_stats
(
	 `code` String,
	 `referer` String,
	 `is_new` UInt64,
	 `account_no` UInt64,
	 `province` String,
	 `city` String,
	 `ip` String,
	 `browser_name` String,
	 `os` String,
	 `device_type` String,
	 `pv` UInt64,
	 `uv` UInt64,
	 `start_time` DateTime,
	 `end_time` DateTime,
	 `ts` UInt64
 )
ENGINE = ReplacingMergeTree(ts)
PARTITION BY toYYYYMMDD(start_time)
ORDER BY (
start_time,
end_time,
code,
province,
city,
referer,
is_new,
ip,
browser_name,
os,
device_type);
```

#### 18.7.3Flink整合ClickHouse

##### 18.7.3.1添加依赖

```
<!--引入clickhouse依赖，排查版本影响-->
<dependency>
    <groupId>ru.yandex.clickhouse</groupId>
    <artifactId>clickhouse-jdbc</artifactId>
    <version>0.2.4</version>
    <exclusions>
        <exclusion>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </exclusion>
        <exclusion>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

##### 18.7.3.2数据库配置

- application.properties

```
#----------kafka配置--------------
kafka.servers=123.57.69.236:9092


#----------clickhouse配置--------------
clickhouse.servers=jdbc:clickhouse://123.57.69.236:8123/default
```

##### 18.7.3.3Sink输出ClickHouse

###### 18.7.3.3.1MyClickHouseSink

```
package net.xdclass.util;

import lombok.extern.slf4j.Slf4j;
import net.xdclass.model.ShortLinkVisitStatsDO;
import org.apache.flink.connector.jdbc.JdbcConnectionOptions;
import org.apache.flink.connector.jdbc.JdbcExecutionOptions;
import org.apache.flink.connector.jdbc.JdbcSink;
import org.apache.flink.connector.jdbc.JdbcStatementBuilder;
import org.apache.flink.streaming.api.functions.sink.SinkFunction;

import java.io.IOException;
import java.io.InputStream;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Properties;

/**
 * @author 刘森飚
 * @since 2023-02-17
 */


@Slf4j
public class MyClickHouseSink {

    /**
     * ClickHouse地址
     */
    private static String CLICK_HOUSE_SERVER = null;

    static {
        Properties properties = new Properties();
        InputStream in = KafkaUtil.class.getClassLoader().getResourceAsStream("application.properties");
        try {
            properties.load(in);
        } catch (IOException e) {
            log.error("加载ClickHouse配置文件失败,{}", e);
        }
        //获取key配置对应的value
        CLICK_HOUSE_SERVER = properties.getProperty("clickhouse.servers");

    }




    /**
     * 获取想ClikcHouseServer写入数据的sinkFunction
     * @param sql
     * @return
     */
    public static SinkFunction getJdbcSink(String sql) {

        SinkFunction<ShortLinkVisitStatsDO> sinkFunction = JdbcSink.sink
                (sql, new JdbcStatementBuilder<ShortLinkVisitStatsDO>() {
                    @Override
                    public void accept(PreparedStatement ps, ShortLinkVisitStatsDO obj) throws SQLException {
                        ps.setObject(1, obj.getCode());
                        ps.setObject(2, obj.getReferer());
                        ps.setObject(3, obj.getIsNew());
                        ps.setObject(4, obj.getAccountNo());
                        ps.setObject(5, obj.getProvince());
                        ps.setObject(6, obj.getCity());
                        ps.setObject(7, obj.getIp());
                        ps.setObject(8, obj.getBrowserName());
                        ps.setObject(9, obj.getOs());
                        ps.setObject(10, obj.getDeviceType());
                        ps.setObject(11, obj.getPv());
                        ps.setObject(12, obj.getUv());
                        ps.setObject(13, obj.getStartTime());
                        ps.setObject(14, obj.getEndTime());
                        ps.setObject(15, obj.getVisitTime());

                    }
                },
                //控制批量写入大小
                new JdbcExecutionOptions.Builder().withBatchSize(3).build(),
                //连接配置
                new JdbcConnectionOptions.JdbcConnectionOptionsBuilder()
                        .withUrl(CLICK_HOUSE_SERVER)
                        .withDriverName("ru.yandex.clickhouse.ClickHouseDriver")
                        .withUsername("default")
                        .build());
        return sinkFunction;
    }
}
```

###### 18.7.3.3.2DwsShortLinkVisitStatsApp

```
        //8、输出Clickhouse
        String sql = "insert into visit_stats values(?,?,?,? ,?,?,?,? ,?,?,?,? ,?,?,?)";
        reduceDS.addSink(MyClickHouseSink.getJdbcSink(sql));
```

##### 18.7.3.4Flink整合ClickHouse链路测试

- 全链路测试

http://localhost:8003/0372Oot0

- clickhouse插入情况

![1676737654924](短链平台项目.assets/1676737654924.png)

- DwsShortLinkVisitStatsApp测试数据

```
>>>>>>> ShortLinkVisitStatsDO(startTime=2023-02-19 12:21:50, endTime=2023-02-19 12:22:00, code=0372Oot0, accountNo=830033392337682432, visitTime=1676737311424, referer=taobao.com, isNew=1, udid=6B3EE101A189E335E81AA3CFEE1D598C, province=广东省, city=广州市, isp=null, ip=113.68.152.139, browserName=Chrome, os=Windows, osVersion= Win64, deviceType=COMPUTER, deviceManufacturer=MICROSOFT, uv=1, pv=1)


>>>>>>> ShortLinkVisitStatsDO(startTime=2023-02-19 12:22:10, endTime=2023-02-19 12:22:20, code=0372Oot0, accountNo=830033392337682432, visitTime=1676737339042, referer=taobao.com, isNew=1, udid=E0C7AE3D3BF5A857939902E2C473EDAF, province=广东省, city=深圳市, isp=null, ip=14.197.9.110, browserName=Chrome, os=Windows, osVersion= Win64, deviceType=COMPUTER, deviceManufacturer=MICROSOFT, uv=1, pv=1)

>>>>>>> ShortLinkVisitStatsDO(startTime=2023-02-19 12:22:40, endTime=2023-02-19 12:22:50, code=0372Oot0, accountNo=830033392337682432, visitTime=1676737363365, referer=taobao.com, isNew=0, udid=E0C7AE3D3BF5A857939902E2C473EDAF, province=广东省, city=深圳市, isp=null, ip=14.197.9.110, browserName=Chrome, os=Windows, osVersion= Win64, deviceType=COMPUTER, deviceManufacturer=MICROSOFT, uv=0, pv=1)
```

